<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>Tarifs de location du linge — SCI Dubuval — Été 2020</title>
  <meta charset="UTF-8"/>
  <style type="text/css">
   
/* <![CDATA[ */
body,div,table,thead,tbody,tfoot,tr,th,td,p {color: darkslategrey; font-family:Arial; font-size:medium;}
table.montablo {border:0; border-collapse: collapse}
table.montablo tr td {border: 1px solid; text-align: center; padding: 5px}
table.montablo tr.gras td {font-weight: bold; background-color: darkslategrey; color: mediumturquoise}
td.gras {font-weight: bold; background-color: darkslategrey; color: mediumturquoise}

/* ]]> */

  </style>
 </head>
 <body onpageshow="compute()">
  <script>
   
//<![CDATA[
//# 1 "mechanic.bc.runtime.js"
// Generated by js_of_ocaml 3.6.0
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return caml_utf16_of_utf8(this.c)
        }};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_jsstring_of_string(s){return s.toString()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = "_bigarray";
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:caml_ba_deserialize,
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === null)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var caml_ephe_blit_key=caml_weak_blit;
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape){case 0:case 1:case 2:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    var caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 "../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtra=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_make_forward=runtime.caml_obj_make_forward,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes("%,"),
     cst_really_input=caml_string_of_jsbytes("really_input"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_output_substring=caml_string_of_jsbytes("output_substring"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_12g=caml_string_of_jsbytes("%.12g"),
     cst=caml_string_of_jsbytes("."),
     cst_false$1=caml_string_of_jsbytes("false"),
     cst_true$1=caml_string_of_jsbytes("true"),
     cst_false$0=caml_string_of_jsbytes("false"),
     cst_true$0=caml_string_of_jsbytes("true"),
     cst_bool_of_string=caml_string_of_jsbytes("bool_of_string"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_char_of_int=caml_string_of_jsbytes("char_of_int"),
     cst_Stdlib_Exit=caml_string_of_jsbytes("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_string_of_jsbytes("option is None"),
     cst_result_is_Ok=caml_string_of_jsbytes("result is Ok _"),
     cst_result_is_Error=caml_string_of_jsbytes("result is Error _"),
     cst_true$2=caml_string_of_jsbytes("true"),
     cst_false$2=caml_string_of_jsbytes("false"),
     cst$1=caml_string_of_jsbytes("\\\\"),
     cst$2=caml_string_of_jsbytes("\\'"),
     cst_b=caml_string_of_jsbytes("\\b"),
     cst_t=caml_string_of_jsbytes("\\t"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst_r=caml_string_of_jsbytes("\\r"),
     cst_Char_chr=caml_string_of_jsbytes("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_string_of_jsbytes(" is not a latin1 character"),
     cst_04X=caml_string_of_jsbytes("%04X"),
     cst_U=caml_string_of_jsbytes("U+"),
     cst_is_not_an_Unicode_scalar_v=
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
     cst_X=caml_string_of_jsbytes("%X"),
     err_no_pred=caml_string_of_jsbytes("U+0000 has no predecessor"),
     err_no_succ=caml_string_of_jsbytes("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_string_of_jsbytes("Stdlib.Sys.Break"),
     ocaml_version=caml_string_of_jsbytes("4.10.0"),
     cst_List_map2=caml_string_of_jsbytes("List.map2"),
     cst_List_iter2=caml_string_of_jsbytes("List.iter2"),
     cst_List_fold_left2=caml_string_of_jsbytes("List.fold_left2"),
     cst_List_fold_right2=caml_string_of_jsbytes("List.fold_right2"),
     cst_List_for_all2=caml_string_of_jsbytes("List.for_all2"),
     cst_List_exists2=caml_string_of_jsbytes("List.exists2"),
     cst_List_combine=caml_string_of_jsbytes("List.combine"),
     cst_List_rev_map2=caml_string_of_jsbytes("List.rev_map2"),
     cst_List_init=caml_string_of_jsbytes("List.init"),
     cst_List_nth$0=caml_string_of_jsbytes("List.nth"),
     cst_nth=caml_string_of_jsbytes("nth"),
     cst_List_nth=caml_string_of_jsbytes("List.nth"),
     cst_tl=caml_string_of_jsbytes("tl"),
     cst_hd=caml_string_of_jsbytes("hd"),
     cst_Bytes_of_seq_cannot_grow_b=
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Byte=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_string_of_jsbytes("Bytes.concat"),
     cst_String_blit_Bytes_blit_str=
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_string_of_jsbytes("Bytes.blit"),
     cst_String_fill_Bytes_fill=
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_string_of_jsbytes("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Byte$0=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes$0=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt$0=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r$0=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte$0=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in$0=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_String_concat=caml_string_of_jsbytes("String.concat"),
     cst$5=caml_string_of_jsbytes("()"),
     cst_Marshal_from_bytes=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_string_of_jsbytes("Marshal.data_size"),
     cst_Marshal_to_buffer_substrin=
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_string_of_jsbytes("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Array_map2_arrays_must_hav=
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_ha=
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_string_of_jsbytes("Array.blit"),
     cst_Array_fill=caml_string_of_jsbytes("Array.fill"),
     cst_Array_sub=caml_string_of_jsbytes("Array.sub"),
     cst_Array_init=caml_string_of_jsbytes("Array.init"),
     cst_Stdlib_Array_Bottom=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_mu=
      caml_string_of_jsbytes
       ("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_m=
      caml_string_of_jsbytes
       ("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_array_blit$0=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_Array_fill=caml_string_of_jsbytes("Float.Array.fill"),
     cst_Float_Array_sub=caml_string_of_jsbytes("Float.Array.sub"),
     cst_Float_Array_concat=caml_string_of_jsbytes("Float.Array.concat"),
     cst_Float_Array_init=caml_string_of_jsbytes("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
     cst_d=caml_string_of_jsbytes("%d"),
     cst_d$0=caml_string_of_jsbytes("%d"),
     zero$2=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$2=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$2=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_string_of_jsbytes("%d"),
     cst_Lexing_lex_refill_cannot_g=
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     cst_syntax_error=caml_string_of_jsbytes("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_Set_bal=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$0=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$1=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$2=caml_string_of_jsbytes("Set.bal"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     cst_count=caml_string_of_jsbytes("{count = "),
     cst_data=caml_string_of_jsbytes("; data = "),
     cst$6=caml_string_of_jsbytes("}"),
     cst_Sempty=caml_string_of_jsbytes("Sempty"),
     cst_Scons=caml_string_of_jsbytes("Scons ("),
     cst$7=caml_string_of_jsbytes(", "),
     cst$8=caml_string_of_jsbytes(")"),
     cst_Sapp=caml_string_of_jsbytes("Sapp ("),
     cst$9=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(")"),
     cst_Slazy=caml_string_of_jsbytes("Slazy"),
     cst_Sgen=caml_string_of_jsbytes("Sgen"),
     cst_Sbuffio=caml_string_of_jsbytes("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_string_of_jsbytes("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_string_of_jsbytes("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_string_of_jsbytes("Buffer.truncate"),
     cst_Buffer_add_channel=caml_string_of_jsbytes("Buffer.add_channel"),
     cst_Buffer_add_substring_add_s=
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buf=
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_string_of_jsbytes("Buffer.nth"),
     cst_Buffer_blit=caml_string_of_jsbytes("Buffer.blit"),
     cst_Buffer_sub=caml_string_of_jsbytes("Buffer.sub"),
     cst_c=caml_string_of_jsbytes("%c"),
     cst_s=caml_string_of_jsbytes("%s"),
     cst_i=caml_string_of_jsbytes("%i"),
     cst_li=caml_string_of_jsbytes("%li"),
     cst_ni=caml_string_of_jsbytes("%ni"),
     cst_Li=caml_string_of_jsbytes("%Li"),
     cst_f=caml_string_of_jsbytes("%f"),
     cst_B=caml_string_of_jsbytes("%B"),
     cst$21=caml_string_of_jsbytes("%{"),
     cst$22=caml_string_of_jsbytes("%}"),
     cst$23=caml_string_of_jsbytes("%("),
     cst$24=caml_string_of_jsbytes("%)"),
     cst_a=caml_string_of_jsbytes("%a"),
     cst_t$0=caml_string_of_jsbytes("%t"),
     cst$25=caml_string_of_jsbytes("%?"),
     cst_r$0=caml_string_of_jsbytes("%r"),
     cst_r$1=caml_string_of_jsbytes("%_r"),
     cst_u$0=caml_string_of_jsbytes("%u"),
     cst_Printf_bad_conversion=
      caml_string_of_jsbytes("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=
      caml_string_of_jsbytes("Printf: bad conversion %_"),
     cst$30=caml_string_of_jsbytes("@{"),
     cst$31=caml_string_of_jsbytes("@["),
     cst$32=caml_string_of_jsbytes("@{"),
     cst$33=caml_string_of_jsbytes("@["),
     cst$34=caml_string_of_jsbytes("@{"),
     cst$35=caml_string_of_jsbytes("@["),
     cst_0=caml_string_of_jsbytes("0"),
     cst_padding=caml_string_of_jsbytes("padding"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst$40=caml_string_of_jsbytes("'*'"),
     cst$38=caml_string_of_jsbytes("'-'"),
     cst_0$2=caml_string_of_jsbytes("'0'"),
     cst$39=caml_string_of_jsbytes("'*'"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_0$1=caml_string_of_jsbytes("0"),
     cst_precision$0=caml_string_of_jsbytes("precision"),
     cst_precision$1=caml_string_of_jsbytes("precision"),
     cst$41=caml_string_of_jsbytes("'+'"),
     cst$42=caml_string_of_jsbytes("'#'"),
     cst$43=caml_string_of_jsbytes("' '"),
     cst_padding$0=caml_string_of_jsbytes("`padding'"),
     cst_precision$2=caml_string_of_jsbytes("`precision'"),
     cst$44=caml_string_of_jsbytes("'+'"),
     cst$45=caml_string_of_jsbytes("'_'"),
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_character=caml_string_of_jsbytes("character ')'"),
     cst_character$0=caml_string_of_jsbytes("character '}'"),
     cst$49=caml_string_of_jsbytes("'#'"),
     cst$46=caml_string_of_jsbytes("'+'"),
     cst$47=caml_string_of_jsbytes("'+'"),
     cst$48=caml_string_of_jsbytes("' '"),
     cst$50=caml_string_of_jsbytes("'+'"),
     cst_non_zero_widths_are_unsupp=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=
      caml_string_of_jsbytes("unexpected end of format"),
     cst$36=caml_string_of_jsbytes(""),
     cst$37=caml_string_of_jsbytes(""),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_hov=caml_string_of_jsbytes("hov"),
     cst_hv=caml_string_of_jsbytes("hv"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg_infinity=caml_string_of_jsbytes("neg_infinity"),
     cst_infinity=caml_string_of_jsbytes("infinity"),
     cst$29=caml_string_of_jsbytes("."),
     cst_nd$0=caml_string_of_jsbytes("%+nd"),
     cst_nd$1=caml_string_of_jsbytes("% nd"),
     cst_ni$1=caml_string_of_jsbytes("%+ni"),
     cst_ni$2=caml_string_of_jsbytes("% ni"),
     cst_nx=caml_string_of_jsbytes("%nx"),
     cst_nx$0=caml_string_of_jsbytes("%#nx"),
     cst_nX=caml_string_of_jsbytes("%nX"),
     cst_nX$0=caml_string_of_jsbytes("%#nX"),
     cst_no=caml_string_of_jsbytes("%no"),
     cst_no$0=caml_string_of_jsbytes("%#no"),
     cst_nd=caml_string_of_jsbytes("%nd"),
     cst_ni$0=caml_string_of_jsbytes("%ni"),
     cst_nu=caml_string_of_jsbytes("%nu"),
     cst_ld$0=caml_string_of_jsbytes("%+ld"),
     cst_ld$1=caml_string_of_jsbytes("% ld"),
     cst_li$1=caml_string_of_jsbytes("%+li"),
     cst_li$2=caml_string_of_jsbytes("% li"),
     cst_lx=caml_string_of_jsbytes("%lx"),
     cst_lx$0=caml_string_of_jsbytes("%#lx"),
     cst_lX=caml_string_of_jsbytes("%lX"),
     cst_lX$0=caml_string_of_jsbytes("%#lX"),
     cst_lo=caml_string_of_jsbytes("%lo"),
     cst_lo$0=caml_string_of_jsbytes("%#lo"),
     cst_ld=caml_string_of_jsbytes("%ld"),
     cst_li$0=caml_string_of_jsbytes("%li"),
     cst_lu=caml_string_of_jsbytes("%lu"),
     cst_Ld$0=caml_string_of_jsbytes("%+Ld"),
     cst_Ld$1=caml_string_of_jsbytes("% Ld"),
     cst_Li$1=caml_string_of_jsbytes("%+Li"),
     cst_Li$2=caml_string_of_jsbytes("% Li"),
     cst_Lx=caml_string_of_jsbytes("%Lx"),
     cst_Lx$0=caml_string_of_jsbytes("%#Lx"),
     cst_LX=caml_string_of_jsbytes("%LX"),
     cst_LX$0=caml_string_of_jsbytes("%#LX"),
     cst_Lo=caml_string_of_jsbytes("%Lo"),
     cst_Lo$0=caml_string_of_jsbytes("%#Lo"),
     cst_Ld=caml_string_of_jsbytes("%Ld"),
     cst_Li$0=caml_string_of_jsbytes("%Li"),
     cst_Lu=caml_string_of_jsbytes("%Lu"),
     cst_d$3=caml_string_of_jsbytes("%+d"),
     cst_d$4=caml_string_of_jsbytes("% d"),
     cst_i$1=caml_string_of_jsbytes("%+i"),
     cst_i$2=caml_string_of_jsbytes("% i"),
     cst_x=caml_string_of_jsbytes("%x"),
     cst_x$0=caml_string_of_jsbytes("%#x"),
     cst_X$0=caml_string_of_jsbytes("%X"),
     cst_X$1=caml_string_of_jsbytes("%#X"),
     cst_o=caml_string_of_jsbytes("%o"),
     cst_o$0=caml_string_of_jsbytes("%#o"),
     cst_d$2=caml_string_of_jsbytes("%d"),
     cst_i$0=caml_string_of_jsbytes("%i"),
     cst_u=caml_string_of_jsbytes("%u"),
     cst$26=caml_string_of_jsbytes("%!"),
     cst$27=caml_string_of_jsbytes("@{"),
     cst$28=caml_string_of_jsbytes("@["),
     cst_0c=caml_string_of_jsbytes("0c"),
     cst$20=caml_string_of_jsbytes("%%"),
     cst$12=caml_string_of_jsbytes("@]"),
     cst$13=caml_string_of_jsbytes("@}"),
     cst$14=caml_string_of_jsbytes("@?"),
     cst$15=caml_string_of_jsbytes("@\n"),
     cst$16=caml_string_of_jsbytes("@."),
     cst$17=caml_string_of_jsbytes("@@"),
     cst$18=caml_string_of_jsbytes("@%"),
     cst$19=caml_string_of_jsbytes("@"),
     cst$11=caml_string_of_jsbytes(".*"),
     cst_CamlinternalFormat_Type_mi=
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_string_of_jsbytes(""),
     cst$59=caml_string_of_jsbytes("\n"),
     cst_a_boolean=caml_string_of_jsbytes("a boolean"),
     cst_an_integer=caml_string_of_jsbytes("an integer"),
     cst_an_integer$0=caml_string_of_jsbytes("an integer"),
     cst_a_float=caml_string_of_jsbytes("a float"),
     cst_a_float$0=caml_string_of_jsbytes("a float"),
     cst$55=caml_string_of_jsbytes(""),
     cst$56=caml_string_of_jsbytes(" "),
     cst$57=caml_string_of_jsbytes(""),
     cst_one_of=caml_string_of_jsbytes("one of: "),
     cst_Arg_Expand_is_is_only_allo=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_string_of_jsbytes("no argument"),
     cst$54=caml_string_of_jsbytes("(?)"),
     cst_help$3=caml_string_of_jsbytes("--help"),
     cst_help$4=caml_string_of_jsbytes("-help"),
     cst_help$2=caml_string_of_jsbytes("-help"),
     cst_Display_this_list_of_optio=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help=caml_string_of_jsbytes("-help"),
     cst_help$1=caml_string_of_jsbytes("--help"),
     cst_Display_this_list_of_optio$0=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help$0=caml_string_of_jsbytes("--help"),
     cst$51=caml_string_of_jsbytes("}"),
     cst$52=caml_string_of_jsbytes("|"),
     cst$53=caml_string_of_jsbytes("{"),
     cst_none=caml_string_of_jsbytes("<none>"),
     cst_Stdlib_Arg_Bad=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     cst$61=caml_string_of_jsbytes(""),
     cst_Program_not_linked_with_g_=
      caml_string_of_jsbytes
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_string_of_jsbytes("Raised at"),
     cst_Re_raised_at=caml_string_of_jsbytes("Re-raised at"),
     cst_Raised_by_primitive_operat=
      caml_string_of_jsbytes("Raised by primitive operation at"),
     cst_Called_from=caml_string_of_jsbytes("Called from"),
     cst_inlined=caml_string_of_jsbytes(" (inlined)"),
     cst$64=caml_string_of_jsbytes(""),
     partial=[4,0,0,0,0],
     cst_Out_of_memory=caml_string_of_jsbytes("Out of memory"),
     cst_Stack_overflow=caml_string_of_jsbytes("Stack overflow"),
     cst_Pattern_matching_failed=
      caml_string_of_jsbytes("Pattern matching failed"),
     cst_Assertion_failed=caml_string_of_jsbytes("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_string_of_jsbytes("Undefined recursive module"),
     cst$62=caml_string_of_jsbytes(""),
     cst$63=caml_string_of_jsbytes(""),
     cst$60=caml_string_of_jsbytes("_"),
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     cst_Stdlib_Fun_Finally_raised=
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_from_hex=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_to_hex=caml_string_of_jsbytes("Digest.to_hex"),
     cst_Digest_substring=caml_string_of_jsbytes("Digest.substring"),
     cst_Random_int64=caml_string_of_jsbytes("Random.int64"),
     cst_Random_int32=caml_string_of_jsbytes("Random.int32"),
     cst_Random_int=caml_string_of_jsbytes("Random.int"),
     cst_x$1=caml_string_of_jsbytes("x"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_string_of_jsbytes("CAMLRUNPARAM"),
     cst$65=caml_string_of_jsbytes(""),
     cst_Weak_Make_hash_bucket_cann=
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_string_of_jsbytes("Weak.fill"),
     cst_Weak_blit=caml_string_of_jsbytes("Weak.blit"),
     cst_Weak_check=caml_string_of_jsbytes("Weak.check"),
     cst_Weak_get_copy=caml_string_of_jsbytes("Weak.get_copy"),
     cst_Weak_get=caml_string_of_jsbytes("Weak.get"),
     cst_Weak_set=caml_string_of_jsbytes("Weak.set"),
     cst_Weak_create=caml_string_of_jsbytes("Weak.create"),
     cst$83=caml_string_of_jsbytes(""),
     cst$84=caml_string_of_jsbytes(""),
     cst$82=caml_string_of_jsbytes("."),
     cst$79=caml_string_of_jsbytes(">"),
     cst$80=caml_string_of_jsbytes("<\/"),
     cst$81=caml_string_of_jsbytes(""),
     cst$76=caml_string_of_jsbytes(">"),
     cst$77=caml_string_of_jsbytes("<"),
     cst$78=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes("\n"),
     cst_Format_pp_set_geometry_max=
      caml_string_of_jsbytes("Format.pp_set_geometry: max_indent < 2"),
     cst_Format_pp_set_geometry_mar=
      caml_string_of_jsbytes("Format.pp_set_geometry: margin <= max_indent"),
     cst$71=caml_string_of_jsbytes(""),
     cst$72=caml_string_of_jsbytes(""),
     cst$73=caml_string_of_jsbytes(""),
     cst$74=caml_string_of_jsbytes(""),
     cst$67=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes(""),
     cst$70=caml_string_of_jsbytes(""),
     cst$66=caml_string_of_jsbytes(""),
     cst_Stdlib_Format_String_tag=
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=
      caml_string_of_jsbytes("end of input not found"),
     cst_scanf_bad_conversion_a=
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_string_of_jsbytes("scanf: missing reader"),
     cst_scanf_bad_conversion_custo=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst$90=caml_string_of_jsbytes('"'),
     cst$91=caml_string_of_jsbytes('"'),
     cst$88=caml_string_of_jsbytes('"'),
     cst$89=caml_string_of_jsbytes('"'),
     cst$87=caml_string_of_jsbytes('"'),
     cst_in_format=caml_string_of_jsbytes(' in format "'),
     cst_an=caml_string_of_jsbytes("an"),
     cst_x$2=caml_string_of_jsbytes("x"),
     cst_nfinity=caml_string_of_jsbytes("nfinity"),
     cst_digits=caml_string_of_jsbytes("digits"),
     cst_decimal_digits=caml_string_of_jsbytes("decimal digits"),
     cst_0b=caml_string_of_jsbytes("0b"),
     cst_0o=caml_string_of_jsbytes("0o"),
     cst_0u=caml_string_of_jsbytes("0u"),
     cst_0x=caml_string_of_jsbytes("0x"),
     cst_false$3=caml_string_of_jsbytes("false"),
     cst_true$3=caml_string_of_jsbytes("true"),
     cst_not_a_valid_float_in_hexad=
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_fo=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     cst$86=caml_string_of_jsbytes("-"),
     cst_unnamed_function=caml_string_of_jsbytes("unnamed function"),
     cst_unnamed_character_string=
      caml_string_of_jsbytes("unnamed character string"),
     cst_unnamed_Stdlib_input_chann=
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
     cst$85=caml_string_of_jsbytes("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_string_of_jsbytes("binary"),
     cst_octal=caml_string_of_jsbytes("octal"),
     cst_hexadecimal=caml_string_of_jsbytes("hexadecimal"),
     cst_a_Char=caml_string_of_jsbytes("a Char"),
     cst_a_String=caml_string_of_jsbytes("a String"),
     cst$92=caml_string_of_jsbytes(""),
     cst$93=caml_string_of_jsbytes(""),
     cst$94=caml_string_of_jsbytes(""),
     cst$95=caml_string_of_jsbytes(""),
     cst$96=caml_string_of_jsbytes(""),
     cst$98=caml_string_of_jsbytes(""),
     cst$97=caml_string_of_jsbytes(""),
     cst_Illegal_character=caml_string_of_jsbytes("Illegal character "),
     cst_Filename_chop_extension=
      caml_string_of_jsbytes("Filename.chop_extension"),
     cst$126=caml_string_of_jsbytes(""),
     cst_Filename_chop_suffix=caml_string_of_jsbytes("Filename.chop_suffix"),
     cst$125=caml_string_of_jsbytes(""),
     cst_2_1$0=caml_string_of_jsbytes(" 2>&1"),
     cst_2$0=caml_string_of_jsbytes(" 2>"),
     cst$124=caml_string_of_jsbytes(""),
     cst$116=caml_string_of_jsbytes(" >"),
     cst$123=caml_string_of_jsbytes(""),
     cst$117=caml_string_of_jsbytes(" <"),
     cst$122=caml_string_of_jsbytes(""),
     cst$118=caml_string_of_jsbytes(" "),
     cst$119=caml_string_of_jsbytes(" "),
     cst$120=caml_string_of_jsbytes('"'),
     cst$121=caml_string_of_jsbytes(""),
     cst_Filename_quote_command_bad=
      caml_string_of_jsbytes("Filename.quote_command: bad file name "),
     cst$114=caml_string_of_jsbytes('"'),
     cst$115=caml_string_of_jsbytes('"'),
     cst$112=caml_string_of_jsbytes("./"),
     cst$111=caml_string_of_jsbytes(".\\"),
     cst$110=caml_string_of_jsbytes("../"),
     cst$109=caml_string_of_jsbytes("..\\"),
     cst_2_1=caml_string_of_jsbytes(" 2>&1"),
     cst_2=caml_string_of_jsbytes(" 2>"),
     cst$108=caml_string_of_jsbytes(""),
     cst$103=caml_string_of_jsbytes(" >"),
     cst$107=caml_string_of_jsbytes(""),
     cst$104=caml_string_of_jsbytes(" <"),
     cst$106=caml_string_of_jsbytes(""),
     cst$105=caml_string_of_jsbytes(" "),
     cst$102=caml_string_of_jsbytes("./"),
     cst$101=caml_string_of_jsbytes("../"),
     cst$100=caml_string_of_jsbytes(""),
     cst$99=caml_string_of_jsbytes(""),
     null$0=caml_string_of_jsbytes("/dev/null"),
     current_dir_name=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep=caml_string_of_jsbytes("/"),
     cst_TMPDIR=caml_string_of_jsbytes("TMPDIR"),
     cst_tmp=caml_string_of_jsbytes("/tmp"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     null$1=caml_string_of_jsbytes("NUL"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     cst_TEMP=caml_string_of_jsbytes("TEMP"),
     cst$113=caml_string_of_jsbytes("."),
     null$2=caml_string_of_jsbytes("/dev/null"),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$1=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     cst_Cygwin=caml_string_of_jsbytes("Cygwin"),
     cst_Win32=caml_string_of_jsbytes("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Series_is_closed$0=caml_string_of_jsbytes("Series is closed"),
     cst_Series_is_closed=caml_string_of_jsbytes("Series is closed"),
     cst_Bigarray_array3_of_genarra=
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarra=
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarra=
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarra=
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_n$0=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _o_=[0,0,0],
     _s_=[0,caml_string_of_jsbytes("array.ml"),238,4],
     _u_=[0,caml_string_of_jsbytes("float.ml"),381,6],
     _t_=[0,caml_string_of_jsbytes("float.ml"),208,14],
     _F_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _E_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _D_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _C_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _G_=[0,0,0,0],
     _H_=[0,0,0],
     _I_=[0,caml_string_of_jsbytes("set.ml"),547,18],
     _J_=[0,0,0,0],
     _K_=[0,caml_string_of_jsbytes("map.ml"),398,10],
     _L_=[0,0,0],
     _M_=[0,caml_string_of_jsbytes("stream.ml"),53,12],
     _N_=[0,0],
     _O_=[0,caml_string_of_jsbytes("stream.ml"),82,12],
     _Y_=[0,caml_string_of_jsbytes("buffer.ml"),282,9],
     _X_=[0,caml_string_of_jsbytes("buffer.ml"),263,2],
     _W_=[0,caml_string_of_jsbytes("buffer.ml"),195,19],
     _V_=[0,caml_string_of_jsbytes("buffer.ml"),213,8],
     _U_=[0,caml_string_of_jsbytes("buffer.ml"),174,19],
     _T_=[0,caml_string_of_jsbytes("buffer.ml"),192,8],
     _S_=[0,caml_string_of_jsbytes("buffer.ml"),138,19],
     _R_=[0,caml_string_of_jsbytes("buffer.ml"),171,8],
     _Q_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _P_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     ___=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _ab_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _ac_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _ad_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _$_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _aa_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _ap_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _aq_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1830,8],
     _aX_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aW_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aA_=[0,1,0],
     _aB_=[0,0],
     _aC_=[1,0],
     _aD_=[1,1],
     _aF_=[1,1],
     _aE_=[1,1],
     _aJ_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aG_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aH_=[0,0],
     _aI_=[0,0],
     _aK_=[0,[12,64,0]],
     _aL_=[0,caml_string_of_jsbytes("@ "),1,0],
     _aM_=[0,caml_string_of_jsbytes("@,"),0,0],
     _aN_=[2,60],
     _aO_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aP_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aQ_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2837,11],
     _aR_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aS_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2899,34],
     _aT_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2935,28],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2957,11],
     _aV_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _ax_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _aw_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _av_=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _au_=[0,0,4],
     _ao_=[0,103],
     _Z_=[0,0,0],
     _bh_=[0,[2,0,[0,0]],caml_string_of_jsbytes("%s%c")],
     _bb_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bc_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ba_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a9_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a__=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a3_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _a6_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a7_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _a4_=[0,caml_string_of_jsbytes("-help")],
     _a5_=[0,caml_string_of_jsbytes("--help")],
     _a2_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a1_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _a0_=[0,caml_string_of_jsbytes("-help")],
     _aY_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _aZ_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _bm_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _bv_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bt_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bu_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _br_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(' file "'),
         [2,
          0,
          [12,
           34,
           [2,
            0,
            [11,
             caml_string_of_jsbytes(", line "),
             [4,
              0,
              0,
              0,
              [11,
               caml_string_of_jsbytes(", characters "),
               [4,0,0,0,[12,45,partial]]]]]]]]]],
       caml_string_of_jsbytes('%s file "%s"%s, line %d, characters %d-%d')],
     _bs_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _bq_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bp_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bn_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _bo_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _bl_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bk_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _bD_=
      [0,
       [11,caml_string_of_jsbytes("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("minor_collections: %d\n")],
     _bE_=
      [0,
       [11,caml_string_of_jsbytes("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("major_collections: %d\n")],
     _bF_=
      [0,
       [11,caml_string_of_jsbytes("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("compactions:       %d\n")],
     _bG_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bH_=[0,[8,[0,0,0],0,[0,0],0],caml_string_of_jsbytes("%.0f")],
     _bI_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("minor_words:    %*.0f\n")],
     _bJ_=
      [0,
       [11,
        caml_string_of_jsbytes("promoted_words: "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("promoted_words: %*.0f\n")],
     _bK_=
      [0,
       [11,
        caml_string_of_jsbytes("major_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("major_words:    %*.0f\n")],
     _bL_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bM_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bN_=
      [0,
       [11,caml_string_of_jsbytes("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("top_heap_words: %*d\n")],
     _bO_=
      [0,
       [11,caml_string_of_jsbytes("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("heap_words:     %*d\n")],
     _bP_=
      [0,
       [11,caml_string_of_jsbytes("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("live_words:     %*d\n")],
     _bQ_=
      [0,
       [11,caml_string_of_jsbytes("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("free_words:     %*d\n")],
     _bR_=
      [0,
       [11,caml_string_of_jsbytes("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("largest_free:   %*d\n")],
     _bS_=
      [0,
       [11,caml_string_of_jsbytes("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("fragments:      %*d\n")],
     _bT_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bU_=
      [0,
       [11,caml_string_of_jsbytes("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("live_blocks: %d\n")],
     _bV_=
      [0,
       [11,caml_string_of_jsbytes("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("free_blocks: %d\n")],
     _bW_=
      [0,
       [11,caml_string_of_jsbytes("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("heap_chunks: %d\n")],
     _bZ_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b0_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _b1_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _b5_=[0,0],
     _b4_=[0,caml_string_of_jsbytes("hashtbl.ml"),102,23],
     _b8_=[3,0,3],
     _b7_=[0,caml_string_of_jsbytes("")],
     _b6_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _cm_=[0,91],
     _cl_=[0,123],
     _cn_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _co_=[0,[3,0,[10,0]],caml_string_of_jsbytes("%S%!")],
     _ck_=[0,37,caml_string_of_jsbytes("")],
     _cj_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _ci_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _ch_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _cg_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _cf_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _ce_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _cd_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _cc_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _cb_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _ca_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _b$_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _b__=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _cv_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),438,17],
     _cu_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),420,13],
     _ct_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),417,13],
     _cs_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),414,13],
     _cr_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),411,13],
     _cq_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),408,13],
     _cp_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),281,50],
     _cy_=[0,0],
     _cx_=[0,0],
     _cw_=[0,0],
     _cD_=[0,7,0],
     _cC_=[0,1,[0,3,[0,5,0]]],
     _cB_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _cA_=[0,caml_string_of_jsbytes('"'),0],
     _cE_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (734,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_string_of_jsbytes("" + n)}
    function int_of_string_opt(s)
     {try
       {var _As_=[0,caml_int_of_string(s)];return _As_}
      catch(_At_)
       {_At_ = caml_wrap_exception(_At_);
        if(_At_[1] === Failure)return 0;
        throw _At_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,cst);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _Aq_=[0,caml_float_of_string(s)];return _Aq_}
      catch(_Ar_)
       {_Ar_ = caml_wrap_exception(_Ar_);
        if(_Ar_[1] === Failure)return 0;
        throw _Ar_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_Ap_)
             {_Ap_ = caml_wrap_exception(_Ap_);
              if(_Ap_[1] !== Sys_error)throw _Ap_;
              var _Ao_=_Ap_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_An_){}
      try
       {var _Al_=caml_ml_close_channel(oc);return _Al_}
      catch(_Am_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _Ak_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _Ak_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _Ak_=res}
        return caml_string_of_bytes(_Ak_)}}
    function close_in_noerr(ic)
     {try
       {var _Ai_=caml_ml_close_channel(ic);return _Ai_}
      catch(_Aj_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_string_of_jsbytes("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_string_of_jsbytes("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol$0(param,_Ag_)
     {var
       str2=_Ag_[2],
       fmt2=_Ag_[1],
       str1=param[2],
       fmt1=param[1],
       _Ah_=symbol(str1,symbol(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_Ah_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1],f_already_ran=[0,0];
      exit_function[1]
      =
      function(param)
       {if(1 - f_already_ran[1]){f_already_ran[1] = 1;caml_call1(f,0)}
        return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(747,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(748,Stdlib_pervasives,"Stdlib__pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _Ae_=function(_Af_){return map(f,next,_Af_)};
        return [0,caml_call1(f,x),_Ae_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Ad_){return filter_map(f,next,_Ad_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Ac_){return filter(f,next,_Ac_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Ab_=caml_call1(f,x),_Aa_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_Ab_,next,_Aa_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_Ab_,next,_Aa_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_z$_){return flat_map_app(f,next,tail,_z$_)}]}
      var _z__=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_z__)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_z__])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    var
     Stdlib_seq=
      [0,empty,return$0,map,filter,filter_map,flat_map,fold_left,iter];
    caml_register_global(749,Stdlib_seq,"Stdlib__seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param){if(param){var o=param[1];return o}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _z9_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_z9_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_z8_){return return$0(v,_z8_)}}
      return empty}
    var
     Stdlib_option=
      [0,
       none,
       some,
       value,
       get,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(750,Stdlib_option,"Stdlib__option");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$1(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$0(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$0(ok,error,r0,match)
     {if(0 === r0[0])
       {var _z6_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_z6_,v1)}}
      else
       {var _z7_=r0[1];
        if(0 !== match[0]){var e1=match[1];return caml_call2(error,_z7_,e1)}}
      return 0}
    function compare$0(ok,error,r0,match)
     {if(0 === r0[0])
       {var _z4_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_z4_,v1)}
        return -1}
      var _z5_=r0[1];
      if(0 === match[0])return 1;
      var e1=match[1];
      return caml_call2(error,_z5_,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_z3_){return return$0(v,_z3_)}}
      return empty}
    var
     Stdlib_result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$1,
       map_error,
       fold$0,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$0,
       compare$0,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(751,Stdlib_result,"Stdlib__result");
    function equal$1(_z2_,_z1_){return _z2_ === _z1_?1:0}
    var compare$1=caml_int_compare;
    function to_int(param){return param?1:0}
    function to_float(param){return param?1.:0.}
    function to_string$0(param){return param?cst_true$2:cst_false$2}
    var
     Stdlib_bool=
      [0,
       function(_z0_){return 1 - _z0_},
       equal$1,
       compare$1,
       to_int,
       to_float,
       to_string$0];
    caml_register_global(752,Stdlib_bool,"Stdlib__bool");
    function chr(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return cst$1;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var switch$0=0;
      if(! (65 <= c) || 90 < c)switch$0 = 1;
      if(switch$0)
       {var switch$1=0;
        if(! (192 <= c) || 214 < c)switch$1 = 1;
        if(switch$1)
         {var switch$2=0;
          if(! (216 <= c) || 222 < c)switch$2 = 1;
          if(switch$2)return c}}
      return c + 32 | 0}
    function uppercase(c)
     {var switch$0=0;
      if(! (97 <= c) || 122 < c)switch$0 = 1;
      if(switch$0)
       {var switch$1=0;
        if(! (224 <= c) || 246 < c)switch$1 = 1;
        if(switch$1)
         {var switch$2=0;
          if(! (248 <= c) || 254 < c)switch$2 = 1;
          if(switch$2)return c}}
      return c - 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c && ! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c && ! (122 < c))return c - 32 | 0;return c}
    function compare$2(c1,c2){return c1 - c2 | 0}
    function equal$2(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$2,
       equal$2];
    caml_register_global(753,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _zW_=0 <= i?1:0,_zX_=_zW_?i <= 55295?1:0:_zW_;
      if(_zX_)
       var _zY_=_zX_;
      else
       var _zZ_=57344 <= i?1:0,_zY_=_zZ_?i <= 1114111?1:0:_zZ_;
      return _zY_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (symbol
                  (caml_format_int(cst_X,i),cst_is_not_an_Unicode_scalar_v))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (symbol
                  (cst_U,
                   symbol
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_zV_){return _zV_}
    function equal$3(_zU_,_zT_){return _zU_ === _zT_?1:0}
    var compare$3=caml_int_compare;
    function hash(_zS_){return _zS_}
    function _m_(_zR_){return _zR_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_zQ_){return _zQ_},
       _m_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$3,
       compare$3,
       hash];
    caml_register_global(754,Stdlib_uchar,"Stdlib__uchar");
    var
     executable_name=runtime.caml_sys_executable_name(0),
     match=runtime.caml_sys_get_config(0),
     os_type=match[1],
     match$0=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     big_endian=0,
     match$1=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _zO_=[0,caml_sys_getenv(s)];return _zO_}
      catch(_zP_)
       {_zP_ = caml_wrap_exception(_zP_);
        if(_zP_ === Not_found)return 0;
        throw _zP_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    function Make(_zN_,_zM_){return [0,1]}
    var
     Immediate64=[0,Make],
     Stdlib_sys=
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       match$0,
       unix,
       win32,
       cygwin,
       match$1,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
    caml_register_global(755,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$0 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$2(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$2(f,l)]}
      return 0}
    function _n_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_n_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _n_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zL_=caml_call1(p,a);
          if(_zL_){var param$0=l;continue}
          return _zL_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zK_=caml_call1(p,a);
          if(_zK_)return _zK_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _zJ_=caml_call2(p,a1,a2);
            if(_zJ_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _zJ_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _zI_=caml_call2(p,a1,a2);
            if(_zI_)return _zI_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zH_=0 === caml_compare(a,x)?1:0;
          if(_zH_)return _zH_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zG_=a === x?1:0;
          if(_zG_)return _zG_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _zF_=0 === caml_compare(a,x)?1:0;
          if(_zF_)return _zF_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_zE_=a === x?1:0;
          if(_zE_)return _zE_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],result=caml_call1(f,x);
          if(result)return result;
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function concat_map(f,param)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           xs=caml_call1(f,x),
           acc$0=rev_append(xs,acc),
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _zD_=rev(no);
        return [0,rev(yes),_zD_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _o_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function fast_sort(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zz_=l[2];
            if(_zz_)
             {var
               tl=_zz_[2],
               x2=_zz_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _zB_=l[2];
           if(_zB_)
            {var _zC_=_zB_[2];
             if(_zC_)
              {var
                tl$1=_zC_[2],
                x3=_zC_[1],
                x2$0=_zB_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x1$0,x3)
                    ?0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                      :[0,x2$0,[0,x3,[0,x1$0,0]]]
                    :[0,x2$0,[0,x1$0,[0,x3,0]]]
                  :0 < caml_call2(cmp,x2$0,x3)
                    ?0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                      :[0,x1$0,[0,x3,[0,x2$0,0]]]
                    :[0,x1$0,[0,x2$0,[0,x3,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            var _zA_=rev_append(l1,accu)}
          else
           var _zA_=rev_append(l2,accu);
          return [0,_zA_,tl$0]}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zv_=l[2];
            if(_zv_)
             {var
               tl=_zv_[2],
               x2=_zv_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _zx_=l[2];
           if(_zx_)
            {var _zy_=_zx_[2];
             if(_zy_)
              {var
                tl$1=_zy_[2],
                x3=_zy_[1],
                x2$0=_zx_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x2$0,x3)
                    ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                      :[0,x3,[0,x1$0,[0,x2$0,0]]]
                  :0 < caml_call2(cmp,x1$0,x3)
                    ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                      :[0,x3,[0,x2$0,[0,x1$0,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            var _zw_=rev_append(l1,accu)}
          else
           var _zw_=rev_append(l2,accu);
          return [0,_zw_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function sort_uniq(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zm_=l[2];
            if(_zm_)
             {var
               tl=_zm_[2],
               x2=_zm_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _zo_=l[2];
           if(_zo_)
            {var _zp_=_zo_[2];
             if(_zp_)
              {var
                tl$1=_zp_[2],
                x3=_zp_[1],
                x2$0=_zo_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _zq_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]],
                 s$0=_zq_;
               else
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)
                   var _zr_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 <= c$3)
                    var
                     c$4=caml_call2(cmp,x2$0,x3),
                     _zs_=
                      0 === c$4
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 <= c$4
                         ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                         :[0,x2$0,[0,x3,[0,x1$0,0]]],
                     _zr_=_zs_;
                   else
                    var _zr_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                  var s$0=_zr_}
                else
                 {var c$5=caml_call2(cmp,x2$0,x3);
                  if(0 === c$5)
                   var _zt_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 <= c$5)
                    var
                     c$6=caml_call2(cmp,x1$0,x3),
                     _zu_=
                      0 === c$6
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 <= c$6
                         ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                         :[0,x1$0,[0,x3,[0,x2$0,0]]],
                     _zt_=_zu_;
                   else
                    var _zt_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                  var s$0=_zt_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            var _zn_=rev_append(l1,accu)}
          else
           var _zn_=rev_append(l2,accu);
          return [0,_zn_,tl$0]}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zd_=l[2];
            if(_zd_)
             {var
               tl=_zd_[2],
               x2=_zd_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _zf_=l[2];
           if(_zf_)
            {var _zg_=_zf_[2];
             if(_zg_)
              {var
                tl$1=_zg_[2],
                x3=_zg_[1],
                x2$0=_zf_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _zh_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]],
                 s$0=_zh_;
               else
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)
                   var _zi_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 < c$3)
                    var _zi_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                   else
                    var
                     c$4=caml_call2(cmp,x1$0,x3),
                     _zj_=
                      0 === c$4
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 < c$4
                         ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x3,[0,x1$0,[0,x2$0,0]]],
                     _zi_=_zj_;
                  var s$0=_zi_}
                else
                 {var c$5=caml_call2(cmp,x1$0,x3);
                  if(0 === c$5)
                   var _zk_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 < c$5)
                    var _zk_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                   else
                    var
                     c$6=caml_call2(cmp,x2$0,x3),
                     _zl_=
                      0 === c$6
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$6
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]],
                     _zk_=_zl_;
                  var s$0=_zk_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            var _ze_=rev_append(l1,accu)}
          else
           var _ze_=rev_append(l2,accu);
          return [0,_ze_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_zc_){return aux(tail,_zc_)}]}
        return 0}
      return function(_zb_){return aux(l,_zb_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _za_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_za_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$2,
       iteri,
       map$2,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(756,include,"Stdlib__list");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_y__=n - 1 | 0,_y9_=0;
      if(! (_y__ < 0))
       {var i=_y9_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _y$_=i + 1 | 0;
          if(_y__ !== i){var i=_y$_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string$1(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function symbol$1(a,b)
     {var c=a + b | 0,_y8_=b < 0?1:0,match=c < 0?1:0,switch$0=0;
      if(a < 0)
       {if(_y8_ && ! match)switch$0 = 1}
      else
       if(! _y8_ && match)switch$0 = 1;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$1(symbol$1(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var dstoff=left,srcoff=0;
      else
       var dstoff=0,srcoff=- left | 0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_str)}
    function iter$3(f,a)
     {var _y6_=caml_ml_bytes_length(a) - 1 | 0,_y5_=0;
      if(! (_y6_ < 0))
       {var i=_y5_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _y7_=i + 1 | 0;
          if(_y6_ !== i){var i=_y7_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _y3_=caml_ml_bytes_length(a) - 1 | 0,_y2_=0;
      if(! (_y3_ < 0))
       {var i=_y2_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _y4_=i + 1 | 0;
          if(_y3_ !== i){var i=_y4_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _yZ_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_bytes_length(_yZ_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _y1_=caml_ml_bytes_length(_yZ_) + acc | 0}
          else
           var _y1_=acc;
          var dst=caml_create_bytes(_y1_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _y0_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_bytes(_y0_,0,dst,pos,caml_ml_bytes_length(_y0_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_y0_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_y0_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_bytes(_y0_,0,dst,pos,caml_ml_bytes_length(_y0_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var _yY_=param - 9 | 0,switch$0=0;
      if(4 < _yY_ >>> 0)
       {if(23 === _yY_)switch$0 = 1}
      else
       if(2 !== _yY_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s,j[1])))
           {j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_yR_=caml_ml_bytes_length(s) - 1 | 0,_yQ_=0;
      if(! (_yR_ < 0))
       {var i$0=_yQ_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _yV_=match - 34 | 0,switch$1=0;
            if(58 < _yV_ >>> 0)
             {if(93 <= _yV_)switch$1 = 1}
            else
             if(56 < (_yV_ - 1 | 0) >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _yW_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _yW_=4;break;case 1:var _yW_=2;break}
          n[1] = n[1] + _yW_ | 0;
          var _yX_=i$0 + 1 | 0;
          if(_yR_ !== i$0){var i$0=_yX_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _yT_=caml_ml_bytes_length(s) - 1 | 0,_yS_=0;
      if(! (_yT_ < 0))
       {var i=_yS_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _yU_=i + 1 | 0;
          if(_yT_ !== i){var i=_yU_;continue}
          break}}
      return s$0}
    function map$3(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_yO_=l - 1 | 0,_yN_=0;
      if(! (_yO_ < 0))
       {var i=_yN_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _yP_=i + 1 | 0;
          if(_yO_ !== i){var i=_yP_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_yL_=l - 1 | 0,_yK_=0;
      if(! (_yL_ < 0))
       {var i=_yK_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _yM_=i + 1 | 0;
          if(_yL_ !== i){var i=_yM_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$3(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$3(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))
       return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _yI_=1;return _yI_}
       catch(_yJ_)
        {_yJ_ = caml_wrap_exception(_yJ_);
         if(_yJ_ === Not_found)return 0;
         throw _yJ_}
      return invalid_arg(cst_String_contains_from_Bytes)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i && ! (caml_ml_bytes_length(s) <= i))
       try
        {rindex_rec(s,i,c);var _yG_=1;return _yG_}
       catch(_yH_)
        {_yH_ = caml_wrap_exception(_yH_);
         if(_yH_ === Not_found)return 0;
         throw _yH_}
      return invalid_arg(cst_String_rcontains_from_Byte)}
    var compare$4=runtime.caml_bytes_compare;
    function uppercase$0(s){return map$3(uppercase,s)}
    function lowercase$0(s){return map$3(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_yE_=i + 1 | 0;
        return [0,x,function(_yF_){return aux(_yE_,_yF_)}]}
      var _yC_=0;
      return function(_yD_){return aux(_yC_,_yD_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_yA_=i + 1 | 0;
        return [0,[0,i,x],function(_yB_){return aux(_yA_,_yB_)}]}
      var _yy_=0;
      return function(_yz_){return aux(_yy_,_yz_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_b);
            var new_buf=make(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$4=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$3,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$4,
       equal$4,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(757,include$0,"Stdlib__bytes");
    function make$0(n,c){return caml_string_of_bytes(make(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _yv_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_string_length(_yv_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _yx_=caml_ml_string_length(_yv_) + acc | 0}
          else
           var _yx_=acc;
          var dst=caml_create_bytes(_yx_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _yw_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_string(_yw_,0,dst,pos,caml_ml_string_length(_yw_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_yw_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_yw_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_string(_yw_,0,dst,pos,caml_ml_string_length(_yw_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _yt_=caml_ml_string_length(s) - 1 | 0,_ys_=0;
      if(! (_yt_ < 0))
       {var i=_ys_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _yu_=i + 1 | 0;
          if(_yt_ !== i){var i=_yu_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _yq_=caml_ml_string_length(s) - 1 | 0,_yp_=0;
      if(! (_yq_ < 0))
       {var i=_yp_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _yr_=i + 1 | 0;
          if(_yq_ !== i){var i=_yr_;continue}
          break}}
      return 0}
    function map$4(f,s)
     {return caml_string_of_bytes(map$3(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var _yo_=param - 9 | 0,switch$0=0;
      if(4 < _yo_ >>> 0)
       {if(23 === _yo_)switch$0 = 1}
      else
       if(2 !== _yo_)switch$0 = 1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var match=caml_string_unsafe_get(s,i),_yn_=match - 32 | 0,switch$0=0;
        if(59 < _yn_ >>> 0)
         {if(33 < (_yn_ - 61 | 0) >>> 0)switch$0 = 1}
        else
         if(2 === _yn_)switch$0 = 1;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec$0(s,l,i,c);var _yl_=1;return _yl_}
       catch(_ym_)
        {_ym_ = caml_wrap_exception(_ym_);
         if(_ym_ === Not_found)return 0;
         throw _ym_}
      return invalid_arg(cst_String_contains_from_Bytes$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i && ! (caml_ml_string_length(s) <= i))
       try
        {rindex_rec$0(s,i,c);var _yj_=1;return _yj_}
       catch(_yk_)
        {_yk_ = caml_wrap_exception(_yk_);
         if(_yk_ === Not_found)return 0;
         throw _yk_}
      return invalid_arg(cst_String_rcontains_from_Byte$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    var compare$5=caml_string_compare;
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _yf_=caml_ml_string_length(s) - 1 | 0;
      if(! (_yf_ < 0))
       {var i=_yf_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _yh_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_yh_];
            j[1] = i}
          var _yi_=i - 1 | 0;
          if(0 !== i){var i=_yi_;continue}
          break}}
      var _yg_=r[1];
      return [0,sub$0(s,0,j[1]),_yg_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$5=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$4,
       iteri$1,
       map$4,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$5,
       equal$5,
       split_on_char,
       to_seq$3,
       to_seqi$0,
       of_seq$1];
    caml_register_global(758,include$1,"Stdlib__string");
    function equal$6(param,_ye_){return 1}
    function compare$6(param,_yd_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_unit=[0,equal$6,compare$6,to_string$2];
    caml_register_global(759,Stdlib_unit,"Stdlib__unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_bytes_length(buff) - len | 0) < ofs))
       return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substrin)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       {var len=caml_marshal_data_size(buff,ofs);
        return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                ?invalid_arg(cst_Marshal_from_bytes$0)
                :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(760,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    var double_field=caml_array_get,set_double_field=caml_array_set;
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _yc_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_yc_]}
    var
     first_non_constant_constructor=0,
     last_non_constant_constructor_=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function of_val(x)
     {var switch$0=0;
      if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1)
       {var slot=x[1];switch$0 = 1}
      if(! switch$0)var slot=x;
      var switch$1=0;
      if(is_block(slot) && caml_obj_tag(slot) === 248)
       {var name=slot[1];switch$1 = 1}
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _ya_=0 <= l?1:0,_yb_=_ya_?l <= max_ephe_length?1:0:_ya_;
      if(1 - _yb_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _x9_=0 <= o?1:0,_x__=_x9_?o < length$0(e)?1:0:_x9_,_x$_=1 - _x__;
      return _x$_?invalid_arg(msg):_x$_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$0(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$0(e2) - l | 0) < o2))
       {var
         _x7_=0 !== l?1:0,
         _x8_=_x7_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_x7_;
        return _x8_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _p_=runtime.caml_ephe_blit_data,
     _q_=runtime.caml_ephe_check_data,
     _r_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_x6_){return runtime.caml_ephe_unset_data(_x6_)},
       _q_,
       _p_,
       max_ephe_length],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _r_];
    caml_register_global(761,Stdlib_obj,"Stdlib__obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_x4_=l - 1 | 0,_x3_=1;
        if(! (_x4_ < 1))
         {var i=_x3_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _x5_=i + 1 | 0;
            if(_x4_ !== i){var i=_x5_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_x1_=sx - 1 | 0,_x0_=0;
      if(! (_x1_ < 0))
       {var x=_x0_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _x2_=x + 1 | 0;
          if(_x1_ !== x){var x=_x2_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return runtime.caml_array_fill(a,ofs,len,v);
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _xY_=a.length - 1 - 1 | 0,_xX_=0;
      if(! (_xY_ < 0))
       {var i=_xX_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _xZ_=i + 1 | 0;
          if(_xY_ !== i){var i=_xZ_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_ha);
      var _xV_=a.length - 1 - 1 | 0,_xU_=0;
      if(! (_xV_ < 0))
       {var i=_xU_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _xW_=i + 1 | 0;
          if(_xV_ !== i){var i=_xW_;continue}
          break}}
      return 0}
    function map$5(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_xS_=l - 1 | 0,_xR_=1;
      if(! (_xS_ < 1))
       {var i=_xR_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xT_=i + 1 | 0;
          if(_xS_ !== i){var i=_xT_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Array_map2_arrays_must_hav);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_xP_=la - 1 | 0,_xO_=1;
      if(! (_xP_ < 1))
       {var i=_xO_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _xQ_=i + 1 | 0;
          if(_xP_ !== i){var i=_xQ_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _xM_=a.length - 1 - 1 | 0,_xL_=0;
      if(! (_xM_ < 0))
       {var i=_xL_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _xN_=i + 1 | 0;
          if(_xM_ !== i){var i=_xN_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_xJ_=l - 1 | 0,_xI_=1;
      if(! (_xJ_ < 1))
       {var i=_xI_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _xK_=i + 1 | 0;
          if(_xJ_ !== i){var i=_xK_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_xG_=a.length - 1 - 1 | 0,_xF_=0;
      if(! (_xG_ < 0))
       {var i=_xF_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _xH_=i + 1 | 0;
          if(_xG_ !== i){var i=_xH_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_xD_=a.length - 1 - 1 | 0;
      if(! (_xD_ < 0))
       {var i=_xD_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _xE_=i - 1 | 0;
          if(0 !== i){var i=_xE_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _xw_=i31 + 1 | 0,_xx_=caml_check_bound(a,_xw_)[1 + _xw_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_xx_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _xy_=i31 + 2 | 0,
           _xz_=caml_check_bound(a,_xy_)[1 + _xy_],
           _xA_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_xA_)[1 + _xA_],_xz_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _xB_=i31 + 1 | 0,_xC_=caml_check_bound(a,_xB_)[1 + _xB_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_xC_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _xv_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _xv_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _xu_=trickledown(l,i,e);return _xu_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_xt_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _xt_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _xs_=bubbledown(l,i);return _xs_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xk_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xk_ < 0))
       {var i$2=_xk_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _xr_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_xr_;continue}
          break}}
      var _xl_=l - 1 | 0;
      if(! (_xl_ < 2))
       {var i$0=_xl_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _xp_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _xp_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_s_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _xj_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _xj_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _xq_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_xq_;continue a}
            break}
          break}}
      var _xm_=1 < l?1:0;
      if(_xm_)
       {var e=caml_check_bound(a,1)[2],_xn_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _xn_;
        caml_check_bound(a,0)[1] = e;
        var _xo_=0}
      else
       var _xo_=_xm_;
      return _xo_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xb_=len - 1 | 0,_xa_=0;
        if(! (_xb_ < 0))
         {var i=_xa_;
          a:
          for(;;)
           {var
             _xc_=srcofs + i | 0,
             e=caml_check_bound(a,_xc_)[1 + _xc_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _xd_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_xd_)[1 + _xd_],e))
                 {var
                   _xe_=j[1],
                   _xf_=caml_check_bound(dst,_xe_)[1 + _xe_],
                   _xg_=j[1] + 1 | 0;
                  caml_check_bound(dst,_xg_)[1 + _xg_] = _xf_;
                  j[1] += -1;
                  continue}}
              var _xh_=j[1] + 1 | 0;
              caml_check_bound(dst,_xh_)[1 + _xh_] = e;
              var _xi_=i + 1 | 0;
              if(_xb_ !== i){var i=_xi_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_w__=i + 1 | 0;
          return [0,x,function(_w$_){return aux(_w__,_w$_)}]}
        return 0}
      var _w8_=0;
      return function(_w9_){return aux(_w8_,_w9_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_w6_=i + 1 | 0;
          return [0,[0,i,x],function(_w7_){return aux(_w6_,_w7_)}]}
        return 0}
      var _w4_=0;
      return function(_w5_){return aux(_w4_,_w5_)}}
    function of_seq$2(i$2)
     {var _w3_=0,l=fold_left(function(acc,x){return [0,x,acc]},_w3_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$5,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(762,include$2,"Stdlib__array");
    var zero=0.,one=1.,minus_one=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _w2_=x == runtime.caml_trunc_float(x)?1:0;
      return _w2_?is_finite(x):_w2_}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$7(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x && y == y)
       {if(! (x < y))
         {var switch$0=0;
          if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
          if(switch$0)return [0,y,x]}
        return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _w0_=(ofs + len | 0) - 1 | 0;
      if(! (_w0_ < ofs))
       {var i=ofs;
        for(;;)
         {a[1 + i] = v;
          var _w1_=i + 1 | 0;
          if(_w0_ !== i){var i=_w1_;continue}
          break}}
      return 0}
    function unsafe_blit(src,sofs,dst,dofs,len)
     {var _wY_=len - 1 | 0,_wX_=0;
      if(! (_wY_ < 0))
       {var i=_wX_;
        for(;;)
         {dst[1 + (dofs + i | 0)] = src[1 + (sofs + i | 0)];
          var _wZ_=i + 1 | 0;
          if(_wY_ !== i){var i=_wZ_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _wT_=ofs < 0?1:0;
      if(_wT_)
       var _wU_=_wT_;
      else
       {var _wV_=len < 0?1:0;
        if(_wV_)
         var _wU_=_wV_;
        else
         var
          _wW_=(ofs + len | 0) < 0?1:0,
          _wU_=_wW_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _wU_?invalid_arg(msg):_wU_}
    function make$1(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_wR_=l - 1 | 0,_wQ_=0;
        if(! (_wR_ < 0))
         {var i=_wQ_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _wS_=i + 1 | 0;
            if(_wR_ !== i){var i=_wS_;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$1(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      unsafe_blit(a1,0,result,0,l1);
      unsafe_blit(a2,0,result,l1,l2);
      return result}
    function concat$2(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            unsafe_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_t_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      unsafe_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      unsafe_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return unsafe_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_wP_){return a[1 + _wP_]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[1 + i] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _wN_=a.length - 1 - 1 | 0,_wM_=0;
      if(! (_wN_ < 0))
       {var i=_wM_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _wO_=i + 1 | 0;
          if(_wN_ !== i){var i=_wO_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Float_Array_iter2_arrays_m);
      var _wK_=a.length - 1 - 1 | 0,_wJ_=0;
      if(! (_wK_ < 0))
       {var i=_wJ_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _wL_=i + 1 | 0;
          if(_wK_ !== i){var i=_wL_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wH_=l - 1 | 0,_wG_=0;
      if(! (_wH_ < 0))
       {var i=_wG_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _wI_=i + 1 | 0;
          if(_wH_ !== i){var i=_wI_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Float_Array_map2_arrays_mu);
      var r=caml_floatarray_create(la),_wE_=la - 1 | 0,_wD_=0;
      if(! (_wE_ < 0))
       {var i=_wD_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _wF_=i + 1 | 0;
          if(_wE_ !== i){var i=_wF_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _wB_=a.length - 1 - 1 | 0,_wA_=0;
      if(! (_wB_ < 0))
       {var i=_wA_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _wC_=i + 1 | 0;
          if(_wB_ !== i){var i=_wC_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wy_=l - 1 | 0,_wx_=0;
      if(! (_wy_ < 0))
       {var i=_wx_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _wz_=i + 1 | 0;
          if(_wy_ !== i){var i=_wz_;continue}
          break}}
      return r}
    function fold_left$2(f,x,a)
     {var r=[0,x],_wv_=a.length - 1 - 1 | 0,_wu_=0;
      if(! (_wv_ < 0))
       {var i=_wu_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _ww_=i + 1 | 0;
          if(_wv_ !== i){var i=_ww_;continue}
          break}}
      return r[1]}
    function fold_right$1(f,a,x)
     {var r=[0,x],_ws_=a.length - 1 - 1 | 0;
      if(! (_ws_ < 0))
       {var i=_ws_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _wt_=i - 1 | 0;
          if(0 !== i){var i=_wt_;continue}
          break}}
      return r[1]}
    function exists$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if
         ((i31 + 1 | 0)
          <
          l
          &&
          !
          (0
           <=
           caml_call2(cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
         return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _wr_=trickledown(l,i,e);return _wr_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _wq_=bubbledown(l,i);return _wq_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_wk_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_wk_ < 0))
       {var i$2=_wk_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _wp_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_wp_;continue}
          break}}
      var _wl_=l - 1 | 0;
      if(! (_wl_ < 2))
       {var i$0=_wl_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_u_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _wo_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_wo_;continue a}
            break}
          break}}
      var _wm_=1 < l?1:0;
      if(_wm_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _wn_=caml_array_set(a,0,e)}
      else
       var _wn_=_wm_;
      return _wn_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _wi_=len - 1 | 0,_wh_=0;
        if(! (_wi_ < 0))
         {var i=_wh_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if
               (dstofs
                <=
                j[1]
                &&
                0
                <
                caml_call2(cmp,caml_array_get(dst,j[1]),e))
               {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                j[1] += -1;
                continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _wj_=i + 1 | 0;
              if(_wi_ !== i){var i=_wj_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_wf_=i + 1 | 0;
          return [0,x,function(_wg_){return aux(_wf_,_wg_)}]}
        return 0}
      var _wd_=0;
      return function(_we_){return aux(_wd_,_we_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_wb_=i + 1 | 0;
          return [0,[0,i,x],function(_wc_){return aux(_wb_,_wc_)}]}
        return 0}
      var _v$_=0;
      return function(_wa_){return aux(_v$_,_wa_)}}
    function of_seq$3(i$2)
     {var
       _v__=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_v__,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[1 + i] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_v8_=l - 1 | 0,_v7_=1;
      if(! (_v8_ < 1))
       {var i=_v7_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _v9_=i + 1 | 0;
          if(_v8_ !== i){var i=_v9_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_v5_=l - 1 | 0,_v4_=0;
      if(! (_v5_ < 0))
       {var i=_v4_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _v6_=i + 1 | 0;
          if(_v5_ !== i){var i=_v6_;continue}
          break}}
      return r}
    var
     _v_=caml_floatarray_create,
     _w_=caml_array_set,
     _x_=caml_array_get,
     _y_=
      [0,
       function(_v3_){return _v3_.length - 1},
       _x_,
       _w_,
       make$1,
       _v_,
       init$3,
       append$1,
       concat$2,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$6,
       mapi$3,
       fold_left$2,
       fold_right$1,
       iter2$1,
       map2$1,
       for_all$1,
       exists$1,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _z_=caml_floatarray_create,
     _A_=caml_array_set,
     _B_=caml_array_get,
     Stdlib_float=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$7,
       min$1,
       max$1,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_v2_){return _v2_.length - 1},
        _B_,
        _A_,
        make$1,
        _z_,
        init$3,
        append$1,
        concat$2,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$6,
        mapi$3,
        fold_left$2,
        fold_right$1,
        iter2$1,
        map2$1,
        for_all$1,
        exists$1,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _y_];
    caml_register_global(763,Stdlib_float,"Stdlib__float");
    var zero$0=0,one$0=1,minus_one$0=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$8(_v1_,_v0_){return _v1_ === _v0_?1:0}
    var compare$7=caml_int_compare;
    function to_string$3(x){return caml_string_of_jsbytes("" + x)}
    var
     Stdlib_int=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$8,
       compare$7,
       to_string$3];
    caml_register_global(764,Stdlib_int,"Stdlib__int");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$4(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _vY_=[0,caml_int_of_string(s)];return _vY_}
      catch(_vZ_)
       {_vZ_ = caml_wrap_exception(_vZ_);
        if(_vZ_[1] === Failure)return 0;
        throw _vZ_}}
    var compare$8=caml_int_compare;
    function equal$9(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$4,
       compare$8,
       unsigned_compare,
       equal$9];
    caml_register_global(765,Stdlib_int32,"Stdlib__int32");
    function succ$2(n){return caml_int64_add(n,_C_)}
    function pred$2(n){return caml_int64_sub(n,_D_)}
    function abs$2(n)
     {return caml_greaterequal(n,_E_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_F_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if
       (!
        (0 < caml_int64_compare(zero$2,n))
        &&
        !
        (0 < caml_int64_compare(n,max_int$3)))
       return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$5(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _vW_=[0,caml_int64_of_string(s)];return _vW_}
      catch(_vX_)
       {_vX_ = caml_wrap_exception(_vX_);
        if(_vX_[1] === Failure)return 0;
        throw _vX_}}
    function compare$9(x,y){return caml_int64_compare(x,y)}
    function equal$10(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$5,
       compare$9,
       unsigned_compare$0,
       equal$10];
    caml_register_global(766,Stdlib_int64,"Stdlib__int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$6(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _vU_=[0,caml_int_of_string(s)];return _vU_}
      catch(_vV_)
       {_vV_ = caml_wrap_exception(_vV_);
        if(_vV_[1] === Failure)return 0;
        throw _vV_}}
    var compare$10=caml_int_compare;
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$1,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$6,
       compare$10,
       unsigned_compare$1,
       equal$11];
    caml_register_global(767,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _vR_=0 <= result?1:0,
       _vS_=_vR_?buf[12] !== dummy_pos?1:0:_vR_;
      if(_vS_)
       {buf[11] = buf[12];
        var _vT_=buf[12];
        buf[12] = [0,_vT_[1],_vT_[2],_vT_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _vO_=0 <= result?1:0,
       _vP_=_vO_?buf[12] !== dummy_pos?1:0:_vO_;
      if(_vP_)
       {buf[11] = buf[12];
        var _vQ_=buf[12];
        buf[12] = [0,_vQ_[1],_vQ_[2],_vQ_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _vA_=with_positions?zero_pos:dummy_pos,
       _vB_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _vC_=[0],
       _vD_=0,
       _vE_=0,
       _vF_=0,
       _vG_=0,
       _vH_=0,
       _vI_=0,
       _vJ_=0,
       _vK_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_g);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_vM_=t.length - 1 - 1 | 0,_vL_=0;
                  if(! (_vM_ < 0))
                   {var i=_vL_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _vN_=i + 1 | 0;
                      if(_vM_ !== i){var i=_vN_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _vK_,
              _vJ_,
              _vI_,
              _vH_,
              _vG_,
              _vF_,
              _vE_,
              _vD_,
              _vC_,
              _vB_,
              _vA_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _vp_=with_positions?zero_pos:dummy_pos,
       _vq_=with_positions?zero_pos:dummy_pos,
       _vr_=[0],
       _vs_=1,
       _vt_=0,
       _vu_=0,
       _vv_=0,
       _vw_=0,
       _vx_=0,
       _vy_=caml_ml_string_length(s),
       _vz_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _vz_,
              _vy_,
              _vx_,
              _vw_,
              _vv_,
              _vu_,
              _vt_,
              _vs_,
              _vr_,
              _vq_,
              _vp_]}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _vn_=lcp !== dummy_pos?1:0,
       _vo_=_vn_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_vn_;
      return _vo_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(768,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _vh_=env[13],
                _vi_=
                 caml_call1(caml_check_bound(tables[1],_vh_)[1 + _vh_],env),
                _vj_=4,
                arg$1=_vi_,
                cmd$0=_vj_}
             catch(_vm_)
              {_vm_ = caml_wrap_exception(_vm_);
               if(_vm_ !== Parse_error)throw _vm_;
               var arg$1=0,cmd$0=5,_vk_=_vm_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _vl_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_vl_)[1 + _vl_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _vg_=env[11] - n | 0;return caml_check_bound(env[2],_vg_)[1 + _vg_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _vd_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_vd_)[1 + _vd_],
           _ve_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_ve_)[1 + _ve_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _vf_=env[11];
        return caml_check_bound(env[4],_vf_)[1 + _vf_]}}
    function symbol_end_pos(param)
     {var _vc_=env[11];return caml_check_bound(env[4],_vc_)[1 + _vc_]}
    function rhs_start_pos(n)
     {var _vb_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_vb_)[1 + _vb_]}
    function rhs_end_pos(n)
     {var _va_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_va_)[1 + _va_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_u$_){return runtime.caml_set_parser_trace(_u$_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(769,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _u__=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_u__]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_u5_=height(lr);
               if(_u5_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_u6_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_u6_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_u7_=height(rl);
               if(_u7_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_u8_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_u8_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _u9_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_u9_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _u4_=param$0[1];
               if(_u4_){var param$0=_u4_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _u3_=param$0[1];
               if(_u3_){var param$0=_u3_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _u2_=param[1];
             if(_u2_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_u2_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _u1_=remove_min_elt(match);
               return join(t,min_elt(match),_u1_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _G_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _u0_=0 === c?1:0;
               if(_u0_)return _u0_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _uZ_=remove_min_elt(r);return bal(l,min_elt(r),_uZ_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _uX_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_uX_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _uY_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_uY_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _uT_=split(v1,match),
                _uU_=_uT_[1];
               if(_uT_[2])
                {var r2=_uT_[3],_uV_=inter(r1,r2);
                 return join(inter(l1,_uU_),v1,_uV_)}
               var r2$0=_uT_[3],_uW_=inter(r1,r2$0);
               return concat(inter(l1,_uU_),_uW_)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0 && s2$0)
              {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
               if(s1$0 === s2$0)return 0;
               var match=split_bis(v1,s2$0);
               if(match)
                {var r2=match[2],l2=match[1],_uS_=disjoint(l1,l2);
                 if(_uS_)
                  {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                 return _uS_}
               return 0}
             return 1}}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _uO_=split(v1,match),
                _uP_=_uO_[1];
               if(_uO_[2])
                {var r2=_uO_[3],_uQ_=diff(r1,r2);
                 return concat(diff(l1,_uP_),_uQ_)}
               var r2$0=_uO_[3],_uR_=diff(r1,r2$0);
               return join(diff(l1,_uP_),v1,_uR_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _uL_=subset(l1,l2);
                   if(_uL_){var s1$0=r1,s2$0=r2;continue}
                   return _uL_}
                 if(0 <= c)
                  {var _uM_=subset([0,0,v1,r1,0],r2);
                   if(_uM_){var s1$0=l1;continue}
                   return _uM_}
                 var _uN_=subset([0,l1,v1,0,0],l2);
                 if(_uN_){var s1$0=r1;continue}
                 return _uN_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uI_=caml_call1(p,v);
               if(_uI_)
                {var _uJ_=for_all(p,l);
                 if(_uJ_){var param$0=r;continue}
                 var _uK_=_uJ_}
               else
                var _uK_=_uI_;
               return _uK_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uF_=caml_call1(p,v);
               if(_uF_)
                var _uG_=_uF_;
               else
                {var _uH_=exists(p,l);
                 if(! _uH_){var param$0=r;continue}
                 var _uG_=_uH_}
               return _uG_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _uD_=concat(lf,rf);return [0,join(lt,v,rt),_uD_]}
             var _uE_=join(lf,v,rf);
             return [0,concat(lt,rt),_uE_]}
           return _H_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_uC_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _uC_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0 && v === v$0 && r === r$0)return t;
             var switch$0=0;
             if(0 !== l$0)
              {var _uB_=max_elt(l$0);
               if(0 <= caml_call2(Ord[1],_uB_,v$0))switch$0 = 1}
             if(! switch$0)
              {var switch$1=0;
               if(0 !== r$0)
                {var _uA_=min_elt(r$0);
                 if(0 <= caml_call2(Ord[1],v$0,_uA_))switch$1 = 1}
               if(! switch$1)return join(l$0,v$0,r$0)}
             return union(l$0,add(v$0,r$0))}
           return 0}
         function of_list(l)
          {if(l)
            {var _up_=l[2],_uq_=l[1];
             if(_up_)
              {var _ur_=_up_[2],_us_=_up_[1];
               if(_ur_)
                {var _ut_=_ur_[2],_uu_=_ur_[1];
                 if(_ut_)
                  {var _uv_=_ut_[2],_uw_=_ut_[1];
                   if(_uv_)
                    {if(_uv_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _ux_=l[2];
                                 if(_ux_)
                                  {var l$4=_ux_[2],x1=_ux_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _uy_=l[2];
                                 if(_uy_)
                                  {var _uz_=_uy_[2];
                                   if(_uz_)
                                    {var l$5=_uz_[2],x2=_uz_[1],x1$0=_uy_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_I_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_uv_[1];
                     return add(x4,add(_uw_,add(_uu_,add(_us_,singleton(_uq_)))))}
                   return add(_uw_,add(_uu_,add(_us_,singleton(_uq_))))}
                 return add(_uu_,add(_us_,singleton(_uq_)))}
               return add(_us_,singleton(_uq_))}
             return singleton(_uq_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_un_=cons_enum(t,rest);
             return [0,x,function(_uo_){return seq_of_enum(_un_,_uo_)}]}
           return 0}
         function to_seq(c)
          {var _ul_=cons_enum(c,0);
           return function(_um_){return seq_of_enum(_ul_,_um_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _uj_=[0,v,r,c]}
             else
              var _uj_=c;
             return function(_uk_){return seq_of_enum(_uj_,_uk_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(770,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_ui_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_ui_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_ud_=height(lr);
               if(_ud_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _ue_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_ue_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_uf_=height(rl);
               if(_uf_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _ug_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_ug_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _uh_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_uh_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _uc_=0 === c?1:0;
               if(_uc_)return _uc_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _ub_=param$0[1];
               if(_ub_){var param$0=_ub_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _ua_=param$0[1];
               if(_ua_){var param$0=_ua_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _t$_=param[1];
             if(_t$_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_t$_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _tO_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _tO_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _tO_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _t8_=caml_call2(p,v,d);
               if(_t8_)
                {var _t9_=for_all(p,l);
                 if(_t9_){var param$0=r;continue}
                 var _t__=_t9_}
               else
                var _t__=_t8_;
               return _t__}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _t5_=caml_call2(p,v,d);
               if(_t5_)
                var _t6_=_t5_;
               else
                {var _t7_=exists(p,l);
                 if(! _t7_){var param$0=r;continue}
                 var _t6_=_t7_}
               return _t6_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _J_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _t1_=merge(f,r1,r2),
                _t2_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_t2_,_t1_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _t3_=merge(f,r1$0,r2$0),
              _t4_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_t4_,_t3_)}
           throw [0,Assert_failure,_K_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _tZ_=concat(lf,rf);return [0,join(lt,v,d,rt),_tZ_]}
             var _t0_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_t0_]}
           return _L_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _tW_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_tW_)
                  {var _tX_=caml_call2(cmp,d1,d2);
                   if(_tX_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _tY_=_tX_}
                 else
                  var _tY_=_tW_;
                 return _tY_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_tV_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _tV_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_tT_=cons_enum(t,rest);
             return [0,[0,k,v],function(_tU_){return seq_of_enum(_tT_,_tU_)}]}
           return 0}
         function to_seq(m)
          {var _tR_=cons_enum(m,0);
           return function(_tS_){return seq_of_enum(_tR_,_tS_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _tP_=[0,v,d,r,c]}
             else
              var _tP_=c;
             return function(_tQ_){return seq_of_enum(_tP_,_tQ_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(771,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _tN_=s[1];
      if(_tN_)
       {var tl=_tN_[2],hd=_tN_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _tM_=s[1];
      if(_tM_)
       {var tl=_tM_[2],hd=_tM_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _tL_=s[1];if(_tL_){var hd=_tL_[1];return hd}throw Empty}
    function top_opt(s)
     {var _tK_=s[1];if(_tK_){var hd=_tK_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$1(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$1,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(772,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_tJ_=q[3];
      return _tJ_
              ?(q[1] = q[1] + 1 | 0,_tJ_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _tI_=q[2];if(_tI_){var content=_tI_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _tH_=q[2];if(_tH_){var content=_tH_[1];return [0,content]}return 0}
    function take(q)
     {var _tF_=q[2];
      if(_tF_)
       {var _tG_=_tF_[1];
        if(_tF_[2])
         {var next=_tF_[2];q[1] = q[1] - 1 | 0;q[2] = next;return _tG_}
        clear$0(q);
        return _tG_}
      throw Empty$0}
    function take_opt(q)
     {var _tD_=q[2];
      if(_tD_)
       {var _tE_=_tD_[1];
        if(_tD_[2])
         {var next=_tD_[2];q[1] = q[1] - 1 | 0;q[2] = next;return [0,_tE_]}
        clear$0(q);
        return [0,_tE_]}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$2(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _tB_=0 < q1[1]?1:0;
      if(_tB_)
       {var _tC_=q2[3];
        return _tC_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _tC_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _tB_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_tA_){return aux(next,_tA_)}]}
        return 0}
      var _ty_=q[2];
      return function(_tz_){return aux(_ty_,_tz_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$2,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(773,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      caml_obj_make_forward(blk,result);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(774,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250 && t !== 246 && t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(775,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_M_]}
           case 2:
            var
             f=d$0[1],
             _tu_=caml_obj_tag(f),
             d$1=250 === _tu_?f[1]:246 === _tu_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _tv_=d$0[1],_tw_=_tv_[1];
            if(_tw_)
             {var _tx_=_tw_[1];
              if(_tx_){var a$0=_tx_[1];_tv_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_tv_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _tv_[1] = _N_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _tp_=s[2];
        if(typeof _tp_ === "number")
         return 0;
        else
         switch(_tp_[0])
          {case 0:var a=_tp_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_O_]}
           case 2:
            var
             f=_tp_[1],
             _tq_=caml_obj_tag(f),
             _tr_=250 === _tq_?f[1]:246 === _tq_?force_lazy_block(f):f;
            s[2] = _tr_;
            continue;
           case 3:
            var _ts_=_tp_[1],_tt_=_ts_[1];
            if(_tt_){var a$1=_tt_[1];return a$1}
            var x=caml_call1(_ts_[2],s[1]);
            _ts_[1] = [0,x];
            return x;
           default:
            var b=_tp_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _tn_=s[2];
        if(typeof _tn_ !== "number")
         switch(_tn_[0])
          {case 0:var d=_tn_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _to_=_tn_[1];
            if(_to_[1]){s[1] = s[1] + 1 | 0;_to_[1] = 0;return 0}
            break;
           case 4:
            var b=_tn_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _tm_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_tm_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _tl_=data(s);return [0,[0,0,[1,data(i),_tl_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tj_)
                  {var _tk_=data(s);return [1,data(caml_call1(f,0)),_tk_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_th_)
                  {var _ti_=data(s);return [0,caml_call1(f,0),_ti_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_tg_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_tf_){return data(caml_call1(f,0))}]]]]}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string$0,
       of_bytes,
       of_channel,
       iter$9,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(776,Stdlib_stream,"Stdlib__stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        !
        ((src[2] - len | 0) < srcoff)
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
       return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs && ! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buf);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_P_]}
        throw [0,Assert_failure,_Q_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_R_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_S_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_T_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_U_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_V_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_W_]}
    function add_substring(b,s,offset,len)
     {var _tc_=offset < 0?1:0;
      if(_tc_)
       var _td_=_tc_;
      else
       var
        _te_=len < 0?1:0,
        _td_=_te_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_td_)invalid_arg(cst_Buffer_add_substring_add_s);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len)
     {var _ta_=len < 0?1:0,_tb_=_ta_ || (max_string_length < len?1:0);
      if(_tb_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len | 0))resize(b,len);
      var already_read=0,ofs=b[2],to_read=len,_s$_=b[1];
      for(;;)
       {if(0 !== to_read)
         {var r=input(ic,_s$_,ofs,to_read);
          if(0 !== r)
           {var
             already_read$0=already_read + r | 0,
             ofs$0=ofs + r | 0,
             to_read$0=to_read - r | 0,
             already_read=already_read$0,
             ofs=ofs$0,
             to_read=to_read$0;
            continue}}
        if((b[2] + already_read | 0) <= b[3])
         {b[2] = b[2] + already_read | 0;
          if(already_read < len)throw End_of_file;
          return 0}
        throw [0,Assert_failure,_X_]}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start),switch$0=0;
            if(40 !== opening && 123 !== opening)
             {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
              for(;;)
               {if(lim$0 <= i$3)
                 var stop=lim$0;
                else
                 {var match=caml_string_get(s,i$3),switch$1=0;
                  if(91 <= match)
                   {if(97 <= match)
                     {if(! (123 <= match))switch$1 = 1}
                    else
                     if(95 === match)switch$1 = 1}
                  else
                   if(58 <= match)
                    {if(65 <= match)switch$1 = 1}
                   else
                    if(48 <= match)switch$1 = 1;
                  if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                  var stop=i$3}
                var match$0=[0,sub$0(s,start,stop - start | 0),stop];
                switch$0 = 1;
                break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _s9_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_Y_];var _s9_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _s9_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _s__=92 === previous?1:0;
        return _s__?add_char(b,previous):_s__}}
    function truncate(b,len)
     {if(0 <= len && ! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_s7_=i + 1 | 0;
        return [0,x,function(_s8_){return aux(_s7_,_s8_)}]}
      var _s5_=0;
      return function(_s6_){return aux(_s5_,_s6_)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_s3_=i + 1 | 0;
        return [0,[0,i,x],function(_s4_){return aux(_s3_,_s4_)}]}
      var _s1_=0;
      return function(_s2_){return aux(_s1_,_s2_)}}
    function add_seq$1(b,seq)
     {return iter(function(_s0_){return add_char(b,_s0_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_buffer=
      [0,
       create$2,
       contents,
       to_bytes,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(777,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string$1(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _sZ_=i + 1 | 0;
        if(31 !== i){var i=_sZ_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_sY_=[0,ndec];else var _sY_=0;
          return [0,[8,_Z_,pad_of_pad_opt(pad_opt$5),_sY_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _sW_=len < min_len?1:0;
      if(_sW_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _sX_=0}
      else
       var _sX_=_sW_;
      return _sX_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        case 7:return 72;
        default:return 70}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_string_of_jsbytes("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")return prec?buffer_add_string(buf,cst$11):0;
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:break;
        case 1:buffer_add_char(buf,43);break;
        default:buffer_add_char(buf,32)}
      return 8 <= fconv[2]?buffer_add_char(buf,35):0}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(cst$19,make$0(1,c))}}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _sU_=caml_ml_string_length(str) - 1 | 0,_sT_=0;
      if(! (_sU_ < 0))
       {var i=_sT_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _sV_=i + 1 | 0;
          if(_sU_ !== i){var i=_sV_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(0,fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$26);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           if(0 === fmting_gen[0])
            {var match$1=fmting_gen[1],str$0=match$1[2];
             buffer_add_string(buf,cst$27);
             buffer_add_string(buf,str$0)}
           else
            {var match$2=fmting_gen[1],str$1=match$2[2];
             buffer_add_string(buf,cst$28);
             buffer_add_string(buf,str$1)}
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _sJ_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_sO_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _sP_=is_in_char_set(_sO_,c);
                 if(_sP_)
                  var
                   _sQ_=is_in_char_set(_sO_,before),
                   _sR_=_sQ_?is_in_char_set(_sO_,after):_sQ_,
                   _sS_=1 - _sR_;
                 else
                  var _sS_=_sP_;
                 return _sS_}
               return is_alone},
            is_alone=is_alone$0(_sJ_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_sJ_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0,switch$0=0;
               if(48 < switcher >>> 0)
                if(210 <= switcher)print_char(buf,255);else switch$0 = 1;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 switch$0 = 1}
               if(switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_sJ_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var
                  match$0=char_of_int(i$1),
                  switcher$1=match$0 - 45 | 0,
                  switch$1=0;
                 if(48 < switcher$1 >>> 0)
                  if(210 <= switcher$1)
                   {print_char(buf,254);print_char(buf,255)}
                  else
                   switch$1 = 1;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_sJ_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     switch$1 = 1}
                   else
                    switch$1 = 1}
                 if(switch$1)
                  {if(! is_in_char_set(_sJ_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0 && is_in_char_set(_sJ_,char_of_int(j$0)))
                      {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _sK_=108;break;
             case 1:var _sK_=110;break;
             default:var _sK_=78}
           buffer_add_char(buf,_sK_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$3=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$3[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _sM_=int_of_custom_arity(arity),
            _sL_=1;
           if(! (_sM_ < 1))
            {var i$8=_sL_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _sN_=i$8 + 1 | 0;
               if(_sM_ !== i$8){var i$8=_sN_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _sl_=function(param){return 0},
         _sm_=function(param){return 0},
         _sn_=function(param){return 0};
        return [0,function(param){return 0},_sn_,_sm_,_sl_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _so_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_so_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _sp_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _sp_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _sq_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _sq_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _sr_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _sr_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _ss_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _ss_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _st_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _st_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _su_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _su_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _sv_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _sv_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _sw_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _sw_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _sx_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _sy_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _sz_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _sz_,
                  _sy_,
                  _sx_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _sA_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _sA_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _sB_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _sB_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _sC_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _sC_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _sD_=function(param){caml_call1(de$12,0);return 0},
           _sE_=function(param){caml_call1(ed$12,0);return 0},
           _sF_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _sF_,
                  _sE_,
                  _sD_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _sG_=function(param){caml_call1(de$13,0);return 0},
           _sH_=function(param){caml_call1(ed$13,0);return 0},
           _sI_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _sI_,
                  _sH_,
                  _sG_]}}
    function trans(ty1,match)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,___]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_r4_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_r4_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_r5_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_r5_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_r6_=ty1[1];
          if(typeof match === "number")
           switch$3 = 1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_r6_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_r7_=ty1[1];
          if(typeof match === "number")
           switch$4 = 1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_r7_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_r8_=ty1[1];
          if(typeof match === "number")
           switch$5 = 1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_r8_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_r9_=ty1[1];
          if(typeof match === "number")
           switch$6 = 1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_r9_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_r__=ty1[1];
          if(typeof match === "number")
           switch$7 = 1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_r__,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_r$_=ty1[1];
          if(typeof match === "number")
           switch$8 = 1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_r$_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_sa_=ty1[2],_sb_=ty1[1];
          if(typeof match === "number")
           switch$9 = 1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_sc_=trans(_sa_,rest2$7);
              return [8,trans(_sb_,ty2),_sc_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_ah_];
          break;
         case 9:
          var switch$10=0,_sd_=ty1[3],_se_=ty1[2],_sf_=ty1[1];
          if(typeof match === "number")
           switch$10 = 1;
          else
           switch(match[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_se_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_sf_,ty22,trans(_sd_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_ai_];
          break;
         case 10:
          var _sg_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_sg_,rest2$9)]}
          throw [0,Assert_failure,_aj_];
         case 11:
          var switch$11=0,_sh_=ty1[1];
          if(typeof match === "number")
           switch$11 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:var rest2$10=match[1];return [11,trans(_sh_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_ak_];
          break;
         case 12:
          var switch$12=0,_si_=ty1[1];
          if(typeof match === "number")
           switch$12 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=match[1];return [12,trans(_si_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_al_];
          break;
         case 13:
          var switch$13=0,_sj_=ty1[1];
          if(typeof match === "number")
           switch$13 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=match[1];return [13,trans(_sj_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_am_];
          break;
         default:
          var switch$14=0,_sk_=ty1[1];
          if(typeof match === "number")
           switch$14 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=match[1];return [14,trans(_sk_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_an_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ab_];
        case 1:throw [0,Assert_failure,_ac_];
        case 2:throw [0,Assert_failure,_ad_];
        case 3:throw [0,Assert_failure,_ae_];
        case 4:throw [0,Assert_failure,_af_];
        case 5:throw [0,Assert_failure,_$_];
        case 6:throw [0,Assert_failure,_aa_];
        default:throw [0,Assert_failure,_ag_]}}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _r2_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_r3_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _r3_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_r3_,_r2_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?prec?[2,fmtty]:fmtty:fmtty}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mi,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _r1_=match[2];
          if(typeof _r1_ !== "number" && 2 === _r1_[0])
           {var rest=_r1_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_format(fmt,fmtty)
     {var _r0_=type_format_gen(fmt,fmtty);
      if(typeof _r0_[2] === "number"){var fmt$0=_r0_[1];return fmt$0}
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _rJ_=match$1[2],
           _rI_=match$1[1];
          if(typeof _rJ_ !== "number" && 1 === _rJ_[0])
           {var
             fmtty_rest$1=_rJ_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_rI_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _rL_=match$3[2],
           _rK_=match$3[1];
          if(typeof _rL_ !== "number" && 1 === _rL_[0])
           {var
             fmtty_rest$2=_rL_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_rK_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _rN_=match$5[3],
           _rM_=match$5[1];
          if(typeof _rN_ !== "number" && 2 === _rN_[0])
           {var
             fmtty_rest$3=_rN_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_rM_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _rP_=match$7[3],
           _rO_=match$7[1];
          if(typeof _rP_ !== "number" && 3 === _rP_[0])
           {var
             fmtty_rest$4=_rP_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_rO_,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _rR_=match$9[3],
           _rQ_=match$9[1];
          if(typeof _rR_ !== "number" && 4 === _rR_[0])
           {var
             fmtty_rest$5=_rR_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_rQ_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _rT_=match$11[3],
           _rS_=match$11[1];
          if(typeof _rT_ !== "number" && 5 === _rT_[0])
           {var
             fmtty_rest$6=_rT_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_rS_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _rV_=match$13[3],
           _rU_=match$13[1];
          if(typeof _rV_ !== "number" && 6 === _rV_[0])
           {var
             fmtty_rest$7=_rV_[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_rU_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _rX_=match$15[2],
           _rW_=match$15[1];
          if(typeof _rX_ !== "number" && 7 === _rX_[0])
           {var
             fmtty_rest$8=_rX_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_rW_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _rY_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_rY_))
             throw Type_mismatch;
            var
             match$21=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$28=formatting_gen[1],
             str$0=match$28[2],
             fmt1=match$28[1],
             match$29=type_format_gen(fmt1,fmtty),
             fmtty2=match$29[2],
             fmt2=match$29[1],
             match$30=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$30[2],
             fmt3=match$30[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$31=formatting_gen[1],
           str$1=match$31[2],
           fmt1$0=match$31[1],
           match$32=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$32[2],
           fmt2$0=match$32[1],
           match$33=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$33[2],
           fmt3$0=match$33[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$34=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$34[2],
                 fmt$21=match$34[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _rZ_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$35=_rZ_[2],
               fmtty$22=match$35[2],
               fmt$22=match$35[1],
               sub_fmtty$4=_rZ_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substituti(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _rG_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_rG_))
             throw Type_mismatch;
            var _rH_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_rH_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _rF_=2 === padty$0?48:32,res=make(width$0,_rF_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function format_of_fconv(fconv,prec)
     {var
       prec$0=abs(prec),
       symb=char_of_fconv(_ao_,fconv),
       buf=buffer_create(16);
      buffer_add_char(buf,37);
      bprint_fconv_flag(buf,fconv);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec$0));
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_rA_=caml_ml_string_length(s) - 1 | 0,_rz_=0;
        if(! (_rA_ < 0))
         {var i$0=_rz_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _rE_=i$0 + 1 | 0;
            if(_rA_ !== i$0){var i$0=_rE_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _rC_=caml_ml_string_length(s) - 1 | 0,
         _rB_=0;
        if(! (_rC_ < 0))
         {var i=_rB_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _rD_=i + 1 | 0;
            if(_rC_ !== i){var i=_rD_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _ry_=cst_d$3;break;
        case 2:var _ry_=cst_d$4;break;
        case 4:var _ry_=cst_i$1;break;
        case 5:var _ry_=cst_i$2;break;
        case 6:var _ry_=cst_x;break;
        case 7:var _ry_=cst_x$0;break;
        case 8:var _ry_=cst_X$0;break;
        case 9:var _ry_=cst_X$1;break;
        case 10:var _ry_=cst_o;break;
        case 11:var _ry_=cst_o$0;break;
        case 0:
        case 13:var _ry_=cst_d$2;break;
        case 3:
        case 14:var _ry_=cst_i$0;break;
        default:var _ry_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_ry_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _rx_=cst_ld$0;break;
        case 2:var _rx_=cst_ld$1;break;
        case 4:var _rx_=cst_li$1;break;
        case 5:var _rx_=cst_li$2;break;
        case 6:var _rx_=cst_lx;break;
        case 7:var _rx_=cst_lx$0;break;
        case 8:var _rx_=cst_lX;break;
        case 9:var _rx_=cst_lX$0;break;
        case 10:var _rx_=cst_lo;break;
        case 11:var _rx_=cst_lo$0;break;
        case 0:
        case 13:var _rx_=cst_ld;break;
        case 3:
        case 14:var _rx_=cst_li$0;break;
        default:var _rx_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_rx_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _rw_=cst_nd$0;break;
        case 2:var _rw_=cst_nd$1;break;
        case 4:var _rw_=cst_ni$1;break;
        case 5:var _rw_=cst_ni$2;break;
        case 6:var _rw_=cst_nx;break;
        case 7:var _rw_=cst_nx$0;break;
        case 8:var _rw_=cst_nX;break;
        case 9:var _rw_=cst_nX$0;break;
        case 10:var _rw_=cst_no;break;
        case 11:var _rw_=cst_no$0;break;
        case 0:
        case 13:var _rw_=cst_nd;break;
        case 3:
        case 14:var _rw_=cst_ni$0;break;
        default:var _rw_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_rw_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _rv_=cst_Ld$0;break;
        case 2:var _rv_=cst_Ld$1;break;
        case 4:var _rv_=cst_Li$1;break;
        case 5:var _rv_=cst_Li$2;break;
        case 6:var _rv_=cst_Lx;break;
        case 7:var _rv_=cst_Lx$0;break;
        case 8:var _rv_=cst_LX;break;
        case 9:var _rv_=cst_LX$0;break;
        case 10:var _rv_=cst_Lo;break;
        case 11:var _rv_=cst_Lo$0;break;
        case 0:
        case 13:var _rv_=cst_Ld;break;
        case 3:
        case 14:var _rv_=cst_Li$0;break;
        default:var _rv_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_rv_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return runtime.caml_hexstring_of_float(x,prec,sign)}
      function caml_special_val(str)
       {var match=runtime.caml_classify_float(x);
        return 3 === match
                ?x < 0.?cst_neg_infinity:cst_infinity
                :4 <= match?cst_nan:str}
      switch(fconv[2])
       {case 5:
         var
          str=caml_format_float(format_of_fconv(fconv,prec),x),
          len=caml_ml_string_length(str),
          i=0;
         for(;;)
          {if(i === len)
            var _rt_=0;
           else
            {var match=caml_string_get(str,i),_rs_=match - 46 | 0,switch$0=0;
             if(23 < _rs_ >>> 0)
              {if(55 === _rs_)switch$0 = 1}
             else
              if(21 < (_rs_ - 1 | 0) >>> 0)switch$0 = 1;
             if(! switch$0){var i$0=i + 1 | 0,i=i$0;continue}
             var _rt_=1}
           var _ru_=_rt_?str:symbol(str,cst$29);
           return caml_special_val(_ru_)}
        case 6:return hex(0);
        case 7:return uppercase_ascii$1(hex(0));
        case 8:return caml_special_val(hex(0));
        default:return caml_format_float(format_of_fconv(fconv,prec),x)}}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_int_padding_precision(k,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return match
                 ?function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _rp_=pad[2],_rq_=pad[1];
          if(typeof match === "number")
           return match
                   ?function(p,x)
                     {var
                       str=
                        fix_padding
                         (_rq_,_rp_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var str=fix_padding(_rq_,_rp_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_rq_,_rp_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _rr_=pad[1];
        if(typeof match === "number")
         return match
                 ?function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_rr_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var str=fix_padding(_rr_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_rr_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return prec$3
                      ?function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _rm_=pad$5[2],_rn_=pad$5[1];
               if(typeof prec$3 === "number")
                return prec$3
                        ?function(p,x)
                          {var str=fix_padding(_rn_,_rm_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)}
                        :function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_rn_,_rm_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_rn_,_rm_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _ro_=pad$5[1];
             if(typeof prec$3 === "number")
              return prec$3
                      ?function(w,p,x)
                        {var str=fix_padding(_ro_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_ro_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_ro_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _rk_=fmt$0[1];
           if(0 === _rk_[0])
            {var
              rest$13=fmt$0[2],
              match=_rk_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_rk_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ap_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _rl_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_rl_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_rl_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_aq_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_rj_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_ar_];
         default:throw [0,Assert_failure,_as_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _ri_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_ri_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_ri_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _rh_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_rh_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_rh_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)
           {var _qP_=make_iprintf(k,o,fmt),_qQ_=function(_q7_){return _qP_};
            return function(_q6_){return _qQ_}}
          var _qR_=make_iprintf(k,o,fmt);
          return function(_q5_){return _qR_}}
        var _qS_=make_iprintf(k,o,fmt);
        return function(_q4_){return _qS_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(prec)
             {var _qT_=make_iprintf(k,o,fmt),_qU_=function(_rg_){return _qT_};
              return function(_rf_){return _qU_}}
            var _qV_=make_iprintf(k,o,fmt);
            return function(_re_){return _qV_}}
          var _qW_=make_iprintf(k,o,fmt);
          return function(_rd_){return _qW_}}
        if(typeof prec === "number")
         {if(prec)
           {var
             _qX_=make_iprintf(k,o,fmt),
             _qY_=function(_rc_){return _qX_},
             _qZ_=function(_rb_){return _qY_};
            return function(_ra_){return _qZ_}}
          var _q0_=make_iprintf(k,o,fmt),_q1_=function(_q$_){return _q0_};
          return function(_q__){return _q1_}}
        var _q2_=make_iprintf(k,o,fmt),_q3_=function(_q9_){return _q2_};
        return function(_q8_){return _q3_}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_p6_=make_iprintf(k$0,o,rest);
           return function(_qO_){return _p6_};
          case 1:
           var rest$0=fmt$0[1],_p7_=make_iprintf(k$0,o,rest$0);
           return function(_qN_){return _p7_};
          case 2:
           var _p8_=fmt$0[1];
           if(typeof _p8_ === "number")
            {var rest$1=fmt$0[2],_p9_=make_iprintf(k$0,o,rest$1);
             return function(_qJ_){return _p9_}}
           else
            {if(0 === _p8_[0])
              {var rest$2=fmt$0[2],_p__=make_iprintf(k$0,o,rest$2);
               return function(_qM_){return _p__}}
             var
              rest$3=fmt$0[2],
              _p$_=make_iprintf(k$0,o,rest$3),
              _qa_=function(_qL_){return _p$_};
             return function(_qK_){return _qa_}}
          case 3:
           var _qb_=fmt$0[1];
           if(typeof _qb_ === "number")
            {var rest$4=fmt$0[2],_qc_=make_iprintf(k$0,o,rest$4);
             return function(_qF_){return _qc_}}
           else
            {if(0 === _qb_[0])
              {var rest$5=fmt$0[2],_qd_=make_iprintf(k$0,o,rest$5);
               return function(_qI_){return _qd_}}
             var
              rest$6=fmt$0[2],
              _qe_=make_iprintf(k$0,o,rest$6),
              _qf_=function(_qH_){return _qe_};
             return function(_qG_){return _qf_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _qg_=fmt$0[1];
           if(typeof _qg_ === "number")
            {var rest$12=fmt$0[2],_qh_=make_iprintf(k$0,o,rest$12);
             return function(_qB_){return _qh_}}
           else
            {if(0 === _qg_[0])
              {var rest$13=fmt$0[2],_qi_=make_iprintf(k$0,o,rest$13);
               return function(_qE_){return _qi_}}
             var
              rest$14=fmt$0[2],
              _qj_=make_iprintf(k$0,o,rest$14),
              _qk_=function(_qD_){return _qj_};
             return function(_qC_){return _qk_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_ql_=make_iprintf(k$0,o,rest$15);
           return function(_qA_){return _ql_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _qm_=make_iprintf(k$0,o,rest$17),
            _qn_=function(_qz_){return _qm_};
           return function(_qy_){return _qn_};
          case 16:
           var rest$18=fmt$0[1],_qo_=make_iprintf(k$0,o,rest$18);
           return function(_qx_){return _qo_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _qp_=fmt$0[1];
           if(0 === _qp_[0])
            {var
              rest$19=fmt$0[2],
              match=_qp_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_qp_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_at_];
          case 20:
           var rest$21=fmt$0[3],_qq_=make_iprintf(k$0,o,rest$21);
           return function(_qw_){return _qq_};
          case 21:
           var rest$22=fmt$0[2],_qr_=make_iprintf(k$0,o,rest$22);
           return function(_qv_){return _qr_};
          case 22:
           var rest$23=fmt$0[1],_qs_=make_iprintf(k$0,o,rest$23);
           return function(_qu_){return _qs_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_qt_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_qt_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_p4_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_p5_){return _p4_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _p2_=acc$0[2],_p3_=acc$0[1];
           if(0 === _p2_[0])
            {var acc$1=_p2_[1];
             output_acc(o,_p3_);
             output_string(o,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_p2_[1];
           output_acc(o,_p3_);
           output_string(o,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _p0_=acc$0[2],_p1_=acc$0[1];
           if(0 === _p0_[0])
            {var acc$1=_p0_[1];
             bufput_acc(b,_p1_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_p0_[1];
           bufput_acc(b,_p1_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _pY_=acc$0[2],_pZ_=acc$0[1];
           if(0 === _pY_[0])
            {var acc$1=_pY_[1];
             strput_acc(b,_pZ_);
             add_string(b,cst$34);
             var acc$0=acc$1;
             continue}
           var acc$2=_pY_[1];
           strput_acc(b,_pZ_);
           add_string(b,cst$35);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$36))return _au_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_av_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _pW_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_pW_}
       catch(_pX_)
        {_pX_ = caml_wrap_exception(_pX_);
         if(_pX_[1] !== Failure)throw _pX_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,cst$37)
        &&
        caml_string_notequal(box_name,cst_b$0))
       var
        box_type=
         caml_string_notequal(box_name,cst_h)
          ?caml_string_notequal(box_name,cst_hov)
            ?caml_string_notequal(box_name,cst_hv)
              ?caml_string_notequal(box_name,cst_v)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=prec?[0,1,fmt]:[0,0,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_aw_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_ax_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_ay_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _pV_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_pV_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aK_;
            else
             {var c=caml_string_get(str,str_ind$0),switch$0=0;
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  switch$0 = 1;
                 else
                  switch(switcher)
                   {case 0:
                     var match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]]}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]]}}
                else
                 switch$0 = 1;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]];
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aL_,fmt_rest$5]];
                     break;
                    case 5:
                     var switch$1=0;
                     if
                      ((str_ind$0 + 1 | 0)
                       <
                       end_ind
                       &&
                       37
                       ===
                       caml_string_get(str,str_ind$0 + 1 | 0))
                      {var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]];
                       switch$1 = 1}
                     if(! switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]];
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aM_,fmt_rest$8]];
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]];
                     break;
                    case 27:
                     var match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 28:
                     var match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]];
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]];
                     break;
                    default:switch$0 = 1}}
                else
                 switch$0 = 1;
              if(switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number" && ! match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aE_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aF_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$38);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$39)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _ps_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _ps_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_ps_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _pu_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_pu_;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_pA_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _pA_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_pA_;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _pB_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _pB_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_pB_;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _pU_=i + 1 | 0;
                    if(c !== i){var i=_pU_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aO_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _pT_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_pT_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_pT_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0),switch$0=0;
                  if(46 <= c$1)
                   {if(64 === c$1)
                     switch$0 = 1;
                    else
                     if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
                  else
                   if(37 === c$1)
                    switch$0 = 1;
                   else
                    if(45 <= c$1)
                     {var str_ind$2=str_ind$0 + 1 | 0;
                      if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                      var c$2=caml_string_get(str,str_ind$2);
                      if(37 === c$2)
                       {if((str_ind$2 + 1 | 0) === end_ind)
                         unexpected_end_of_format(end_ind);
                        var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                        if(37 !== c$3 && 64 !== c$3)
                         return fail_single_percent(str_ind$2);
                        add_range(c$0,c$3);
                        var _pR_=str_ind$2 + 2 | 0;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return parse_char_set_content(counter$2,_pR_,end_ind)}
                        return caml_trampoline_return
                                (parse_char_set_content,[0,_pR_,end_ind])}
                      if(93 === c$2)
                       {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                      add_range(c$0,c$2);
                      var _pS_=str_ind$2 + 1 | 0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return parse_char_set_content(counter$1,_pS_,end_ind)}
                      return caml_trampoline_return
                              (parse_char_set_content,[0,_pS_,end_ind])}
                  if(switch$0 && 37 === c$0)
                   {add_char(c$1);
                    var _pQ_=str_ind$0 + 1 | 0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return parse_char_set_content(counter$0,_pQ_,end_ind)}
                    return caml_trampoline_return
                            (parse_char_set_content,[0,_pQ_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,reverse=1,str_ind$1=str_ind$0;
            else
             var reverse=0,str_ind$1=str_ind;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _pG_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _pG_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_pG_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _pH_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _pI_=_pH_;
              else
               var
                _pI_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,cst_non_zero_widths_are_unsupp);
              var _pJ_=_pI_}
            else
             var _pJ_=char_format(fmt_rest$21);
            var fmt_result=_pJ_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _pK_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_pK_;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _pL_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _pL_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_pL_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _pM_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _pM_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_pM_;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _pt_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _pt_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_pt_;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var
               symb$0=caml_string_get(str,str_ind),
               _pN_=symb$0 - 88 | 0,
               switch$2=0;
              if(! (32 < _pN_ >>> 0))
               switch(_pN_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _pz_=1;switch$2 = 1;break
                 }
              if(! switch$2)var _pz_=0;
              if(_pz_){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$15=parse(str_ind,end_ind),
               fmt_rest$13=match$15[1],
               switch$3=0;
              if(108 <= symb)
               {if(! (111 <= symb))
                 {var switcher$0=symb - 108 | 0;
                  switch(switcher$0)
                   {case 0:var counter=0;switch$3 = 1;break;
                    case 1:break;
                    default:var counter=1;switch$3 = 1}}}
              else
               if(76 === symb){var counter=2;switch$3 = 1}
              if(! switch$3)throw [0,Assert_failure,_aS_];
              if(get_ign(0))
               var ignored$5=[11,counter],_py_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _py_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_py_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_aJ_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _pC_=get_space(0),
             _pD_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_pD_,_pC_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _pE_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _pF_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_pF_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _pE_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_pE_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             hash$1=get_hash(0),
             plus$2=get_plus(0),
             flag=
              plus$2
               ?space$1
                 ?legacy_behavior$0
                   ?1
                   :incompatible_flag(pct_ind,str_ind,32,cst$50)
                 :1
               :space$1?2:0,
             switch$4=0;
            if(73 <= symb)
             {var switcher$1=symb - 101 | 0;
              if(3 < switcher$1 >>> 0)
               switch$4 = 1;
              else
               {switch(switcher$1)
                 {case 0:var _pO_=1;break;
                  case 1:var _pO_=0;break;
                  case 2:var _pO_=3;break;
                  default:var _pO_=6}
                var kind=_pO_}}
            else
             if(69 <= symb)
              {var switcher$2=symb - 69 | 0,switch$5=0;
               switch(switcher$2)
                {case 0:var _pP_=2;break;
                 case 1:switch$4 = 1;switch$5 = 1;break;
                 case 2:var _pP_=4;break;
                 default:var _pP_=7}
               if(! switch$5)var kind=_pP_}
             else
              switch$4 = 1;
            if(switch$4)
             {var switch$6=0;
              if(hash$1)
               if(70 === symb)var kind=8;else switch$6 = 1;
              else
               if(70 === symb)var kind=5;else switch$6 = 1;
              if(switch$6)throw [0,Assert_failure,_aU_]}
            var
             fconv=[0,flag,kind],
             match$13=parse(str_ind,end_ind),
             fmt_rest$11=match$13[1];
            if(get_ign(0))
             {var match=get_prec(0);
              if(typeof match === "number")
               var _pv_=match?incompatible_flag(pct_ind,str_ind,95,cst$40):0;
              else
               var ndec=match[1],_pv_=[0,ndec];
              var
               ignored$4=[6,get_pad_opt(95),_pv_],
               _pw_=[0,[23,ignored$4,fmt_rest$11]]}
            else
             var
              _px_=get_prec(0),
              match$14=make_padprec_fmt_ebb(get_pad(0),_px_,fmt_rest$11),
              fmt_rest$12=match$14[3],
              prec$3=match$14[2],
              pad$5=match$14[1],
              _pw_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_pw_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$7=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$7 = 1;
           else
            {var switcher=symb - 108 | 0,switch$8=0;
             switch(switcher)
              {case 0:
                var
                 _pc_=caml_string_get(str,str_ind),
                 _pd_=get_space(0),
                 _pe_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_pe_,_pd_,_pc_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _pf_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _ph_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_ph_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _pf_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _pg_=_pf_;
                break;
               case 1:switch$7 = 1;switch$8 = 1;break;
               default:
                var
                 _pi_=caml_string_get(str,str_ind),
                 _pj_=get_space(0),
                 _pk_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_pk_,_pj_,_pi_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _pl_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _pm_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_pm_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _pl_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _pg_=_pl_}
             if(! switch$8)var fmt_result=_pg_}
          else
           if(76 === symb)
            {var
              _pn_=caml_string_get(str,str_ind),
              _po_=get_space(0),
              _pp_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_pp_,_po_,_pn_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _pq_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _pr_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_pr_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _pq_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_pq_}
           else
            switch$7 = 1;
          if(switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aG_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _o5_=1 - plus_used[1],plus$0=_o5_?plus:_o5_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _o6_=1 - hash_used[1],hash$0=_o6_?hash:_o6_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _o7_=1 - space_used[1],space$0=_o7_?space:_o7_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$43);
          var _o8_=1 - pad_used[1],_o9_=_o8_?caml_notequal([0,pad],_aH_):_o8_;
          if(_o9_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _o__=1 - prec_used[1],
           _o$_=_o__?caml_notequal([0,prec],_aI_):_o__;
          if(_o$_)
           {var _pa_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_pa_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$44)}
        var _pb_=1 - ign_used[1],ign$0=_pb_?ign:_pb_;
        if(ign$0)
         {var switch$9=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$9 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$9 = 1;
          var switch$10=0;
          if(switch$9 || ! legacy_behavior$0)switch$10 = 1;
          if(switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$45)}
        return fmt_result}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number" && ! match)return parse_conv(0);
          if(minus)
           {if(typeof match === "number")return parse_conv(_aC_);
            var n=match[1];
            return parse_conv([0,0,n])}
          if(typeof match === "number")return parse_conv(_aD_);
          var n$0=match[1];
          return parse_conv([0,1,n$0])}
        return parse_conv(pad)}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _o4_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_o4_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aB_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _o1_=flag[1],_o2_=_o1_?1 - legacy_behavior$0:_o1_;
          if(_o2_)
           {var _o3_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_az_),str,str_ind,_o3_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _oW_=space[1],
           _oX_=hash[1],
           _oY_=plus[1],
           _oZ_=minus[1],
           _o0_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            _o0_
             ?_oZ_
               ?legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0)
               :2
             :_oZ_?0:1,
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _oZ_,
                       _oY_,
                       _oX_,
                       _oW_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _oZ_,
                     _oY_,
                     _oX_,
                     _oW_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oZ_,_oY_,_oX_,_oW_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oZ_,_oY_,_oX_,_oW_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_oZ_,_oY_,_oX_,_oW_,ign,_aA_)}}}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str],
             formatting$0=is_open_tag?[0,sub_format$0]:[1,sub_format$0],
             _oU_=[0,[18,formatting$0,fmt_rest$0]];
            return _oU_}
          throw Not_found}
        catch(_oV_)
         {_oV_ = caml_wrap_exception(_oV_);
          if(_oV_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _oV_}}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _oN_=str_ind === end_ind?1:0,
           _oO_=_oN_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_oO_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _oP_=[0,s,width,0],
             _oQ_=str_ind_3 + 1 | 0,
             formatting_lit$0=_oP_,
             next_ind=_oQ_;
           else
            switch$1 = 1;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _oR_=[0,s$0,width,offset],
               _oS_=str_ind_5 + 1 | 0,
               formatting_lit$0=_oR_,
               next_ind=_oS_}
            else
             switch$1 = 1}
          if(switch$1)throw Not_found}
        catch(_oT_)
         {_oT_ = caml_wrap_exception(_oT_);
          if(_oT_ !== Not_found && _oT_[1] !== Failure)throw _oT_;
          var formatting_lit$0=formatting_lit,next_ind=str_ind}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _oL_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _oL_=0;
          var _oK_=_oL_}
        catch(_oM_)
         {_oM_ = caml_wrap_exception(_oM_);
          if(_oM_ !== Not_found && _oM_[1] !== Failure)throw _oM_;
          var _oK_=0}
        if(_oK_)
         {var
           match=_oK_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aN_,fmt_rest$0]]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aP_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aQ_]}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aR_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aV_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(plus$0)
           {if(hash$0)
             switch$0 = 1;
            else
             if(! space$0){if(100 === symb)return 1;if(105 === symb)return 4}}
          else
           if(hash$0)
            if(space$0)
             switch$0 = 1;
            else
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
           else
            if(space$0)
             {if(100 === symb)return 2;if(105 === symb)return 5}
            else
             {var switcher$1=symb - 88 | 0;
              if(! (32 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
          if(switch$0)
           {var switcher=symb - 88 | 0;
            if(! (32 < switcher >>> 0))
             switch(switcher)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$49)
               }}
          if(plus$0)
           {if(space$0)
             {if(legacy_behavior$0){var space$0=0;continue}
              return incompatible_flag(pct_ind,str_ind,32,cst$46)}
            if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$47)}
          if(space$0)
           {if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$48)}
          throw [0,Assert_failure,_aT_]}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _oI_=[0,type_format(fmt,fmtty),str];return _oI_}
      catch(_oJ_)
       {_oJ_ = caml_wrap_exception(_oJ_);
        if(_oJ_ === Type_mismatch)
         {var _oH_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aW_),str,_oH_)}
        throw _oJ_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _oF_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _oF_}
      catch(_oG_)
       {_oG_ = caml_wrap_exception(_oG_);
        if(_oG_ === Type_mismatch)
         return caml_call2(failwith_message(_aX_),str,str$0);
        throw _oG_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(778,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_oE_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _oE_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_oD_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _oD_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_oC_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_oB_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_oA_){return 0},oc,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ksprintf];
    caml_register_global(779,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$1=l$0[2],l$0=l$1;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _oz_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_oz_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_oy_=symbol(prefix,h);
        return symbol
                (fold_left$0
                  (function(x,y){return symbol(x,symbol(sep,y))},_oy_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a0_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _ov_=0,_ot_=_ov_}
      catch(_ox_)
       {_ox_ = caml_wrap_exception(_ox_);
        if(_ox_ !== Not_found)throw _ox_;
        var
         _ot_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_optio],0]}
      try
       {assoc3(cst_help$1,speclist);var _ou_=0,add2=_ou_}
      catch(_ow_)
       {_ow_ = caml_wrap_exception(_ow_);
        if(_ow_ !== Not_found)throw _ow_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_optio$0],
           0]}
      return append(speclist,append(_ot_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a1_),errmsg);
      var _oq_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _or_=0 < caml_ml_string_length(doc)?1:0;
                 if(_or_)
                  {if(11 === spec[0])
                    {var l=spec[1],_os_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_aZ_),key,_os_,doc)}
                   return caml_call2(bprintf(buf,_aY_),key,doc)}
                 return _or_},
               _oq_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _op_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a2_),_op_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _on_=[0,bool_of_string(x)];return _on_}
      catch(_oo_)
       {_oo_ = caml_wrap_exception(_oo_);
        if(_oo_[1] === Invalid_argument)return 0;
        throw _oo_}}
    function int_of_string_opt$0(x)
     {try
       {var _ol_=[0,caml_int_of_string(x)];return _ol_}
      catch(_om_)
       {_om_ = caml_wrap_exception(_om_);
        if(_om_[1] === Failure)return 0;
        throw _om_}}
    function float_of_string_opt(x)
     {try
       {var _oj_=[0,caml_float_of_string(x)];return _oj_}
      catch(_ok_)
       {_ok_ = caml_wrap_exception(_ok_);
        if(_ok_[1] === Failure)return 0;
        throw _ok_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _oi_=error[1];
           if
            (caml_string_notequal(_oi_,cst_help$3)
             &&
             caml_string_notequal(_oi_,cst_help$4))
            caml_call2(bprintf(b,_a3_),progname,_oi_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a6_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a7_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a8_),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a4_) && ! caml_equal(error,_a5_))
         return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _n$_=current[1],
             s=caml_check_bound(argv[1],_n$_)[1 + _n$_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _ob_=assoc3(s,speclist[1]),
                 follow$0=follow$1,
                 action=_ob_}
              catch(_og_)
               {_og_ = caml_wrap_exception(_og_);
                if(_og_ !== Not_found)throw _og_;
                try
                 {var
                   match=split$0(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _oa_=assoc3(keyword,speclist[1])}
                catch(_oh_)
                 {_oh_ = caml_wrap_exception(_oh_);
                  if(_oh_ === Not_found)throw [0,Stop,[0,s]];
                  throw _oh_;
                  var _oc_=_oh_}
                var follow$0=follow,action=_oa_,_od_=_og_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow)
                     {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _of_=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_of_)[1 + _of_]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt$0(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,cst_a_boolean]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt$0(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt$0(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,cst_a_float]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                      case 10:
                       var specs=param[1];
                       no_arg(0);
                       return iter$2(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,
                               s,
                               arg$5,
                               symbol(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                      case 12:
                       var f$5=param[1];
                       no_arg(0);
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _oe_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_oe_)[1 + _oe_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      default:
                       var f$6=param[1];
                       if(1 - allow_expand)
                        throw [0,Invalid_argument,cst_Arg_Expand_is_is_only_allo];
                       var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _n__=parse_argv(0,caml_sys_argv(0),l,f,msg);return _n__}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a9_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_a__),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _n9_=parse_argv_dynamic(0,caml_sys_argv(0),l,f,msg);return _n9_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a$_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_ba_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,caml_sys_argv(0)],
         spec=[0,l],
         current$0=[0,current[1]],
         _n8_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _n8_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bb_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bc_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_n6_)
       {_n6_ = caml_wrap_exception(_n6_);
        if(_n6_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_n7_)
           {_n7_ = caml_wrap_exception(_n7_);
            if(_n7_ === Not_found)return len;
            throw _n7_}
          return loop(n + 1 | 0)}
        throw _n6_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$4
              (function(c)
                {if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$2
              (function(ksd)
                {var _n4_=ksd[1],_n5_=ksd[2];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _n5_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _n4_,
                             _n5_,
                             symbol(cst$59,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    spec=ksd[2],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_n4_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_n4_,spec,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_n4_,spec,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s),switch$0=0;
          if(0 < len && 13 === caml_string_get(s,len - 1 | 0))
           {var _n3_=sub$0(s,0,len - 1 | 0);switch$0 = 1}
          if(! switch$0)var _n3_=s;
          var word=_n3_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_n2_)
       {_n2_ = caml_wrap_exception(_n2_);
        if(_n2_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _n2_}}
    var _bd_=10,_be_=1;
    function read_arg(_n1_){return read_aux(_be_,_bd_,_n1_)}
    var _bf_=0,_bg_=0;
    function read_arg0(_n0_){return read_aux(_bg_,_bf_,_n0_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bh_),s,sep)},args);
      return close_out(oc)}
    var _bi_=10;
    function write_arg(_nY_,_nZ_){return write_aux(_bi_,_nY_,_nZ_)}
    var _bj_=0;
    function write_arg0(_nW_,_nX_){return write_aux(_bj_,_nW_,_nX_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(780,Stdlib_arg,"Stdlib__arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bk_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$60
              :caml_call1(sprintf(_bl_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _nU_=other_fields(x,i + 1 | 0),_nV_=field(x,i);
      return caml_call2(sprintf(_bm_),_nV_,_nU_)}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_nT_){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(printers[1])}
    function to_string_default(x)
     {if(x === Out_of_memory)return cst_Out_of_memory;
      if(x === Stack_overflow)return cst_Stack_overflow;
      if(x[1] === Match_failure)
       {var match$0=x[2],char$0=match$0[3],line=match$0[2],file=match$0[1];
        return caml_call5
                (sprintf(locfmt),
                 file,
                 line,
                 char$0,
                 char$0 + 5 | 0,
                 cst_Pattern_matching_failed)}
      if(x[1] === Assert_failure)
       {var
         match$1=x[2],
         char$1=match$1[3],
         line$0=match$1[2],
         file$0=match$1[1];
        return caml_call5
                (sprintf(locfmt),
                 file$0,
                 line$0,
                 char$1,
                 char$1 + 6 | 0,
                 cst_Assertion_failed)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$2=x[2],
         char$2=match$2[3],
         line$1=match$2[2],
         file$1=match$2[1];
        return caml_call5
                (sprintf(locfmt),
                 file$1,
                 line$1,
                 char$2,
                 char$2 + 6 | 0,
                 cst_Undefined_recursive_module)}
      if(0 === caml_obj_tag(x))
       {var constructor=x[1][1],match=x.length - 1;
        if(2 < match >>> 0)
         var
          _nP_=other_fields(x,2),
          _nQ_=field(x,1),
          _nS_=caml_call2(sprintf(_bn_),_nQ_,_nP_);
        else
         switch(match)
          {case 0:var _nS_=cst$62;break;
           case 1:var _nS_=cst$63;break;
           default:var _nR_=field(x,1),_nS_=caml_call1(sprintf(_bo_),_nR_)}
        return symbol(constructor,_nS_)}
      return x[1]}
    function to_string$7(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function print(fct,arg)
     {try
       {var _nO_=caml_call1(fct,arg);return _nO_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _nN_=to_string$7(x);
        caml_call1(eprintf(_bp_),_nN_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _nM_=caml_call1(fct,arg);return _nM_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _nL_=to_string$7(x);
        caml_call1(eprintf(_bq_),_nL_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos?cst_Raised_by_primitive_operat:cst_Called_from}
      if(0 === slot[0])
       {var
         _nE_=slot[5],
         _nF_=slot[4],
         _nG_=slot[3],
         _nH_=slot[6]?cst_inlined:cst$64,
         _nI_=slot[2],
         _nJ_=info(slot[1]);
        return [0,caml_call6(sprintf(_br_),_nJ_,_nI_,_nH_,_nG_,_nF_,_nE_)]}
      if(slot[1])return 0;
      var _nK_=info(0);
      return [0,caml_call1(sprintf(_bs_),_nK_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_nC_=a.length - 1 - 1 | 0,_nB_=0;
        if(! (_nC_ < 0))
         {var i=_nB_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bt_),str)}
            var _nD_=i + 1 | 0;
            if(_nC_ !== i){var i=_nD_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bu_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtra(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_nz_=a.length - 1 - 1 | 0,_ny_=0;
        if(! (_nz_ < 0))
         {var i=_ny_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bv_),str)}
            var _nA_=i + 1 | 0;
            if(_nz_ !== i){var i=_nA_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _nx_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _nw_=0 === param[0]?1:0;
            if(! _nw_){var i$0=i - 1 | 0,i=i$0;continue}
            var _nx_=_nw_}
          return _nx_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtra(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var uncaught_exception_handler=[0,0];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = [0,fn];return 0}
    function _bw_(_nv_){return runtime.caml_raw_backtrace_next_slot(_nv_)}
    function _bx_(_nu_){return runtime.caml_convert_raw_backtrace_slot(_nu_)}
    function _by_(_nt_,_ns_)
     {return runtime.caml_raw_backtrace_slot(_nt_,_ns_)}
    function _bz_(_nr_){return runtime.caml_raw_backtrace_length(_nr_)}
    var
     _bA_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       format_backtrace_slot];
    function _bB_(_nq_){return caml_get_exception_raw_backtra(_nq_)}
    function _bC_(_np_){return runtime.caml_backtrace_status(_np_)}
    var
     Stdlib_printexc=
      [0,
       to_string$7,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_no_){return runtime.caml_record_backtrace(_no_)},
       _bC_,
       register_printer,
       use_printers,
       _bB_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bA_,
       _bz_,
       _by_,
       _bx_,
       _bw_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(781,Stdlib_printexc,"Stdlib__printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _nn_=caml_call1(finally$0,0);return _nn_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtra(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtra(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(782,Stdlib_fun,"Stdlib__fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_m8_=st[4];
      caml_call1(fprintf(c,_bD_),_m8_);
      var _m9_=st[5];
      caml_call1(fprintf(c,_bE_),_m9_);
      var _m__=st[14];
      caml_call1(fprintf(c,_bF_),_m__);
      fprintf(c,_bG_);
      var
       _m$_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bH_),_m$_)),
       _na_=st[1];
      caml_call2(fprintf(c,_bI_),l1,_na_);
      var _nb_=st[2];
      caml_call2(fprintf(c,_bJ_),l1,_nb_);
      var _nc_=st[3];
      caml_call2(fprintf(c,_bK_),l1,_nc_);
      fprintf(c,_bL_);
      var
       _nd_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bM_),_nd_)),
       _ne_=st[15];
      caml_call2(fprintf(c,_bN_),l2,_ne_);
      var _nf_=st[6];
      caml_call2(fprintf(c,_bO_),l2,_nf_);
      var _ng_=st[8];
      caml_call2(fprintf(c,_bP_),l2,_ng_);
      var _nh_=st[10];
      caml_call2(fprintf(c,_bQ_),l2,_nh_);
      var _ni_=st[12];
      caml_call2(fprintf(c,_bR_),l2,_ni_);
      var _nj_=st[13];
      caml_call2(fprintf(c,_bS_),l2,_nj_);
      fprintf(c,_bT_);
      var _nk_=st[9];
      caml_call1(fprintf(c,_bU_),_nk_);
      var _nl_=st[11];
      caml_call1(fprintf(c,_bV_),_nl_);
      var _nm_=st[7];
      return caml_call1(fprintf(c,_bW_),_nm_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _bX_(_m7_){return runtime.caml_final_release(_m7_)}
    function _bY_(_m6_,_m5_)
     {return runtime.caml_final_register_called_without_value(_m6_,_m5_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_m4_,_m3_){return runtime.caml_final_register(_m4_,_m3_)},
       _bY_,
       _bX_,
       create_alarm,
       delete_alarm];
    caml_register_global(783,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(str) - len | 0) < ofs))
       return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _m2_=10 <= n?87:48;return n + _m2_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _m1_=i + 1 | 0;
        if(15 !== i){var i=_m1_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_mZ_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _mZ_ | 0));
        var _m0_=i + 1 | 0;
        if(15 !== i){var i=_m0_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$5,
       equal$5,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(784,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _mY_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_mY_;continue}
        var accu=[0,cst_x$1],_mU_=54 + max(55,l) | 0,_mT_=0;
        if(! (_mU_ < 0))
         {var i=_mT_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(symbol(accu[1],caml_string_of_jsbytes("" + x)));
            var
             _mV_=accu[1],
             _mP_=caml_string_get(_mV_,3) << 24,
             _mQ_=caml_string_get(_mV_,2) << 16,
             _mR_=caml_string_get(_mV_,1) << 8,
             _mS_=((caml_string_get(_mV_,0) + _mR_ | 0) + _mQ_ | 0) + _mP_ | 0,
             _mW_=(caml_check_bound(s[1],j)[1 + j] ^ _mS_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _mW_;
            var _mX_=i + 1 | 0;
            if(_mU_ !== i){var i=_mX_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$2(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$2(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _mM_=s[2],
       curval=caml_check_bound(s[1],_mM_)[1 + _mM_],
       _mN_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_mN_)[1 + _mN_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _mO_=s[2];
      caml_check_bound(s[1],_mO_)[1 + _mO_] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound) && 0 < bound)
       for(;;)
        {var r=bits(s),v=caml_mod(r,bound);
         if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
         return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b0_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_bZ_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b1_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b2_=
      [0,
       make$2,
       make_self_init,
       copy$5,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b2_,
       get_state,
       set_state];
    caml_register_global(785,Stdlib_random,"Stdlib__random");
    function ongoing_traversal(h)
     {var _mK_=h.length - 1 < 4?1:0,_mL_=_mK_ || (h[4] < 0?1:0);return _mL_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cI_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cI_}
    catch(_mI_)
     {_mI_ = caml_wrap_exception(_mI_);
      if(_mI_ !== Not_found)throw _mI_;
      try
       {var _cH_=caml_sys_getenv(cst_CAMLRUNPARAM),_b3_=_cH_}
      catch(_mJ_)
       {_mJ_ = caml_wrap_exception(_mJ_);
        if(_mJ_ !== Not_found)throw _mJ_;
        var _b3_=cst$65}
      var params=_b3_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_mH_){return caml_call1(_b2_[2],0)}];
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
         {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _mF_=caml_obj_tag(prng),
          _mG_=250 === _mF_?prng[1]:246 === _mF_?force_lazy_block(prng):prng,
          seed=caml_call1(_b2_[4],_mG_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {var _mE_=0 < h[1]?1:0;
      return _mE_?(h[1] = 0,fill$0(h[2],0,h[2].length - 1,0)):_mE_}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b4_]}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _mB_=init[4],_mC_=init[3],_mD_=map$5(copy_bucketlist,init[2]);
      return [0,init[1],_mD_,_mC_,_mB_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _ms_=nsize < max_array_length?1:0;
      if(_ms_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _mu_=osize - 1 | 0,_mt_=0;
        if(! (_mu_ < 0))
         {var i$0=_mt_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
                caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
                var cell=next;
                continue}
              var _mA_=i$0 + 1 | 0;
              if(_mu_ !== i$0){var i$0=_mA_;continue a}
              break}
            break}}
        if(inplace)
         {var _mw_=nsize - 1 | 0,_mv_=0;
          if(! (_mw_ < 0))
           {var i=_mv_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
              if(match$0)match$0[3] = 0;
              var _mz_=i + 1 | 0;
              if(_mw_ !== i){var i=_mz_;continue}
              break}}
          var _mx_=0}
        else
         var _mx_=inplace;
        var _my_=_mx_}
      else
       var _my_=_ms_;
      return _my_}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_mo_=d.length - 1 - 1 | 0,_mn_=0;
        if(! (_mo_ < 0))
         {var i=_mn_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _mr_=i + 1 | 0;
            if(_mo_ !== i){var i=_mr_;continue}
            break}}
        var _mp_=1 - old_trav,_mq_=_mp_?flip_ongoing_traversal(h):_mp_;
        return _mq_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _mk_=d.length - 1 - 1 | 0,_mj_=0;
        if(! (_mk_ < 0))
         {var i=_mj_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _mm_=i + 1 | 0;
            if(_mk_ !== i){var i=_mm_;continue}
            break}}
        var _ml_=0;
        return _ml_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$3(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_mf_=d.length - 1 - 1 | 0,_me_=0;
        if(! (_mf_ < 0))
         {var i=_me_;
          for(;;)
           {var _mh_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_mh_);
            var _mi_=i + 1 | 0;
            if(_mf_ !== i){var i=_mi_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _mg_=accu[1];
        return _mg_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _mb_=h[2],
       _mc_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_mc_,_mb_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _md_=h[2];
      iter$5
       (function(b)
         {var l=bucket_length(0,b);
          histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
          return 0},
        _md_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_ma_){return aux(i$0,next,_ma_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _l9_=0,_l__=0;
      return function(_l$_){return aux(_l__,_l9_,_l$_)}}
    function to_seq_keys(m)
     {var _l5_=to_seq$9(m);
      function _l6_(_l8_){return _l8_[1]}
      return function(_l7_){return map(_l6_,_l5_,_l7_)}}
    function to_seq_values(m)
     {var _l1_=to_seq$9(m);
      function _l2_(_l4_){return _l4_[2]}
      return function(_l3_){return map(_l2_,_l1_,_l3_)}}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _l0_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _l0_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _lZ_=h[2].length - 1 << 1 < h[1]?1:0;
        return _lZ_?resize$0(key_index,h):_lZ_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _lY_=key_index(h,key),match=caml_check_bound(h[2],_lY_)[1 + _lY_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _lX_=key_index(h,key),match=caml_check_bound(h[2],_lX_)[1 + _lX_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _lW_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_lW_)[1 + _lW_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _lT_=0}
          else
           var _lT_=1;
          if(_lT_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _lU_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_lU_)return resize$0(key_index,h);
            var _lV_=_lU_}
          else
           var _lV_=_lT_;
          return _lV_}}
      function mem(h,key)
       {var
         _lS_=key_index(h,key),
         param$0=caml_check_bound(h[2],_lS_)[1 + _lS_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_lR_=caml_call2(H[1],k,key);
            if(_lR_)return _lR_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$3,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make$0(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _lQ_=include[1];
      function create(sz){return caml_call2(_lQ_,_b5_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _lP_=h[2].length - 1 << 1 < h[1]?1:0;
      return _lP_?resize$0(key_index,h):_lP_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _lO_=key_index(h,key),match=caml_check_bound(h[2],_lO_)[1 + _lO_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _lN_=key_index(h,key),match=caml_check_bound(h[2],_lN_)[1 + _lN_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _lM_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_lM_)[1 + _lM_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _lJ_=0}
        else
         var _lJ_=1;
        if(_lJ_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _lK_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_lK_)return resize$0(key_index,h);
          var _lL_=_lK_}
        else
         var _lL_=_lJ_;
        return _lL_}}
    function mem$2(h,key)
     {var
       _lI_=key_index(h,key),
       param$0=caml_check_bound(h[2],_lI_)[1 + _lI_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_lH_=0 === caml_compare(k,key)?1:0;
          if(_lH_)return _lH_;
          var param=next;
          continue}
        return 0}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    var
     Stdlib_hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$3,
       length$4,
       randomize,
       is_randomized,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make$0,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(786,Stdlib_hashtbl,"Stdlib__hashtbl");
    function weak_create(l)
     {var _lF_=0 <= l?1:0,_lG_=_lF_?l <= _r_[15]?1:0:_lF_;
      if(1 - _lG_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _lC_=0 <= o?1:0,_lD_=_lC_?o < length$5(e)?1:0:_lC_,_lE_=1 - _lD_;
      return _lE_?invalid_arg(msg):_lE_}
    function set(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$5(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$5(e2) - l | 0) < o2))
       {var
         _lA_=0 !== l?1:0,
         _lB_=_lA_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_lA_;
        return _lB_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs && 0 <= len && ! ((length$5(ar) - len | 0) < ofs))
       {var _ly_=(ofs + len | 0) - 1 | 0;
        if(! (_ly_ < ofs))
         {var i=ofs;
          for(;;)
           {set(ar,i,x);
            var _lz_=i + 1 | 0;
            if(_ly_ !== i){var i=_lz_;continue}
            break}}
        return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$1(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _lw_=t[1].length - 1 - 1 | 0,_lv_=0;
        if(! (_lw_ < 0))
         {var i=_lv_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _lx_=i + 1 | 0;
            if(_lw_ !== i){var i=_lx_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _lu_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$0(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lu_,
                 init)}
      function iter(f,t)
       {var _lt_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$0(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lt_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _ls_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _ls_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _ln_=0,_lo_=t[1],_lp_=0;
        return fold_right$0
                (function(_lq_,_lr_){return count_bucket(_lp_,_lq_,_lr_)},
                 _lo_,
                 _ln_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)failwith(cst_Weak_Make_hash_bucket_cann);
            var
             newbucket$0=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket$0,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket$0,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket$0;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _lj_=sz <= t[3]?1:0,_lk_=_lj_?t[3] < newsz?1:0:_lj_;
            if(_lk_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _k$_=t[5],
                 bucket=caml_check_bound(t[1],_k$_)[1 + _k$_],
                 _la_=t[5],
                 hbucket=caml_check_bound(t[2],_la_)[1 + _la_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _lb_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _lb_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _lc_=t[5];
                      caml_check_bound(t[1],_lc_)[1 + _lc_] = emptybucket;
                      var _ld_=t[5];
                      caml_check_bound(t[2],_ld_)[1 + _ld_] = [0]}
                    else
                     {var newbucket=weak_create(prev_len);
                      blit$4(bucket,0,newbucket,0,prev_len);
                      var _lg_=t[5];
                      caml_check_bound(t[1],_lg_)[1 + _lg_] = newbucket;
                      var _lh_=sub$1(hbucket,0,prev_len),_li_=t[5];
                      caml_check_bound(t[2],_li_)[1 + _li_] = _lh_}
                    var _le_=t[3] < n?1:0,_lf_=_le_?prev_len <= t[3]?1:0:_le_;
                    if(_lf_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _lm_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_lm_;continue}
                break}}
            var _ll_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_ll_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_k__=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(match)
                       {var
                         oh=caml_check_bound(t[2],j)[1 + j],
                         setter$0=
                          function(i)
                           {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                            return setter},
                         setter=setter$0(i$0),
                         h=caml_check_bound(oh,i$0)[1 + i$0];
                        add_aux(newt,setter,0,h,get_index(newt,h));
                        var i$1=i$0 + 1 | 0,i$0=i$1;
                        continue}
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _k__);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _ll_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);return add_aux(t,set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$0(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,d,function(h,index){add_aux(t,set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$0(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _k9_=0;
        return find_shadow(t,d,function(w,i){return set(w,i,0)},_k9_)}
      function mem(t,d)
       {var _k8_=0;return find_shadow(t,d,function(w,i){return 1},_k8_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$0(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$5(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _k0_=0,
         totlen=
          fold_left$1(function(_k7_,_k6_){return _k7_ + _k6_ | 0},_k0_,lens),
         _k1_=len - 1 | 0,
         _k3_=len / 2 | 0,
         _k2_=caml_check_bound(lens,_k1_)[1 + _k1_],
         _k4_=caml_check_bound(lens,_k3_)[1 + _k3_],
         _k5_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_k5_,_k4_,_k2_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,weak_create,length$5,set,get$0,get_copy,check$0,fill$2,blit$4,Make$1];
    caml_register_global(787,Stdlib_weak,"Stdlib__weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _kZ_=caml_string_notequal(s,cst$66);
      return _kZ_?format_pp_text(state,caml_ml_string_length(s),s):_kZ_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_b6_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var match$12=peek_opt(state[28]);
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _kX_=0 <= size$0?1:0,
           _kY_=_kX_ || (state[9] <= pending_count?1:0);
          if(_kY_)
           {take(state[28]);
            var size$1=0 <= size$0?size$0:pp_infinity;
            if(typeof token === "number")
             switch(token)
              {case 0:
                var match$3=top_opt(state[3]);
                if(match$3)
                 {var
                   match$4=match$3[1],
                   tabs=match$4[1],
                   add_tab=
                    function(n,ls)
                     {if(ls)
                       {var l=ls[2],x=ls[1];
                        return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                      return [0,n,0]};
                  tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                break;
               case 1:pop_opt(state[2]);break;
               case 2:pop_opt(state[3]);break;
               case 3:
                var match$5=top_opt(state[2]);
                if(match$5)
                 {var match$6=match$5[1],width$0=match$6[2];
                  break_line(state,width$0)}
                else
                 pp_output_newline(state);
                break;
               case 4:
                if(state[10] !== (state[6] - state[9] | 0))
                 {var match$1=take_opt(state[28]);
                  if(match$1)
                   {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                    state[12] = state[12] - length | 0;
                    state[9] = state[9] + size | 0}}
                break;
               default:
                var match$7=pop_opt(state[5]);
                if(match$7)
                 {var
                   tag_name=match$7[1],
                   marker=caml_call1(state[25],tag_name);
                  pp_output_string(state,marker)}}
            else
             switch(token[0])
              {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
               case 1:
                var
                 breaks=token[2],
                 fits=token[1],
                 off=breaks[2],
                 before=breaks[1],
                 match$8=top_opt(state[2]);
                if(match$8)
                 {var
                   match$9=match$8[1],
                   width$1=match$9[2],
                   box_type$0=match$9[1];
                  switch(box_type$0)
                   {case 0:break_same_line(state,fits);break;
                    case 1:break_new_line(state,breaks,width$1);break;
                    case 2:break_new_line(state,breaks,width$1);break;
                    case 3:
                     if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                      break_new_line(state,breaks,width$1);
                     else
                      break_same_line(state,fits);
                     break;
                    case 4:
                     if(state[11])
                      break_same_line(state,fits);
                     else
                      if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                       break_new_line(state,breaks,width$1);
                      else
                       if(((state[6] - width$1 | 0) + off | 0) < state[10])
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                     break;
                    default:break_same_line(state,fits)}}
                break;
               case 2:
                var
                 off$0=token[2],
                 n=token[1],
                 insertion_point=state[6] - state[9] | 0,
                 match$10=top_opt(state[3]);
                if(match$10)
                 {var match$11=match$10[1],tabs$0=match$11[1],_kV_=tabs$0[1];
                  if(_kV_)
                   {var first=_kV_[1],param=tabs$0[1];
                    for(;;)
                     {if(param)
                       {var tail=param[2],head=param[1];
                        if(! (insertion_point <= head)){var param=tail;continue}
                        var _kW_=head}
                      else
                       var _kW_=first;
                      var tab=_kW_;
                      break}}
                  else
                   var tab=insertion_point;
                  var offset=tab - insertion_point | 0;
                  if(0 <= offset)
                   break_same_line(state,[0,cst$68,offset + n | 0,cst$67]);
                  else
                   break_new_line
                    (state,[0,cst$70,tab + off$0 | 0,cst$69],state[6])}
                break;
               case 3:
                var
                 ty=token[2],
                 off$1=token[1],
                 insertion_point$0=state[6] - state[9] | 0;
                if(state[8] < insertion_point$0)
                 {var match=top_opt(state[2]);
                  if(match)
                   {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                    if(state[9] < width)
                     {var switcher=box_type - 1 | 0;
                      if(! (3 < switcher >>> 0))break_line(state,width)}}
                  else
                   pp_output_newline(state)}
                var
                 width$2=state[9] - off$1 | 0,
                 box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                push([0,box_type$1,width$2],state[2]);
                break;
               case 4:var tbox=token[1];push(tbox,state[3]);break;
               default:
                var
                 tag_name$0=token[1],
                 marker$0=caml_call1(state[24],tag_name$0);
                pp_output_string(state,marker$0);
                push(tag_name$0,state[5])}
            state[12] = length$0 + state[12] | 0;
            continue}
          return _kY_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_b7_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _kS_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _kT_=queue_elem[2];
        if(typeof _kT_ !== "number")
         switch(_kT_[0])
          {case 3:
            var _kU_=1 - ty;
            return _kU_
                    ?(queue_elem[1] = state[13] + _kS_ | 0,pop_opt(state[1]),0)
                    :_kU_;
           case 1:
           case 2:
            return ty
                    ?(queue_elem[1] = state[13] + _kS_ | 0,pop_opt(state[1]),0)
                    :ty
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _kQ_=state[14] === state[15]?1:0;
      if(_kQ_)
       {var _kR_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_kR_),_kR_)}
      return _kQ_}
    function pp_close_box(state,param)
     {var _kO_=1 < state[14]?1:0;
      if(_kO_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _kP_=0}
      else
       var _kP_=_kO_;
      return _kP_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _kN_=state[23];
      if(_kN_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _kN_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _kL_=state[22];
      if(_kL_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _kM_=0}
      else
       var _kM_=_kL_;
      return _kM_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_function(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_function(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _kK_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_kK_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _kJ_=state[14] < state[15]?1:0;
      return _kJ_?enqueue_string_as(state,size,s):_kJ_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_string_of_jsbytes("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _kI_=state[14] < state[15]?1:0;
      return _kI_?enqueue_advance(state,[0,size,3,0]):_kI_}
    function pp_print_if_newline(state,param)
     {var _kH_=state[14] < state[15]?1:0;
      return _kH_?enqueue_advance(state,[0,size,4,0]):_kH_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _kG_=state[14] < state[15]?1:0;
      if(_kG_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _kG_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$74,width,cst$73],[0,cst$72,offset,cst$71])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _kF_=state[14] < state[15]?1:0;
      if(_kF_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _kF_}
    function pp_close_tbox(state,param)
     {var _kC_=1 < state[14]?1:0;
      if(_kC_)
       {var _kD_=state[14] < state[15]?1:0;
        if(_kD_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _kE_=0}
        else
         var _kE_=_kD_}
      else
       var _kE_=_kC_;
      return _kE_}
    function pp_print_tbreak(state,width,offset)
     {var _kB_=state[14] < state[15]?1:0;
      if(_kB_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _kB_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _kA_=state[14] < state[15]?1:0;
      if(_kA_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _kA_}
    function pp_set_max_boxes(state,n)
     {var _ky_=1 < n?1:0,_kz_=_ky_?(state[15] = n,0):_ky_;return _kz_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _kx_=1 < n$0?1:0;
      if(_kx_)
       {var n$1=state[6] - n$0 | 0,_kw_=1 <= n$1?1:0;
        if(_kw_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _kw_}
      return _kx_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _kv_=1 <= n?1:0;
      if(_kv_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _kv_}
    function check_geometry(geometry)
     {var
       _kt_=1 < geometry[1]?1:0,
       _ku_=_kt_?geometry[1] < geometry[2]?1:0:_kt_;
      return _ku_}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_geometry(state,max_indent,margin)
     {if(2 <= max_indent)
       {if(margin <= max_indent)
         throw [0,Invalid_argument,cst_Format_pp_set_geometry_mar];
        pp_set_margin(state,margin);
        return pp_set_max_indent(state,max_indent)}
      throw [0,Invalid_argument,cst_Format_pp_set_geometry_max]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {return check_geometry([0,max_indent,margin])
              ?pp_set_geometry(state,max_indent,margin)
              :0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functi(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functi(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$75,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _ks_=0 < n$0?1:0;
        if(_ks_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _ks_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_kp_,_kq_,_kr_){return output_substring(oc,_kp_,_kq_,_kr_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_ko_){return display_newline(state,_ko_)};
      state[20] = function(_kn_){return display_indent(state,_kn_)};
      state[21] = function(_km_){return display_indent(state,_km_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$77,symbol(s,cst$76))}
      return cst$78}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$80,symbol(s,cst$79))}
      return cst$81}
    function default_pp_print_open_tag(_kl_){return 0}
    function default_pp_print_close_tag(_kk_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_b8_,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _kh_=create$0(0),_ki_=create$0(0),_kj_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _kj_,
              _ki_,
              _kh_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$82,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _j$_(_kg_){return 0}
      function _ka_(_kf_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_ke_){return 0},_ka_,_j$_);
      ppf[19] = function(_kd_){return display_newline(ppf,_kd_)};
      ppf[20] = function(_kc_){return display_indent(ppf,_kc_)};
      ppf[21] = function(_kb_){return display_indent(ppf,_kb_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _j7_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_j8_,_j9_,_j__)
                {return output_substring(oc,_j8_,_j9_,_j__)},
               _j7_)}
    function formatter_of_buffer(b)
     {function _j2_(_j6_){return 0}
      return make_formatter
              (function(_j3_,_j4_,_j5_)
                {return add_substring(b,_j3_,_j4_,_j5_)},
               _j2_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_b(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_j1_){return add_symbolic_output_item(sob,0)}
      function h(_j0_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_jZ_){return pp_open_hbox(std_formatter,_jZ_)}
    function open_vbox(_jY_){return pp_open_vbox(std_formatter,_jY_)}
    function open_hvbox(_jX_){return pp_open_hvbox(std_formatter,_jX_)}
    function open_hovbox(_jW_){return pp_open_hovbox(std_formatter,_jW_)}
    function open_box(_jV_){return pp_open_box(std_formatter,_jV_)}
    function close_box(_jU_){return pp_close_box(std_formatter,_jU_)}
    function open_tag(_jT_){return pp_open_tag(std_formatter,_jT_)}
    function close_tag(_jS_){return pp_close_tag(std_formatter,_jS_)}
    function open_stag(_jR_){return pp_open_stag(std_formatter,_jR_)}
    function close_stag(_jQ_){return pp_close_stag(std_formatter,_jQ_)}
    function print_as(_jO_,_jP_){return pp_print_as(std_formatter,_jO_,_jP_)}
    function print_string$0(_jN_){return pp_print_string(std_formatter,_jN_)}
    function print_int$0(_jM_){return pp_print_int(std_formatter,_jM_)}
    function print_float$0(_jL_){return pp_print_float(std_formatter,_jL_)}
    function print_char$0(_jK_){return pp_print_char(std_formatter,_jK_)}
    function print_bool(_jJ_){return pp_print_bool(std_formatter,_jJ_)}
    function print_break(_jH_,_jI_)
     {return pp_print_break(std_formatter,_jH_,_jI_)}
    function print_cut(_jG_){return pp_print_cut(std_formatter,_jG_)}
    function print_space(_jF_){return pp_print_space(std_formatter,_jF_)}
    function force_newline(_jE_){return pp_force_newline(std_formatter,_jE_)}
    function print_flush(_jD_){return pp_print_flush(std_formatter,_jD_)}
    function print_newline$0(_jC_)
     {return pp_print_newline(std_formatter,_jC_)}
    function print_if_newline(_jB_)
     {return pp_print_if_newline(std_formatter,_jB_)}
    function open_tbox(_jA_){return pp_open_tbox(std_formatter,_jA_)}
    function close_tbox(_jz_){return pp_close_tbox(std_formatter,_jz_)}
    function print_tbreak(_jx_,_jy_)
     {return pp_print_tbreak(std_formatter,_jx_,_jy_)}
    function set_tab(_jw_){return pp_set_tab(std_formatter,_jw_)}
    function print_tab(_jv_){return pp_print_tab(std_formatter,_jv_)}
    function set_margin(_ju_){return pp_set_margin(std_formatter,_ju_)}
    function get_margin(_jt_){return std_formatter[6]}
    function set_max_indent(_js_)
     {return pp_set_max_indent(std_formatter,_js_)}
    function get_max_indent(_jr_){return std_formatter[8]}
    function set_geometry(_jp_,_jq_)
     {return pp_set_geometry(std_formatter,_jp_,_jq_)}
    function safe_set_geometry(_jn_,_jo_)
     {return pp_safe_set_geometry(std_formatter,_jn_,_jo_)}
    function get_geometry(_jm_){return pp_get_geometry(std_formatter,_jm_)}
    function set_max_boxes(_jl_){return pp_set_max_boxes(std_formatter,_jl_)}
    function get_max_boxes(_jk_){return std_formatter[15]}
    function over_max_boxes(_jj_)
     {return pp_over_max_boxes(std_formatter,_jj_)}
    function set_ellipsis_text(_ji_)
     {return pp_set_ellipsis_text(std_formatter,_ji_)}
    function get_ellipsis_text(_jh_){return std_formatter[16]}
    function set_formatter_out_channel(_jg_)
     {return pp_set_formatter_out_channel(std_formatter,_jg_)}
    function set_formatter_out_functions(_jf_)
     {return pp_set_formatter_out_functions(std_formatter,_jf_)}
    function get_formatter_out_functions(_je_)
     {return pp_get_formatter_out_functions(std_formatter,_je_)}
    function set_formatter_output_functions(_jc_,_jd_)
     {return pp_set_formatter_output_functi(std_formatter,_jc_,_jd_)}
    function get_formatter_output_functions(_jb_)
     {return pp_get_formatter_output_functi(std_formatter,_jb_)}
    function set_formatter_stag_functions(_ja_)
     {return pp_set_formatter_stag_function(std_formatter,_ja_)}
    function get_formatter_stag_functions(_i$_)
     {return pp_get_formatter_stag_function(std_formatter,_i$_)}
    function set_print_tags(_i__)
     {return pp_set_print_tags(std_formatter,_i__)}
    function get_print_tags(_i9_){return std_formatter[22]}
    function set_mark_tags(_i8_){return pp_set_mark_tags(std_formatter,_i8_)}
    function get_mark_tags(_i7_){return std_formatter[23]}
    function set_tags(_i6_){return pp_set_tags(std_formatter,_i6_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _i5_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp_v,ppf,_i5_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp_v,ppf,_i5_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _i4_=left[1] !== len?1:0;
        return _i4_?flush(0):_i4_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_i3_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iT_=acc[2],_iU_=acc[1];
          if(0 === _iT_[0])
           {var acc$0=_iT_[1];
            output_acc$0(ppf,_iU_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_iT_[1];
          output_acc$0(ppf,_iU_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iV_=acc[1],switch$1=0;
          if(typeof _iV_ !== "number" && 0 === _iV_[0])
           {var _iW_=_iV_[2],switch$2=0;
            if(typeof _iW_ !== "number" && 1 === _iW_[0])
             {var s$0=acc[2],size=_iW_[2],p$1=_iV_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_iV_;switch$0 = 2}
          break;
         case 3:
          var _iX_=acc[1],switch$3=0;
          if(typeof _iX_ !== "number" && 0 === _iX_[0])
           {var _iY_=_iX_[2],switch$4=0;
            if(typeof _iY_ !== "number" && 1 === _iY_[0])
             {var c$0=acc[2],size$0=_iY_[2],p$3=_iX_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_iX_;switch$0 = 3}
          break;
         case 4:
          var _iZ_=acc[1],switch$5=0;
          if(typeof _iZ_ !== "number" && 0 === _iZ_[0])
           {var _i0_=_iZ_[2],switch$6=0;
            if(typeof _i0_ !== "number" && 1 === _i0_[0])
             {var s$0=acc[2],size=_i0_[2],p$1=_iZ_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_iZ_;switch$0 = 2}
          break;
         case 5:
          var _i1_=acc[1],switch$7=0;
          if(typeof _i1_ === "number" || ! (0 === _i1_[0]))
           switch$7 = 1;
          else
           {var _i2_=_i1_[2],switch$8=0;
            if(typeof _i2_ !== "number" && 1 === _i2_[0])
             {var c$0=acc[2],size$0=_i2_[2],p$3=_i1_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_i1_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iH_=acc[2],_iI_=acc[1];
          if(0 === _iH_[0])
           {var acc$0=_iH_[1];
            strput_acc$0(ppf,_iI_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_iH_[1];
          strput_acc$0(ppf,_iI_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iJ_=acc[1],switch$1=0;
          if(typeof _iJ_ !== "number" && 0 === _iJ_[0])
           {var _iK_=_iJ_[2],switch$2=0;
            if(typeof _iK_ !== "number" && 1 === _iK_[0])
             {var s$0=acc[2],size=_iK_[2],p$1=_iJ_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_iJ_;switch$0 = 2}
          break;
         case 3:
          var _iL_=acc[1],switch$3=0;
          if(typeof _iL_ !== "number" && 0 === _iL_[0])
           {var _iM_=_iL_[2],switch$4=0;
            if(typeof _iM_ !== "number" && 1 === _iM_[0])
             {var c$0=acc[2],size$0=_iM_[2],p$3=_iL_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_iL_;switch$0 = 3}
          break;
         case 4:
          var _iN_=acc[1],switch$5=0;
          if(typeof _iN_ !== "number" && 0 === _iN_[0])
           {var _iO_=_iN_[2],switch$6=0;
            if(typeof _iO_ !== "number" && 1 === _iO_[0])
             {var s$0=acc[2],size=_iO_[2],p$1=_iN_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_iN_;switch$0 = 2}
          break;
         case 5:
          var _iP_=acc[1],switch$7=0;
          if(typeof _iP_ === "number" || ! (0 === _iP_[0]))
           switch$7 = 1;
          else
           {var _iQ_=_iP_[2],switch$8=0;
            if(typeof _iQ_ !== "number" && 1 === _iQ_[0])
             {var c$0=acc[2],size$0=_iQ_[2],p$3=_iP_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_iP_;switch$0 = 3}
          break;
         case 6:
          var _iR_=acc[1];
          if(typeof _iR_ !== "number" && 0 === _iR_[0])
           {var _iS_=_iR_[2];
            if(typeof _iS_ !== "number" && 1 === _iS_[0])
             {var f$1=acc[2],size$1=_iS_[2],p$4=_iR_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_iR_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_iG_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _iG_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_iE_=0;
      return make_iprintf(function(_iF_){return 0},_iE_,fmt)}
    function fprintf$0(ppf)
     {function _iB_(_iD_){return 0}
      return function(_iC_){return kfprintf$0(_iB_,ppf,_iC_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_iA_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _iA_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_fu(state,f,g,h,i)
     {pp_set_formatter_output_functi(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_fu(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_funct(_iw_,_ix_,_iy_,_iz_)
     {return pp_set_all_formatter_output_fu(std_formatter,_iw_,_ix_,_iy_,_iz_)}
    function get_all_formatter_output_funct(_iv_)
     {return pp_get_all_formatter_output_fu(std_formatter,_iv_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_iu_){return stringify(mot,cst$83,_iu_)};
      state[25] = function(_it_){return stringify(mct,cst$84,_it_)};
      var _ip_=0;
      state[26] = function(_is_){return stringify(pot,_ip_,_is_)};
      var _iq_=0;
      state[27] = function(_ir_){return stringify(pct,_iq_,_ir_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_function(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_io_)
     {return pp_set_formatter_tag_functions(std_formatter,_io_)}
    function get_formatter_tag_functions(_in_)
     {return pp_get_formatter_tag_functions(std_formatter,_in_)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(788,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_im_)
       {_im_ = caml_wrap_exception(_im_);
        if(_im_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _im_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _il_=ib[9];
      if(typeof _il_ === "number")
       return 0 === _il_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _il_[0])return cst_unnamed_Stdlib_input_chann;
        var fname=_il_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _b9_=0;
    function from_function$0(_ik_){return create$4(_b9_,_ik_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$85,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$86))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_ij_){return open_in_file(open_in,_ij_)}
    function from_file_bin(_ii_){return open_in_file(open_in_bin,_ii_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _ih_=ib[9];
      if(typeof _ih_ === "number")
       return 0;
      else
       {if(0 === _ih_[0]){var ic=_ih_[1];return caml_ml_close_channel(ic)}
        var ic$0=_ih_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _if_=assq(ic,memo[1]);return _if_}
      catch(_ig_)
       {_ig_ = caml_wrap_exception(_ig_);
        if(_ig_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _ig_}}
    function memo_from_channel(_ie_)
     {return memo_from_ic(scan_raise_at_end,_ie_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_b__),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_b$_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_fo)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexad)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cb_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_ic_=1 - ib[1];
         if(_ic_)
          {var _id_=c - 9 | 0,switch$0=0;
           if(4 < _id_ >>> 0)
            {if(23 === _id_)switch$0 = 1}
           else
            if(1 < (_id_ - 2 | 0) >>> 0)switch$0 = 1;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _ic_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_cc_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cd_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=symbol(cst_0b,token_string(ib));break;
        case 3:var tok=symbol(cst_0o,token_string(ib));break;
        case 4:var tok=symbol(cst_0u,token_string(ib));break;
        case 5:var tok=symbol(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_ce_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_cf_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_ia_,_ib_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_ia_,_ib_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_h__,_h$_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_h__,_h$_)}
    function is_hexa_digit(param)
     {var _h9_=param - 48 | 0,switch$0=0;
      if(22 < _h9_ >>> 0)
       {if(! (5 < (_h9_ - 49 | 0) >>> 0))switch$0 = 1}
      else
       if(6 < (_h9_ - 10 | 0) >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_h7_,_h8_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_h7_,_h8_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           var switch$0=0;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             if(120 === c$0)switch$0 = 1}
           else
            if(88 === c$0)
             switch$0 = 1;
            else
             if(98 <= c$0)return scan_binary_int(store_char(width,ib,c$0),ib);
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _h4_=len - 1 | 0,
       _h3_=0;
      if(! (_h4_ < 0))
       {var i=_h3_;
        for(;;)
         {var c=peek_char(ib),_h5_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _h5_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _h6_=i + 1 | 0;
          if(_h4_ !== i){var i=_h6_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _hQ_=0 === width?1:0,_hR_=_hQ_ || end_of_input(ib);
      if(_hR_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _hS_=0 === width$0?1:0,
       _hT_=_hS_ || end_of_input(ib);
      if(_hT_)bad_hex_float(0);
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _hU_=0 === width$1?1:0,
             _hV_=_hU_ || end_of_input(ib);
            if(_hV_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _hY_=0 === width$3?1:0,
           _hZ_=_hY_ || end_of_input(ib);
          if(_hZ_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_h0_=match - 46 | 0,switch$1=0;
            if(34 < _h0_ >>> 0)
             {if(66 === _h0_)switch$1 = 1}
            else
             if(32 < (_h0_ - 1 | 0) >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _h1_=0 === width$9?1:0,
                 _h2_=_h1_ || end_of_input(ib);
                if(_h2_)bad_hex_float(0);
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _hW_=0 === width$2?1:0,
         _hX_=_hW_ || end_of_input(ib);
        if(_hX_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _hM_=0 === width?1:0,_hN_=_hM_ || end_of_input(ib);
      if(_hN_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _hO_=0 === width$0?1:0,
       _hP_=_hO_ || end_of_input(ib);
      if(_hP_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _hy_=0 === width?1:0,_hz_=_hy_ || end_of_input(ib);
      if(_hz_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _hA_=0 === width$0?1:0,
       _hB_=_hA_ || end_of_input(ib);
      if(_hB_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _hC_=0 === width$1?1:0,
           _hD_=_hC_ || end_of_input(ib);
          if(_hD_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _hE_=0 === width$2?1:0,
          _hF_=_hE_ || end_of_input(ib);
         if(_hF_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _hG_=0 === width$3?1:0,
          _hH_=_hG_ || end_of_input(ib);
         if(_hH_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _hI_=0 === width$4?1:0,
          _hJ_=_hI_ || end_of_input(ib);
         if(_hJ_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)var width$7=width$4;else switch$0 = 1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _hK_=0 === width$9?1:0,
            _hL_=_hK_ || end_of_input(ib);
           if(_hL_)bad_hex_float(0);
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var _hx_=c - 9 | 0,switch$0=0;
        if(4 < _hx_ >>> 0)
         {if(23 === _hx_)switch$0 = 1}
        else
         if(1 < (_hx_ - 2 | 0) >>> 0)switch$0 = 1;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_ca_),message)):c}
    function check_next_char_for_char(_hv_,_hw_)
     {return check_next_char(cst_a_Char,_hv_,_hw_)}
    function check_next_char_for_string(_ht_,_hu_)
     {return check_next_char(cst_a_String,_ht_,_hu_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher$0=c0 - 92 | 0;
          if(! (28 < switcher$0 >>> 0))
           switch(switcher$0)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_hs_=c - 48 | 0,switch$0=0;
                  if(22 < _hs_ >>> 0)
                   {if(! (5 < (_hs_ - 49 | 0) >>> 0))switch$0 = 1}
                  else
                   if(6 < (_hs_ - 10 | 0) >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               c1=get_digit(0),
               c2=get_digit(0),
               _ho_=hexadecimal_value_of_char(c2),
               c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _ho_ | 0,
               switch$1=0;
              if(0 <= c$0 && ! (255 < c$0))
               {var _hq_=char_of_int(c$0);switch$1 = 1}
              if(! switch$1)
               var _hq_=bad_input(caml_call2(sprintf(_ch_),c1,c2));
              return store_char(width - 2 | 0,ib,_hq_);
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0,
            switch$2=0;
           if(0 <= c && ! (255 < c)){var _hr_=char_of_int(c);switch$2 = 1}
           if(! switch$2)
            var _hr_=bad_input(caml_call3(sprintf(_cg_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_hr_)}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      if(switch$0)
       {var switch$3=0;
        if(110 <= c0)
         if(117 <= c0)
          switch$3 = 1;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _hp_=10;break;
             case 4:var _hp_=13;break;
             case 6:var _hp_=9;break;
             default:switch$3 = 1}}
        else
         if(98 === c0)var _hp_=8;else switch$3 = 1;
        if(switch$3)var _hp_=c0;
        return store_char(width,ib,_hp_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _hm_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_hm_)}
              return caml_trampoline_return(skip_spaces,[0,_hm_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _hn_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_hn_)}
                return caml_trampoline_return(skip_spaces,[0,_hn_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_hi_=0 < i$0?1:0;
          if(_hi_)
           {var _hj_=1 - ib[1];
            if(_hj_)
             var _hk_=is_in_char_set(char_set,c),_hl_=_hk_?c !== stp?1:0:_hk_;
            else
             var _hl_=_hj_}
          else
           var _hl_=_hi_;
          if(_hl_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _hl_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _hh_=1 - ib[1];
        if(_hh_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _hh_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cj_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _ck_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_hf_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_hf_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_hf_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _hg_=fmt$0[1];
           if(0 === _hg_[0])
            {var
              rest$0=fmt$0[2],
              match=_hg_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_hg_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)return invalid_arg(cst_scanf_bad_conversion);
          caml_call3(scan,max_int,max_int,ib);
          var x=caml_call1(token,ib);
          return [0,x,make_scanf(ib,fmt,readers)]}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(pad[1])
           {var _he_=pad[2];
            if(typeof prec === "number")
             {if(prec)return invalid_arg(cst_scanf_bad_conversion$0);
              caml_call3(scan,_he_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            var p$0=prec[1];
            caml_call3(scan,_he_,p$0,ib);
            var x$2=caml_call1(token,ib);
            return [0,x$2,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion$1)}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _g3_=fmt$0[1],_g4_=fmt$0[2];
           if(typeof _g4_ !== "number")
            switch(_g4_[0])
             {case 17:
               var
                rest$2=_g4_[2],
                fmting_lit=_g4_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$2];
               return pad_prec_scanf
                       (ib,str_rest,readers,_g3_,0,scan$0,token_string);
              case 18:
               var _g5_=_g4_[1];
               if(0 === _g5_[0])
                {var
                  rest$3=_g4_[2],
                  match$0=_g5_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cl_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$3),
                          readers,
                          _g3_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$4=_g4_[2],
                match$1=_g5_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cm_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$4),
                        readers,
                        _g3_,
                        0,
                        scan$2,
                        token_string)
              }
           var
            rest$1=fmt$0[2],
            scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,rest$1,readers,_g3_,0,scan,token_string);
          case 3:
           var
            rest$5=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$5,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$6=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$7=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$8=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$9=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$9,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           switch(fmt$0[1][2])
            {case 5:
             case 8:
              var rest$11=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
              return pad_prec_scanf
                      (ib,
                       rest$11,
                       readers,
                       pad$5,
                       prec$4,
                       scan_caml_float,
                       token_float);
             case 6:
             case 7:
              var rest$12=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$12,readers,pad$6,prec$5,scan_hex_float,token_float);
             default:
              var rest$10=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$10,readers,pad$4,prec$3,scan_float,token_float)}
          case 9:
           var
            rest$13=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_hd_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_ci_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$13,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$14=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$14;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$15=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_hc_){return check_char(ib,_hc_)},str$0);
           var fmt$0=rest$15;
           continue;
          case 12:
           var rest$16=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$16;
           continue;
          case 13:
           var rest$17=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _g6_=format_of_string_fmtty(s,fmtty),fmt$3=_g6_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$17,readers)];
          case 14:
           var rest$18=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _g8_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=fmt$8,
              fmt$4=_g8_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _g7_=bad_input(msg$0),
              fmt$5=_g7_[2],
              fmt$4=_g7_[1]}
           return [0,
                   [0,fmt$4,s$0],
                   make_scanf(ib,concat_fmt(fmt$5,rest$18),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$19=fmt$0[2],
            formatting_lit=fmt$0[1],
            _g9_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_hb_){return check_char(ib,_hb_)},_g9_);
           var fmt$0=rest$19;
           continue;
          case 18:
           var _g__=fmt$0[1];
           if(0 === _g__[0])
            {var rest$20=fmt$0[2],match$4=_g__[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$20),fmt$0=fmt$10;
             continue}
           var rest$21=fmt$0[2],match$5=_g__[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$21),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _g$_=fmt$0[1],_ha_=fmt$0[3];
           if(typeof _ha_ !== "number" && 17 === _ha_[0])
            {var
              rest$23=_ha_[2],
              fmting_lit$0=_ha_[1],
              char_set$0=fmt$0[2],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_g$_);
             scan_chars_in_char_set(char_set$0,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$23];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var
            rest$22=fmt$0[3],
            char_set=fmt$0[2],
            width=width_of_pad_opt(_g$_);
           scan_chars_in_char_set(char_set,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,rest$22,readers)];
          case 21:
           var
            rest$24=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$24,readers)];
          case 22:
           var rest$25=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$25,readers)];
          case 23:
           var
            rest$26=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$26),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cn_];
          default:return invalid_arg(cst_scanf_bad_conversion_custo)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _g2_=[0,make_scanf(ib,fmt,readers)],_g1_=_g2_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _g0_=
              invalid_arg
               (symbol
                 (msg,symbol(cst_in_format,symbol(escaped$1(str),cst$87))));
            switch$0 = 1}
          if(! switch$0)var _g0_=[1,exc];
          var _g1_=_g0_}
        if(0 === _g1_[0]){var args=_g1_[1];return apply(f,args)}
        var exc=_g1_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _gZ_=format_of_string_format(str,format),fmt=_gZ_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _gY_(x){return x}
      return sscanf_format
              (symbol(cst$89,symbol(escaped$1(s),cst$88)),fmt,_gY_)}
    function unescaped(s)
     {function _gX_(x){return x}
      return caml_call1(sscanf(symbol(cst$91,symbol(s,cst$90)),_co_),_gX_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(789,Stdlib_scanf,"Stdlib__scanf");
    var register=caml_register_named_value;
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(790,Stdlib_callback,"Stdlib__callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_gU_=caml_ml_string_length(s) - 1 | 0,_gT_=0;
      if(! (_gU_ < 0))
       {var i=_gT_;
        for(;;)
         {var _gV_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _gV_ | 0;
          var _gW_=i + 1 | 0;
          if(_gU_ !== i){var i=_gW_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare$11=caml_string_compare,
     Vars=caml_call1(Stdlib_map[1],[0,compare$11]),
     compare$12=caml_string_compare,
     Meths=caml_call1(Stdlib_map[1],[0,compare$12]),
     compare$13=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$13]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _gN_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _gN_;
      var _gP_=len - 1 | 0,_gO_=0;
      if(! (_gP_ < 0))
       {var i=_gO_;
        for(;;)
         {var
           _gR_=(i * 2 | 0) + 3 | 0,
           _gQ_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_gR_)[1 + _gR_] = _gQ_;
          var _gS_=i + 1 | 0;
          if(_gP_ !== i){var i=_gS_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_gL_=old_size < new_size?1:0;
      if(_gL_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _gM_=0}
      else
       var _gM_=_gL_;
      return _gM_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _gJ_=caml_call2(Meths[27],name,table[3]);return _gJ_}
      catch(_gK_)
       {_gK_ = caml_wrap_exception(_gK_);
        if(_gK_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _gK_}}
    function get_method_labels(table,names)
     {return map$5(function(_gI_){return get_method_label(table,_gI_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _gG_=assoc(label,table[6]);return _gG_}
      catch(_gH_)
       {_gH_ = caml_wrap_exception(_gH_);
        if(_gH_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _gH_}}
    function to_list$3(arr){return 0 === arr?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$2
         (function(_gF_){return get_method_label(table,_gF_)},virt_meths$0),
       concr_meth_labs=
        map$2
         (function(_gE_){return get_method_label(table,_gE_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _gv_=Vars[1],_gw_=table[7];
      function _gx_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_gx_,_gw_,_gv_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _gA_=by_label[1];
          try
           {var _gC_=caml_call2(Labs[27],label,table[4]),_gB_=_gC_}
          catch(_gD_)
           {_gD_ = caml_wrap_exception(_gD_);
            if(_gD_ !== Not_found)throw _gD_;
            var _gB_=1}
          by_label[1] = caml_call3(Labs[4],label,_gB_,_gA_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _gy_=0,_gz_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _gz_,
        _gy_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _gu_=caml_call2(Vars[27],v,table[7]);
          return caml_call3(Vars[4],v,_gu_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _gt_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _gt_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _gr_=caml_call2(Vars[27],name,table[7]);return _gr_}
      catch(_gs_)
       {_gs_ = caml_wrap_exception(_gs_);
        if(_gs_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$92))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _gs_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _gj_=nmeths - 1 | 0,
       _gi_=0;
      if(! (_gj_ < 0))
       {var i$0=_gi_;
        for(;;)
         {var
           _gp_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _gp_;
          var _gq_=i$0 + 1 | 0;
          if(_gj_ !== i$0){var i$0=_gq_;continue}
          break}}
      var _gl_=nvals - 1 | 0,_gk_=0;
      if(! (_gl_ < 0))
       {var i=_gk_;
        for(;;)
         {var
           _gn_=i + nmeths | 0,
           _gm_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_gn_)[1 + _gn_] = _gm_;
          var _go_=i + 1 | 0;
          if(_gl_ !== i){var i=_go_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _gg_=caml_call2(Vars[27],name,table[7]);return _gg_}
      catch(_gh_)
       {_gh_ = caml_wrap_exception(_gh_);
        if(_gh_ === Not_found)throw [0,Assert_failure,_cp_];
        throw _gh_}}
    function get_variables(table,names)
     {return map$5(function(_gf_){return get_variable(table,_gf_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$5(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _ga_=0,
       _gb_=to_array(concr_meths),
       _gc_=
        [0,
         map$5
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_gb_),
         _ga_],
       _gd_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$5(function(_ge_){return get_variable(cla,_ge_)},_gd_),
                 _gc_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_f$_=0 !== inits?1:0;
      return _f$_?iter_f(obj,inits):_f$_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initiali(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_ct_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_f7_=0;
      if(! (n < 0))
       {var i=_f7_;
        for(;;)
         {var _f9_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_f9_,0];
          var _f__=i + 1 | 0;
          if(n !== i){var i=_f__;continue}
          break}}
      var _f8_=r[1];
      if(tables){tables[2] = _f8_;return res}
      throw [0,Assert_failure,_cq_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cv_]}
                if(tables$0)
                 {var _f6_=tables$0[3];
                  if(_f6_){var tables$0=_f6_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cr_]}
                throw [0,Assert_failure,_cu_]}
              throw [0,Assert_failure,_cs_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _f0_=i[1],
           label=caml_check_bound(methods,_f0_)[1 + _f0_],
           next=
            function(param)
             {i[1]++;
              var _f5_=i[1];
              return caml_check_bound(methods,_f5_)[1 + _f5_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _f3_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_f3_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _f2_=obj[1 + n];
                     return caml_call2(caml_get_public_method(_f2_,m,0),_f2_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _f1_=obj[1 + e][1 + n];
                     return caml_call2(caml_get_public_method(_f1_,m,0),_f1_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _f4_=caml_call1(obj[1][1 + n],obj);
                     return caml_call2(caml_get_public_method(_f4_,m,0),_f4_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(791,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(792,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(793,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _fY_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _fY_}
        catch(_fZ_)
         {_fZ_ = caml_wrap_exception(_fZ_);
          if(_fZ_ === Not_found)return [1,id];
          throw _fZ_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _fW_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _fW_}
        catch(_fX_)
         {_fX_ = caml_wrap_exception(_fX_);
          if(_fX_ === Not_found)
           throw [0,Error,symbol(cst_Illegal_character,s)];
          throw _fX_}}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fV_=match[1],switcher=_fV_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_fV_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fU_=match[1],switch$0=0;
          if(43 !== _fU_ && 45 !== _fU_)switch$0 = 1;
          if(! switch$0)
           {junk(strm);store(_fU_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _fR_=match[1];
            if(58 <= _fR_)
             {var switch$0=0;
              if(69 === _fR_ || 101 === _fR_)switch$0 = 1;
              if(switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _fR_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _fS_=match$0[1],_fT_=_fS_ - 69 | 0;
                    if(32 < _fT_ >>> 0)
                     {var switcher=_fT_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_fS_);continue}}
                    else
                     {var switcher$0=_fT_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _fR_){junk(s);store(_fR_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fP_=match[1],switch$0=0;
            if(94 <= _fP_)
             {var _fQ_=_fP_ - 95 | 0;
              if(30 < _fQ_ >>> 0)
               {if(! (32 <= _fQ_))switch$0 = 1}
              else
               if(29 === _fQ_)switch$0 = 1}
            else
             if(65 <= _fP_)
              {if(92 === _fP_)switch$0 = 1}
             else
              if(33 <= _fP_)
               switch(_fP_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:switch$0 = 1;break
                 }
            if(switch$0){junk(strm);store(_fP_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _fO_=match[1],switcher=_fO_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_fO_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fM_=match[1],switch$0=0;
            if(91 <= _fM_)
             {var _fN_=_fM_ - 95 | 0;
              if(27 < _fN_ >>> 0)
               {if(97 <= _fN_)switch$0 = 1}
              else
               if(1 !== _fN_)switch$0 = 1}
            else
             if(48 <= _fM_)
              {if(6 < (_fM_ - 58 | 0) >>> 0)switch$0 = 1}
             else
              if(39 === _fM_)switch$0 = 1;
            if(switch$0){junk(strm);store(_fM_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fC_=match[1],switch$0=0;
            if(124 <= _fC_)
             {if(127 <= _fC_)
               {if(192 <= _fC_)switch$0 = 1}
              else
               if(125 !== _fC_)switch$0 = 2}
            else
             {var _fD_=_fC_ - 65 | 0;
              if(57 < _fD_ >>> 0)
               {if(! (58 <= _fD_))
                 {var switcher=_fD_ + 65 | 0;
                  switch(switcher)
                   {case 34:
                     junk(strm);
                     reset_buffer(0);
                     for(;;)
                      {var match$1=peek$0(strm);
                       if(match$1)
                        {var _fF_=match$1[1];
                         if(34 === _fF_){junk(strm);return [0,[4,get_string(0)]]}
                         if(92 === _fF_)
                          {junk(strm);
                           try
                            {var c$0=escape(strm)}
                           catch(_fL_)
                            {_fL_ = caml_wrap_exception(_fL_);
                             if(_fL_ === Failure$0)throw [0,Error,cst$95];
                             throw _fL_;
                             var _fI_=_fL_}
                           store(c$0);
                           continue}
                         junk(strm);
                         store(_fF_);
                         continue}
                       throw Failure$0}
                    case 39:
                     junk(strm);
                     try
                      {var match$2=peek$0(strm);
                       if(! match$2)throw Failure$0;
                       var _fG_=match$2[1];
                       if(92 === _fG_)
                        {junk(strm);
                         try
                          {var _fH_=escape(strm)}
                         catch(_fK_)
                          {_fK_ = caml_wrap_exception(_fK_);
                           if(_fK_ === Failure$0)throw [0,Error,cst$96];
                           throw _fK_}
                         var c=_fH_}
                       else
                        {junk(strm);var c=_fG_}}
                     catch(_fJ_)
                      {_fJ_ = caml_wrap_exception(_fJ_);
                       if(_fJ_ === Failure$0)throw [0,Error,cst$93];
                       throw _fJ_}
                     var match$0=peek$0(strm);
                     if(match$0 && 39 === match$0[1])
                      {junk(strm);return [0,[5,c]]}
                     throw [0,Error,cst$94];
                    case 40:
                     junk(strm);
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return maybe_comment(counter$0,strm)}
                     return caml_trampoline_return(maybe_comment,[0,strm]);
                    case 45:junk(strm);return neg_number(strm);
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 26:
                    case 32:junk(strm);continue;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                     junk(strm);reset_buffer(0);store(_fC_);return number(strm);
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 42:
                    case 43:
                    case 47:
                    case 58:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:switch$0 = 2;break
                    }}}
              else
               {var _fE_=_fD_ - 26 | 0;
                if(5 < _fE_ >>> 0)
                 switch$0 = 1;
                else
                 switch(_fE_)
                  {case 4:switch$0 = 1;break;case 1:case 3:switch$0 = 2;break}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_fC_)];
              case 1:
               junk(strm);reset_buffer(0);store(_fC_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_fC_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match && 42 === match[1])
         {junk(strm);
          comment(strm);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return next_token$0(counter$0,strm)}
          return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _fz_=match[1];
          if(58 <= _fz_)
           {var switcher=_fz_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _fz_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _fA_=match$0[1],switcher$0=_fA_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _fB_=match$1[1],switcher$1=_fB_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_fz_ - 48 | 0) * 100 | 0)
                               +
                               ((_fA_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_fB_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$98]}}
             throw [0,Error,cst$97]}
          junk(strm);
          return _fz_}
        throw Failure$0}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _fy_=match$1[1];
                    if(41 === _fy_){junk(strm);return 0}
                    if(42 === _fy_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(794,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_fx_){return caml_call1(_b2_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
           {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _fv_=caml_obj_tag(prng),
            _fw_=250 === _fv_?prng[1]:246 === _fv_?force_lazy_block(prng):prng,
            seed=caml_call1(_b2_[4],_fw_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_ft_=len - 1 | 0,_fs_=0;
        if(! (_ft_ < 0))
         {var i=_fs_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _fu_=i + 1 | 0;
            if(_ft_ !== i){var i=_fu_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _fp_=init[4],_fq_=init[3],_fr_=copy$1(init[2]);
        return [0,init[1],_fr_,_fq_,_fp_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hkey=param$0[1],rest=param$0[3],c=param$0[2];
              if(caml_call1(H[7],c))
               {var rest$0=param$0[3],c$0=param$0[2];
                return [0,hkey,c$0,do_bucket(rest$0)]}
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_fm_=d.length - 1 - 1 | 0,_fl_=0;
        if(! (_fm_ < 0))
         {var i=_fl_;
          for(;;)
           {var _fn_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _fn_;
            var _fo_=i + 1 | 0;
            if(_fm_ !== i){var i=_fo_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _ff_=nsize < max_array_length?1:0,
         _fg_=_ff_?(osize >>> 1 | 0) <= h[1]?1:0:_ff_;
        if(_fg_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var nidx=key_index(h,hkey);
                ndata[1 + nidx]
                =
                [0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                return 0}
              return 0},
           _fi_=osize - 1 | 0,
           _fh_=0;
          if(! (_fi_ < 0))
           {var i=_fh_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _fk_=i + 1 | 0;
              if(_fi_ !== i){var i=_fk_;continue}
              break}}
          var _fj_=0}
        else
         var _fj_=_fg_;
        return _fj_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _fe_=h[2].length - 1 << 1 < h[1]?1:0;
        return _fe_?resize(h):_fe_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              var next$0=param$0[3],c$0=param$0[2];
              return [0,hk,c$0,remove_bucket(next$0)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _fd_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _fd_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fc_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fc_)[1 + _fc_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fb_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fb_)[1 + _fb_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],rest=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$1=param$0[3],param$0=param$1;
              continue}
            return 0}}
        var _fa_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_fa_)[1 + _fa_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(match){var param$0=next;continue}
                return caml_call3(H[6],c,key,info)}
              var param$1=param$0[3],param$0=param$1;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _e__=replace_bucket(l);return _e__}
        catch(_e$_)
         {_e$_ = caml_wrap_exception(_e$_);
          if(_e$_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _e9_=h[2].length - 1 << 1 < h[1]?1:0;
            return _e9_?resize(h):_e9_}
          throw _e$_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _e8_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_e8_)[1 + _e8_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(match){var param=rest;continue}
              return 1}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_e6_=d$0.length - 1 - 1 | 0,_e5_=0;
        if(! (_e6_ < 0))
         {var i=_e5_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1];caml_call2(f,k,d);switch$0 = 1}
                var param=rest;
                continue}
              var _e7_=i + 1 | 0;
              if(_e6_ !== i){var i=_e7_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_e2_=d$0.length - 1 - 1 | 0,_e1_=0;
        if(! (_e2_ < 0))
         {var i=_e1_;
          a:
          for(;;)
           {var
             _e3_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_e3_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1],accu$0=caml_call3(f,k,d,accu);
                  switch$0 = 1}
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _e4_=i + 1 | 0;
              if(_e2_ !== i){var i=_e4_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                if(match$1)
                 {var new_d=match$1[1];
                  caml_call3(H[6],c,k,new_d);
                  return [0,hk,c,do_bucket(rest)]}
                var param$0=rest;
                continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_eY_=d.length - 1 - 1 | 0,_eX_=0;
        if(! (_eY_ < 0))
         {var i=_eX_;
          for(;;)
           {var _eZ_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _eZ_;
            var _e0_=i + 1 | 0;
            if(_eY_ !== i){var i=_e0_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _eU_=h[2],
         _eV_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_eV_,_eU_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eW_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length(0,b);
            histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
            return 0},
          _eW_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$1=param$0[3],param$0=param$1;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _eR_=h[2],
         _eS_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_eS_,_eR_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _eT_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            histo[1 + l] = caml_check_bound(histo,l)[1 + l] + 1 | 0;
            return 0},
          _eT_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var data=match$0[1],key=match[1];
                return [0,
                        [0,key,data],
                        function(_eQ_){return aux(i$0,next,_eQ_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _eN_=0,_eO_=0;
        return function(_eP_){return aux(_eO_,_eN_,_eP_)}}
      function to_seq_keys(m)
       {var _eJ_=to_seq(m);
        function _eK_(_eM_){return _eM_[1]}
        return function(_eL_){return map(_eK_,_eJ_,_eL_)}}
      function to_seq_values(m)
       {var _eF_=to_seq(m);
        function _eG_(_eI_){return _eI_[2]}
        return function(_eH_){return map(_eG_,_eF_,_eH_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_r_[1],1)}
    function get_key$0(t){return caml_call2(_r_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_r_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_r_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_r_[6],t,0)}
    function check_key$0(t){return caml_call2(_r_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_r_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_r_[9],t)}
    function get_data_copy(t){return caml_call1(_r_[10],t)}
    function set_data(t,d){return caml_call2(_r_[11],t,d)}
    function unset_data(t){return caml_call1(_r_[12],t)}
    function check_data(t){return caml_call1(_r_[13],t)}
    function blit_data(t1,t2){return caml_call2(_r_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$2(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _eE_=include[1];
      function create(sz){return caml_call2(_eE_,_cw_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_r_[1],2)}
    function get_key1(t){return caml_call2(_r_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_r_[4],t,0)}
    function set_key1(t,k){return caml_call3(_r_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_r_[6],t,0)}
    function check_key1(t){return caml_call2(_r_[7],t,0)}
    function get_key2(t){return caml_call2(_r_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_r_[4],t,1)}
    function set_key2(t,k){return caml_call3(_r_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_r_[6],t,1)}
    function check_key2(t){return caml_call2(_r_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_r_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_r_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_r_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_r_[9],t)}
    function get_data_copy$0(t){return caml_call1(_r_[10],t)}
    function set_data$0(t,d){return caml_call2(_r_[11],t,d)}
    function unset_data$0(t){return caml_call1(_r_[12],t)}
    function check_data$0(t){return caml_call1(_r_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_r_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _eD_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _eD_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2$0=match$0[1],k1$0=match[1];
          if(caml_call2(H1[1],k1,k1$0) && caml_call2(H2[1],k2,k2$0))return 0;
          return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _eC_=check_key1(c);return _eC_?check_key2(c):_eC_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$3(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_eA_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_eA_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _eB_=include[1];
      function create(sz){return caml_call2(_eB_,_cx_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_r_[1],n)}
    function length$6(k){return caml_call1(_r_[2],k)}
    function get_key$1(t,n){return caml_call2(_r_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_r_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_r_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_r_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_r_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_r_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_r_[9],t)}
    function get_data_copy$1(t){return caml_call1(_r_[10],t)}
    function set_data$1(t,d){return caml_call2(_r_[11],t,d)}
    function unset_data$1(t){return caml_call1(_r_[12],t)}
    function check_data$1(t){return caml_call1(_r_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_r_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _ey_=k.length - 1 - 1 | 0,_ex_=0;
        if(! (_ey_ < 0))
         {var i=_ex_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _ez_=i + 1 | 0;
            if(_ey_ !== i){var i=_ez_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_et_=k.length - 1 - 1 | 0,_es_=0;
        if(! (_et_ < 0))
         {var i=_es_;
          for(;;)
           {var _eu_=h[1],_ev_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_ev_) * 65599 | 0) + _eu_ | 0;
            var _ew_=i + 1 | 0;
            if(_et_ !== i){var i=_ew_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_er_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_er_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _ep_=k.length - 1 - 1 | 0,_eo_=0;
        if(! (_ep_ < 0))
         {var i=_eo_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _eq_=i + 1 | 0;
            if(_ep_ !== i){var i=_eq_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _el_=i < 0?1:0;
          if(_el_)
           var _em_=_el_;
          else
           {var _en_=check_key$1(c,i);
            if(_en_){var i$0=i - 1 | 0,i=i$0;continue}
            var _em_=_en_}
          return _em_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$4(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _ek_=include[1];
      function create(sz){return caml_call2(_ek_,_cy_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$2,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$3,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$4,
        MakeSeeded$3],
       [0,
        function(_ej_)
         {return MakeSeeded$0
                  ([0,_ej_[3],_ej_[1],_ej_[2],_ej_[5],_ej_[4],_ej_[6],_ej_[7]])}]];
    caml_register_global(795,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$99))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$100))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _eh_=caml_ml_string_length(n) < 1?1:0,
       _ei_=_eh_ || (47 !== caml_string_get(n,0)?1:0);
      return _ei_}
    function is_implicit(n)
     {var _ec_=is_relative(n);
      if(_ec_)
       {var
         _ed_=caml_ml_string_length(n) < 2?1:0,
         _ee_=_ed_ || caml_string_notequal(sub$0(n,0,2),cst$102);
        if(_ee_)
         var
          _ef_=caml_ml_string_length(n) < 3?1:0,
          _eg_=_ef_ || caml_string_notequal(sub$0(n,0,3),cst$101);
        else
         var _eg_=_ee_}
      else
       var _eg_=_ec_;
      return _eg_}
    function check_suffix(name,suff)
     {var
       _ea_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _eb_=
        _ea_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_ea_;
      return _eb_}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cG_=caml_sys_getenv(cst_TMPDIR),_cz_=_cG_}
    catch(_d$_)
     {_d$_ = caml_wrap_exception(_d$_);
      if(_d$_ !== Not_found)throw _d$_;
      var _cz_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _d9_=l - 1 | 0,_d8_=0;
      if(! (_d9_ < 0))
       {var i=_d8_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _d__=i + 1 | 0;
          if(_d9_ !== i){var i=_d__;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function quote_command(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _d2_=caml_equal(stderr,stdout)?cst_2_1:symbol(cst_2,quote(f)),
        _d3_=_d2_;
      else
       var _d3_=cst$108;
      if(stdout)
       var f$0=stdout[1],_d4_=symbol(cst$103,quote(f$0));
      else
       var _d4_=cst$107;
      var _d5_=symbol(_d4_,_d3_);
      if(stdin)
       var f$1=stdin[1],_d6_=symbol(cst$104,quote(f$1));
      else
       var _d6_=cst$106;
      var _d7_=symbol(_d6_,_d5_);
      return symbol(concat$0(cst$105,map$2(quote,[0,cmd,args])),_d7_)}
    function basename(_d1_)
     {return generic_basename(is_dir_sep,current_dir_name,_d1_)}
    function dirname(_d0_)
     {return generic_dirname(is_dir_sep,current_dir_name,_d0_)}
    var
     Unix=
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       _cz_,
       quote,
       quote_command,
       basename,
       dirname];
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_dX_=47 === c?1:0;
      if(_dX_)
       var _dY_=_dX_;
      else
       var _dZ_=92 === c?1:0,_dY_=_dZ_ || (58 === c?1:0);
      return _dY_}
    function is_relative$0(n)
     {var
       _dR_=caml_ml_string_length(n) < 1?1:0,
       _dS_=_dR_ || (47 !== caml_string_get(n,0)?1:0);
      if(_dS_)
       {var
         _dT_=caml_ml_string_length(n) < 1?1:0,
         _dU_=_dT_ || (92 !== caml_string_get(n,0)?1:0);
        if(_dU_)
         var
          _dV_=caml_ml_string_length(n) < 2?1:0,
          _dW_=_dV_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _dW_=_dU_}
      else
       var _dW_=_dS_;
      return _dW_}
    function is_implicit$0(n)
     {var _dI_=is_relative$0(n);
      if(_dI_)
       {var
         _dJ_=caml_ml_string_length(n) < 2?1:0,
         _dK_=_dJ_ || caml_string_notequal(sub$0(n,0,2),cst$112);
        if(_dK_)
         {var
           _dL_=caml_ml_string_length(n) < 2?1:0,
           _dM_=_dL_ || caml_string_notequal(sub$0(n,0,2),cst$111);
          if(_dM_)
           {var
             _dN_=caml_ml_string_length(n) < 3?1:0,
             _dO_=_dN_ || caml_string_notequal(sub$0(n,0,3),cst$110);
            if(_dO_)
             var
              _dP_=caml_ml_string_length(n) < 3?1:0,
              _dQ_=_dP_ || caml_string_notequal(sub$0(n,0,3),cst$109);
            else
             var _dQ_=_dO_}
          else
           var _dQ_=_dM_}
        else
         var _dQ_=_dK_}
      else
       var _dQ_=_dI_;
      return _dQ_}
    function check_suffix$0(name,suff)
     {var _dF_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_dF_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _dG_=lowercase_ascii$1(suff),
        _dH_=caml_string_equal(lowercase_ascii$1(s),_dG_);
      else
       var _dH_=_dF_;
      return _dH_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _dE_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_dE_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cF_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cF_}
    catch(_dD_)
     {_dD_ = caml_wrap_exception(_dD_);
      if(_dD_ !== Not_found)throw _dD_;
      var temp_dir_name=cst$113}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _dB_=1;
        if(! (n < 1))
         {var j=_dB_;
          for(;;)
           {add_char(b,92);
            var _dC_=j + 1 | 0;
            if(n !== j){var j=_dC_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _dz_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_dz_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dz_,i$0])}
          if(92 === c)
           {var _dA_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_dA_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dA_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _dy_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_dy_)}
            return caml_trampoline_return(loop$0,[0,_dy_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function quote_cmd_filename(f)
     {if(! contains$0(f,34) && ! contains$0(f,37))
       return contains$0(f,32)?symbol(cst$115,symbol(f,cst$114)):f;
      return failwith(symbol(cst_Filename_quote_command_bad,f))}
    function quote_command$0(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _dp_=
         caml_equal(stderr,stdout)
          ?cst_2_1$0
          :symbol(cst_2$0,quote_cmd_filename(f)),
        _dq_=_dp_;
      else
       var _dq_=cst$124;
      var _dr_=[0,_dq_,_cA_];
      if(stdout)
       var f$0=stdout[1],_ds_=symbol(cst$116,quote_cmd_filename(f$0));
      else
       var _ds_=cst$123;
      var _dt_=[0,_ds_,_dr_];
      if(stdin)
       var f$1=stdin[1],_du_=symbol(cst$117,quote_cmd_filename(f$1));
      else
       var _du_=cst$122;
      var
       s=concat$0(cst$118,map$2(quote$0,args)),
       b=create$2(caml_ml_string_length(s) + 20 | 0),
       _dv_=[0,_du_,_dt_];
      iter$4
       (function(c)
         {var switch$0=0;
          if(62 <= c)
           {var _dx_=c - 63 | 0;
            if(60 < _dx_ >>> 0)
             {if(! (62 <= _dx_))switch$0 = 1}
            else
             if(31 === _dx_)switch$0 = 1}
          else
           if(42 <= c)
            {if(60 === c)switch$0 = 1}
           else
            if(33 <= c)
             switch(c - 33 | 0)
              {case 2:case 3:case 6:break;default:switch$0 = 1}
          return switch$0?(add_char(b,94),add_char(b,c)):add_char(b,c)},
        s);
      var _dw_=[0,cst$119,[0,contents(b),_dv_]];
      return concat$0(cst$121,[0,cst$120,[0,quote_cmd_filename(cmd),_dw_]])}
    function drive_and_path(s)
     {var _dl_=2 <= caml_ml_string_length(s)?1:0;
      if(_dl_)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < (param - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _dm_=switch$0?1:0,_dn_=_dm_?58 === caml_string_get(s,1)?1:0:_dm_}
      else
       var _dn_=_dl_;
      if(_dn_)
       {var _do_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_do_]}
      return [0,cst$125,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    var
     Win32=
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
    function basename$1(_dk_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_dk_)}
    function dirname$1(_dj_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_dj_)}
    var
     Cygwin=
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       _cz_,
       quote,
       quote_command,
       basename$1,
       dirname$1],
     Sysdeps=
      caml_string_notequal(os_type,cst_Cygwin)
       ?caml_string_notequal(os_type,cst_Win32)?Unix:Win32
       :Cygwin,
     null$3=Sysdeps[1],
     current_dir_name$2=Sysdeps[2],
     parent_dir_name$2=Sysdeps[3],
     dir_sep$2=Sysdeps[4],
     is_dir_sep$1=Sysdeps[5],
     is_relative$1=Sysdeps[6],
     is_implicit$1=Sysdeps[7],
     check_suffix$1=Sysdeps[8],
     chop_suffix_opt$1=Sysdeps[9],
     temp_dir_name$0=Sysdeps[10],
     quote$1=Sysdeps[11],
     quote_command$1=Sysdeps[12],
     basename$2=Sysdeps[13],
     dirname$2=Sysdeps[14];
    function concat$3(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1 && ! is_dir_sep$1(name,i$1))
         {if(46 === caml_string_get(name,i$1))
           {var i$2=i$1 - 1 | 0,i=i$2;
            for(;;)
             {if(0 <= i && ! is_dir_sep$1(name,i))
               {if(46 === caml_string_get(name,i))
                 {var i$0=i - 1 | 0,i=i$0;continue}
                return caml_ml_string_length(name) - i$1 | 0}
              return 0}}
          var i$3=i$1 - 1 | 0,i$1=i$3;
          continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$126:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_di_){return caml_call1(_b2_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _dg_=caml_obj_tag(prng$0),
       _dh_=
        250 === _dg_?prng$0[1]:246 === _dg_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b2_[4],_dh_) & 16777215;
      return concat$3(temp_dir,caml_call3(sprintf(_cB_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cC_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_de_,_dd_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cD_;
      if(_de_)var sth$0=_de_[1],perms=sth$0;else var perms=384;
      if(_dd_)
       var sth$1=_dd_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _df_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _df_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$3,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1,
       quote_command$1];
    caml_register_global(796,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0. && x[2] == 0.)return _cE_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _dc_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_dc_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(797,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       map$5,
       iteri$2,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(798,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$2,
       iteri,
       map$2,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(799,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$3,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$4,
       equal$4,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(800,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$4,
       iteri$1,
       map$4,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$5,
       equal$5,
       split_on_char,
       to_seq$3,
       to_seqi$0,
       of_seq$1];
    caml_register_global(801,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(802,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0];
    caml_register_global(803,Stdlib_stdLabels,"Stdlib__stdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$8(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_(time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$8,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_(time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snaps(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_(event_name)})}
    var
     Stdlib_spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snaps];
    caml_register_global(804,Stdlib_spacetime,"Stdlib__spacetime");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_c$_=n - 1 | 0,_c__=0;
      if(! (_c$_ < 0))
       {var i=_c__;
        for(;;)
         {var _da_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[1 + i] = _da_;
          var _db_=i + 1 | 0;
          if(_c$_ !== i){var i=_db_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _c9_=fold_left$1(caml_mul,1,dims(arr));
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c9_)}
    var Genarray=[0,dims,size_in_bytes];
    function create$9(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$1(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$0(arr)
     {var _c7_=[0];
      return function(_c8_){return runtime.caml_ba_set_generic(arr,_c7_,_c8_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$9(kind,layout);caml_call1(set$0(a),v);return a}
    function create$10(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _c6_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c6_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function of_array(kind,layout,data)
     {var
       ba=create$10(kind,layout,data.length - 1),
       ofs=layout?1:0,
       _c4_=data.length - 1 - 1 | 0,
       _c3_=0;
      if(! (_c4_ < 0))
       {var i=_c3_;
        for(;;)
         {runtime.caml_ba_set_1
           (ba,i + ofs | 0,caml_check_bound(data,i)[1 + i]);
          var _c5_=i + 1 | 0;
          if(_c4_ !== i){var i=_c5_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _c1_=caml_ba_dim_2(arr),_c2_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c2_),_c1_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2),
       ofs=layout?1:0,
       _cW_=dim1 - 1 | 0,
       _cV_=0;
      if(! (_cW_ < 0))
       {var i=_cV_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_n);
          var _cY_=dim2 - 1 | 0,_cX_=0;
          if(! (_cY_ < 0))
           {var j=_cX_;
            for(;;)
             {runtime.caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[1 + j]);
              var _c0_=j + 1 | 0;
              if(_cY_ !== j){var j=_c0_;continue}
              break}}
          var _cZ_=i + 1 | 0;
          if(_cW_ !== i){var i=_cZ_;continue}
          break}}
      return ba}
    function create$12(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _cS_=runtime.caml_ba_dim_3(arr),
       _cT_=caml_ba_dim_2(arr),
       _cU_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_cU_),_cT_),
               _cS_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$12(kind,layout,dim1,dim2,dim3),
       ofs=layout?1:0,
       _cK_=dim1 - 1 | 0,
       _cJ_=0;
      if(! (_cK_ < 0))
       {var i=_cJ_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_n);
          var _cM_=dim2 - 1 | 0,_cL_=0;
          if(! (_cM_ < 0))
           {var j=_cL_;
            for(;;)
             {var col=caml_check_bound(row,j)[1 + j];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_n$0);
              var _cP_=dim3 - 1 | 0,_cO_=0;
              if(! (_cP_ < 0))
               {var k=_cO_;
                for(;;)
                 {runtime.caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[1 + k]);
                  var _cR_=k + 1 | 0;
                  if(_cP_ !== k){var k=_cR_;continue}
                  break}}
              var _cQ_=j + 1 | 0;
              if(_cM_ !== j){var j=_cQ_;continue}
              break}}
          var _cN_=i + 1 | 0;
          if(_cK_ !== i){var i=_cN_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarra)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarra)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarra)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarra)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       Genarray,
       [0,create$9,caml_ba_change_layout,size_in_bytes$0,get$1,set$0,of_value],
       [0,create$10,caml_ba_change_layout,size_in_bytes$1,slice,of_array],
       [0,
        create$11,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$12,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(805,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 "../inventaire_linge/.inventaire_linge.objs/inventaire_linge.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     cst_Chambre_1=caml_string_of_jsbytes("Chambre 1"),
     cst_Chambre_2=caml_string_of_jsbytes("Chambre 2"),
     cst_Chambre_3=caml_string_of_jsbytes("Chambre 3"),
     cst_S_jour=caml_string_of_jsbytes("S\xc3\xa9jour"),
     cst_Salle_de_bains_1=caml_string_of_jsbytes("Salle de bains 1"),
     cst_Salle_de_bains_2=caml_string_of_jsbytes("Salle de bains 2"),
     cst_ch1=caml_string_of_jsbytes("ch1"),
     cst_ch2=caml_string_of_jsbytes("ch2"),
     cst_ch3=caml_string_of_jsbytes("ch3"),
     cst_sj=caml_string_of_jsbytes("sj"),
     cst_sdb1=caml_string_of_jsbytes("sdb1"),
     cst_sdb2=caml_string_of_jsbytes("sdb2"),
     tarif=caml_string_of_jsbytes("\xc3\x89t\xc3\xa9 2020"),
     destinataires=
      caml_string_of_jsbytes("dubuval@gmail.com,guy.grange@wanadoo.fr"),
     pieces=[0,0,[0,1,[0,2,[0,3,[0,4,[0,5,0]]]]]],
     fournitures=
      caml_list_of_js_array
       ([[0,
          caml_string_of_jsbytes("dh80"),
          caml_string_of_jsbytes("Drap housse 80 cm"),
          7,
          [0,[0,0,2],0]],
         [0,
          caml_string_of_jsbytes("dh90"),
          caml_string_of_jsbytes("Drap housse 90 cm"),
          7,
          [0,[0,2,4],0]],
         [0,
          caml_string_of_jsbytes("dh140"),
          caml_string_of_jsbytes("Drap housse 140 cm"),
          15,
          [0,[0,1,1],[0,[0,3,1],0]]],
         [0,
          caml_string_of_jsbytes("dhbb"),
          caml_string_of_jsbytes("Drap housse b\xc3\xa9b\xc3\xa9"),
          3,
          [0,[0,0,1],0]],
         [0,
          caml_string_of_jsbytes("hc1p"),
          caml_string_of_jsbytes("Housse de couette 1 place"),
          10,
          [0,[0,0,2],[0,[0,2,4],0]]],
         [0,
          caml_string_of_jsbytes("hc2p"),
          caml_string_of_jsbytes("Housse de couette 2 places"),
          16,
          [0,[0,1,1],[0,[0,3,1],0]]],
         [0,
          caml_string_of_jsbytes("hcbb"),
          caml_string_of_jsbytes("Housse de couette b\xc3\xa9b\xc3\xa9"),
          4,
          [0,[0,0,1],0]],
         [0,
          caml_string_of_jsbytes("litbb"),
          caml_string_of_jsbytes("Lit b\xc3\xa9b\xc3\xa9"),
          10,
          [0,[0,0,1],0]],
         [0,
          caml_string_of_jsbytes("pm80"),
          caml_string_of_jsbytes("Prot\xc3\xa8ge matelas 80 cm"),
          0,
          [0,[0,0,2],0]],
         [0,
          caml_string_of_jsbytes("pm90"),
          caml_string_of_jsbytes("Prot\xc3\xa8ge matelas 90 cm"),
          0,
          [0,[0,2,4],0]],
         [0,
          caml_string_of_jsbytes("pm140"),
          caml_string_of_jsbytes("Prot\xc3\xa8ge matelas 140 cm"),
          0,
          [0,[0,1,1],[0,[0,3,1],0]]],
         [0,
          caml_string_of_jsbytes("pmbb"),
          caml_string_of_jsbytes("Prot\xc3\xa8ge matelas b\xc3\xa9b\xc3\xa9"),
          0,
          [0,[0,0,1],0]],
         [0,
          caml_string_of_jsbytes("taie"),
          caml_string_of_jsbytes("Taie d\xe2\x80\x99oreiller"),
          3,
          [0,[0,0,4],[0,[0,1,4],[0,[0,2,8],[0,[0,3,4],0]]]]],
         [0,
          caml_string_of_jsbytes("douche"),
          caml_string_of_jsbytes("Drap de douche"),
          4,
          [0,[0,4,3],[0,[0,5,3],0]]],
         [0,
          caml_string_of_jsbytes("gant"),
          caml_string_of_jsbytes("Gant de toilette"),
          1,
          [0,[0,4,4],[0,[0,5,6],0]]],
         [0,
          caml_string_of_jsbytes("serv"),
          caml_string_of_jsbytes("Serviette de toilette"),
          3,
          [0,[0,4,4],[0,[0,5,6],0]]],
         [0,
          caml_string_of_jsbytes("inv"),
          caml_string_of_jsbytes("Serviette invit\xc3\xa9s"),
          3,
          [0,[0,4,1],[0,[0,5,1],0]]],
         [0,
          caml_string_of_jsbytes("tapis"),
          caml_string_of_jsbytes("Tapis de douche"),
          3,
          [0,[0,4,2],[0,[0,5,2],0]]],
         [0,
          caml_string_of_jsbytes("mains"),
          caml_string_of_jsbytes("Essuie-mains"),
          2,
          [0,[0,3,2],0]],
         [0,
          caml_string_of_jsbytes("table"),
          caml_string_of_jsbytes("Serviettes de table"),
          2,
          [0,[0,3,10],0]],
         [0,
          caml_string_of_jsbytes("torchon"),
          caml_string_of_jsbytes("Torchons \xc3\xa0 vaisselle"),
          2,
          [0,[0,3,2],0]],
         [0,
          caml_string_of_jsbytes("microfibre"),
          caml_string_of_jsbytes("Torchons microfibre"),
          0,
          [0,[0,4,2],[0,[0,5,2],[0,[0,3,2],0]]]]]);
    function short_string_of_piece(param)
     {switch(param)
       {case 0:return cst_ch1;
        case 1:return cst_ch2;
        case 2:return cst_ch3;
        case 3:return cst_sj;
        case 4:return cst_sdb1;
        default:return cst_sdb2}}
    function long_string_of_piece(param)
     {switch(param)
       {case 0:return cst_Chambre_1;
        case 1:return cst_Chambre_2;
        case 2:return cst_Chambre_3;
        case 3:return cst_S_jour;
        case 4:return cst_Salle_de_bains_1;
        default:return cst_Salle_de_bains_2}}
    var
     Inventaire_linge=
      [0,
       tarif,
       destinataires,
       pieces,
       short_string_of_piece,
       long_string_of_piece,
       fournitures];
    runtime.caml_register_global(16,Inventaire_linge,"Inventaire_linge");
    return}
  (function(){return this}()));


//# 1 "../.js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_string_of_jsbytes("parseFloat"),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_string_of_jsbytes("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     cst_can_t_retrieve_file_name_n=
      caml_string_of_jsbytes("can't retrieve file name: not implemented"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_loadstart=caml_string_of_jsbytes("loadstart"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_abort=caml_string_of_jsbytes("abort"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_load=caml_string_of_jsbytes("load"),
     cst_loadend=caml_string_of_jsbytes("loadend"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_area$1=caml_string_of_jsbytes("area"),
     cst_audio$1=caml_string_of_jsbytes("audio"),
     cst_base$1=caml_string_of_jsbytes("base"),
     cst_blockquote$1=caml_string_of_jsbytes("blockquote"),
     cst_body$1=caml_string_of_jsbytes("body"),
     cst_br$1=caml_string_of_jsbytes("br"),
     cst_button$1=caml_string_of_jsbytes("button"),
     cst_canvas$1=caml_string_of_jsbytes("canvas"),
     cst_caption$1=caml_string_of_jsbytes("caption"),
     cst_col$1=caml_string_of_jsbytes("col"),
     cst_colgroup$1=caml_string_of_jsbytes("colgroup"),
     cst_del$1=caml_string_of_jsbytes("del"),
     cst_div$1=caml_string_of_jsbytes("div"),
     cst_dl$1=caml_string_of_jsbytes("dl"),
     cst_embed$1=caml_string_of_jsbytes("embed"),
     cst_fieldset$1=caml_string_of_jsbytes("fieldset"),
     cst_form$1=caml_string_of_jsbytes("form"),
     cst_frame$1=caml_string_of_jsbytes("frame"),
     cst_frameset$1=caml_string_of_jsbytes("frameset"),
     cst_h1$1=caml_string_of_jsbytes("h1"),
     cst_h2$1=caml_string_of_jsbytes("h2"),
     cst_h3$1=caml_string_of_jsbytes("h3"),
     cst_h4$1=caml_string_of_jsbytes("h4"),
     cst_h5$1=caml_string_of_jsbytes("h5"),
     cst_h6$1=caml_string_of_jsbytes("h6"),
     cst_head$1=caml_string_of_jsbytes("head"),
     cst_hr$1=caml_string_of_jsbytes("hr"),
     cst_html$1=caml_string_of_jsbytes("html"),
     cst_iframe$1=caml_string_of_jsbytes("iframe"),
     cst_img$1=caml_string_of_jsbytes("img"),
     cst_input$2=caml_string_of_jsbytes("input"),
     cst_ins$1=caml_string_of_jsbytes("ins"),
     cst_label$1=caml_string_of_jsbytes("label"),
     cst_legend$1=caml_string_of_jsbytes("legend"),
     cst_li$1=caml_string_of_jsbytes("li"),
     cst_link$1=caml_string_of_jsbytes("link"),
     cst_map$1=caml_string_of_jsbytes("map"),
     cst_meta$1=caml_string_of_jsbytes("meta"),
     cst_object$1=caml_string_of_jsbytes("object"),
     cst_ol$1=caml_string_of_jsbytes("ol"),
     cst_optgroup$1=caml_string_of_jsbytes("optgroup"),
     cst_option$1=caml_string_of_jsbytes("option"),
     cst_p$1=caml_string_of_jsbytes("p"),
     cst_param$1=caml_string_of_jsbytes("param"),
     cst_pre$1=caml_string_of_jsbytes("pre"),
     cst_q$1=caml_string_of_jsbytes("q"),
     cst_script$1=caml_string_of_jsbytes("script"),
     cst_select$2=caml_string_of_jsbytes("select"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_table$1=caml_string_of_jsbytes("table"),
     cst_tbody$1=caml_string_of_jsbytes("tbody"),
     cst_td$1=caml_string_of_jsbytes("td"),
     cst_textarea$1=caml_string_of_jsbytes("textarea"),
     cst_tfoot$1=caml_string_of_jsbytes("tfoot"),
     cst_th$1=caml_string_of_jsbytes("th"),
     cst_thead$1=caml_string_of_jsbytes("thead"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_tr$1=caml_string_of_jsbytes("tr"),
     cst_ul$1=caml_string_of_jsbytes("ul"),
     cst_video$1=caml_string_of_jsbytes("video"),
     cst_KeyH=caml_string_of_jsbytes("KeyH"),
     cst_Digit6=caml_string_of_jsbytes("Digit6"),
     cst_BrowserRefresh=caml_string_of_jsbytes("BrowserRefresh"),
     cst_Backslash=caml_string_of_jsbytes("Backslash"),
     cst_AltLeft=caml_string_of_jsbytes("AltLeft"),
     cst_AltRight=caml_string_of_jsbytes("AltRight"),
     cst_ArrowDown=caml_string_of_jsbytes("ArrowDown"),
     cst_ArrowLeft=caml_string_of_jsbytes("ArrowLeft"),
     cst_ArrowRight=caml_string_of_jsbytes("ArrowRight"),
     cst_ArrowUp=caml_string_of_jsbytes("ArrowUp"),
     cst_Backquote=caml_string_of_jsbytes("Backquote"),
     cst_Backspace=caml_string_of_jsbytes("Backspace"),
     cst_BracketLeft=caml_string_of_jsbytes("BracketLeft"),
     cst_BracketRight=caml_string_of_jsbytes("BracketRight"),
     cst_BrowserBack=caml_string_of_jsbytes("BrowserBack"),
     cst_BrowserFavorites=caml_string_of_jsbytes("BrowserFavorites"),
     cst_BrowserForward=caml_string_of_jsbytes("BrowserForward"),
     cst_BrowserHome=caml_string_of_jsbytes("BrowserHome"),
     cst_Delete=caml_string_of_jsbytes("Delete"),
     cst_BrowserSearch=caml_string_of_jsbytes("BrowserSearch"),
     cst_BrowserStop=caml_string_of_jsbytes("BrowserStop"),
     cst_CapsLock=caml_string_of_jsbytes("CapsLock"),
     cst_Comma=caml_string_of_jsbytes("Comma"),
     cst_ContextMenu=caml_string_of_jsbytes("ContextMenu"),
     cst_ControlLeft=caml_string_of_jsbytes("ControlLeft"),
     cst_ControlRight=caml_string_of_jsbytes("ControlRight"),
     cst_Digit0=caml_string_of_jsbytes("Digit0"),
     cst_Digit1=caml_string_of_jsbytes("Digit1"),
     cst_Digit2=caml_string_of_jsbytes("Digit2"),
     cst_Digit3=caml_string_of_jsbytes("Digit3"),
     cst_Digit4=caml_string_of_jsbytes("Digit4"),
     cst_Digit5=caml_string_of_jsbytes("Digit5"),
     cst_F6=caml_string_of_jsbytes("F6"),
     cst_F1=caml_string_of_jsbytes("F1"),
     cst_Digit7=caml_string_of_jsbytes("Digit7"),
     cst_Digit8=caml_string_of_jsbytes("Digit8"),
     cst_Digit9=caml_string_of_jsbytes("Digit9"),
     cst_End=caml_string_of_jsbytes("End"),
     cst_Enter=caml_string_of_jsbytes("Enter"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Escape=caml_string_of_jsbytes("Escape"),
     cst_F10=caml_string_of_jsbytes("F10"),
     cst_F11=caml_string_of_jsbytes("F11"),
     cst_F12=caml_string_of_jsbytes("F12"),
     cst_F2=caml_string_of_jsbytes("F2"),
     cst_F3=caml_string_of_jsbytes("F3"),
     cst_F4=caml_string_of_jsbytes("F4"),
     cst_F5=caml_string_of_jsbytes("F5"),
     cst_KeyA=caml_string_of_jsbytes("KeyA"),
     cst_F7=caml_string_of_jsbytes("F7"),
     cst_F8=caml_string_of_jsbytes("F8"),
     cst_F9=caml_string_of_jsbytes("F9"),
     cst_Home=caml_string_of_jsbytes("Home"),
     cst_Insert=caml_string_of_jsbytes("Insert"),
     cst_IntlBackslash=caml_string_of_jsbytes("IntlBackslash"),
     cst_IntlYen=caml_string_of_jsbytes("IntlYen"),
     cst_KeyB=caml_string_of_jsbytes("KeyB"),
     cst_KeyC=caml_string_of_jsbytes("KeyC"),
     cst_KeyD=caml_string_of_jsbytes("KeyD"),
     cst_KeyE=caml_string_of_jsbytes("KeyE"),
     cst_KeyF=caml_string_of_jsbytes("KeyF"),
     cst_KeyG=caml_string_of_jsbytes("KeyG"),
     cst_Numpad4=caml_string_of_jsbytes("Numpad4"),
     cst_KeyX=caml_string_of_jsbytes("KeyX"),
     cst_KeyP=caml_string_of_jsbytes("KeyP"),
     cst_KeyI=caml_string_of_jsbytes("KeyI"),
     cst_KeyJ=caml_string_of_jsbytes("KeyJ"),
     cst_KeyK=caml_string_of_jsbytes("KeyK"),
     cst_KeyL=caml_string_of_jsbytes("KeyL"),
     cst_KeyM=caml_string_of_jsbytes("KeyM"),
     cst_KeyN=caml_string_of_jsbytes("KeyN"),
     cst_KeyO=caml_string_of_jsbytes("KeyO"),
     cst_KeyQ=caml_string_of_jsbytes("KeyQ"),
     cst_KeyR=caml_string_of_jsbytes("KeyR"),
     cst_KeyS=caml_string_of_jsbytes("KeyS"),
     cst_KeyT=caml_string_of_jsbytes("KeyT"),
     cst_KeyU=caml_string_of_jsbytes("KeyU"),
     cst_KeyV=caml_string_of_jsbytes("KeyV"),
     cst_KeyW=caml_string_of_jsbytes("KeyW"),
     cst_MetaRight=caml_string_of_jsbytes("MetaRight"),
     cst_KeyY=caml_string_of_jsbytes("KeyY"),
     cst_KeyZ=caml_string_of_jsbytes("KeyZ"),
     cst_MediaPlayPause=caml_string_of_jsbytes("MediaPlayPause"),
     cst_MediaStop=caml_string_of_jsbytes("MediaStop"),
     cst_MediaTrackNext=caml_string_of_jsbytes("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_string_of_jsbytes("MediaTrackPrevious"),
     cst_MetaLeft=caml_string_of_jsbytes("MetaLeft"),
     cst_Minus=caml_string_of_jsbytes("Minus"),
     cst_NumLock=caml_string_of_jsbytes("NumLock"),
     cst_Numpad0=caml_string_of_jsbytes("Numpad0"),
     cst_Numpad1=caml_string_of_jsbytes("Numpad1"),
     cst_Numpad2=caml_string_of_jsbytes("Numpad2"),
     cst_Numpad3=caml_string_of_jsbytes("Numpad3"),
     cst_PageUp=caml_string_of_jsbytes("PageUp"),
     cst_NumpadDivide=caml_string_of_jsbytes("NumpadDivide"),
     cst_Numpad5=caml_string_of_jsbytes("Numpad5"),
     cst_Numpad6=caml_string_of_jsbytes("Numpad6"),
     cst_Numpad7=caml_string_of_jsbytes("Numpad7"),
     cst_Numpad8=caml_string_of_jsbytes("Numpad8"),
     cst_Numpad9=caml_string_of_jsbytes("Numpad9"),
     cst_NumpadAdd=caml_string_of_jsbytes("NumpadAdd"),
     cst_NumpadDecimal=caml_string_of_jsbytes("NumpadDecimal"),
     cst_NumpadEnter=caml_string_of_jsbytes("NumpadEnter"),
     cst_NumpadEqual=caml_string_of_jsbytes("NumpadEqual"),
     cst_NumpadMultiply=caml_string_of_jsbytes("NumpadMultiply"),
     cst_NumpadSubtract=caml_string_of_jsbytes("NumpadSubtract"),
     cst_OSLeft=caml_string_of_jsbytes("OSLeft"),
     cst_OSRight=caml_string_of_jsbytes("OSRight"),
     cst_PageDown=caml_string_of_jsbytes("PageDown"),
     cst_ShiftRight=caml_string_of_jsbytes("ShiftRight"),
     cst_Pause=caml_string_of_jsbytes("Pause"),
     cst_Period=caml_string_of_jsbytes("Period"),
     cst_PrintScreen=caml_string_of_jsbytes("PrintScreen"),
     cst_Quote=caml_string_of_jsbytes("Quote"),
     cst_ScrollLock=caml_string_of_jsbytes("ScrollLock"),
     cst_Semicolon=caml_string_of_jsbytes("Semicolon"),
     cst_ShiftLeft=caml_string_of_jsbytes("ShiftLeft"),
     cst_Slash=caml_string_of_jsbytes("Slash"),
     cst_Space=caml_string_of_jsbytes("Space"),
     cst_Tab=caml_string_of_jsbytes("Tab"),
     cst_VolumeDown=caml_string_of_jsbytes("VolumeDown"),
     cst_VolumeMute=caml_string_of_jsbytes("VolumeMute"),
     cst_VolumeUp=caml_string_of_jsbytes("VolumeUp"),
     cst_mouseout$0=caml_string_of_jsbytes("mouseout"),
     cst_mouseover$0=caml_string_of_jsbytes("mouseover"),
     cst_video$0=caml_string_of_jsbytes("video"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_ul$0=caml_string_of_jsbytes("ul"),
     cst_tr$0=caml_string_of_jsbytes("tr"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_thead$0=caml_string_of_jsbytes("thead"),
     cst_th$0=caml_string_of_jsbytes("th"),
     cst_tfoot$0=caml_string_of_jsbytes("tfoot"),
     cst_textarea$0=caml_string_of_jsbytes("textarea"),
     cst_td$0=caml_string_of_jsbytes("td"),
     cst_tbody$0=caml_string_of_jsbytes("tbody"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_select$1=caml_string_of_jsbytes("select"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_q$0=caml_string_of_jsbytes("q"),
     cst_pre$0=caml_string_of_jsbytes("pre"),
     cst_param$0=caml_string_of_jsbytes("param"),
     cst_p$0=caml_string_of_jsbytes("p"),
     cst_option$0=caml_string_of_jsbytes("option"),
     cst_optgroup$0=caml_string_of_jsbytes("optgroup"),
     cst_ol$0=caml_string_of_jsbytes("ol"),
     cst_object$0=caml_string_of_jsbytes("object"),
     cst_meta$0=caml_string_of_jsbytes("meta"),
     cst_map$0=caml_string_of_jsbytes("map"),
     cst_link$0=caml_string_of_jsbytes("link"),
     cst_li$0=caml_string_of_jsbytes("li"),
     cst_legend$0=caml_string_of_jsbytes("legend"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_ins$0=caml_string_of_jsbytes("ins"),
     cst_input$1=caml_string_of_jsbytes("input"),
     cst_img$0=caml_string_of_jsbytes("img"),
     cst_iframe$0=caml_string_of_jsbytes("iframe"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_hr$0=caml_string_of_jsbytes("hr"),
     cst_head$0=caml_string_of_jsbytes("head"),
     cst_h6$0=caml_string_of_jsbytes("h6"),
     cst_h5$0=caml_string_of_jsbytes("h5"),
     cst_h4$0=caml_string_of_jsbytes("h4"),
     cst_h3$0=caml_string_of_jsbytes("h3"),
     cst_h2$0=caml_string_of_jsbytes("h2"),
     cst_h1$0=caml_string_of_jsbytes("h1"),
     cst_frame$0=caml_string_of_jsbytes("frame"),
     cst_frameset$0=caml_string_of_jsbytes("frameset"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_embed$0=caml_string_of_jsbytes("embed"),
     cst_fieldset$0=caml_string_of_jsbytes("fieldset"),
     cst_dl$0=caml_string_of_jsbytes("dl"),
     cst_div$0=caml_string_of_jsbytes("div"),
     cst_del$0=caml_string_of_jsbytes("del"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_caption$0=caml_string_of_jsbytes("caption"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_br$0=caml_string_of_jsbytes("br"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_blockquote$0=caml_string_of_jsbytes("blockquote"),
     cst_base$0=caml_string_of_jsbytes("base"),
     cst_area$0=caml_string_of_jsbytes("area"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_frame=caml_string_of_jsbytes("frame"),
     cst_frameset=caml_string_of_jsbytes("frameset"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_big=caml_string_of_jsbytes("big"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_tt=caml_string_of_jsbytes("tt"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_input$0=caml_string_of_jsbytes("input"),
     cst_select$0=caml_string_of_jsbytes("select"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_base=caml_string_of_jsbytes("base"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_html=caml_string_of_jsbytes("html"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_dblclick=caml_string_of_jsbytes("dblclick"),
     cst_mousedown=caml_string_of_jsbytes("mousedown"),
     cst_mouseup=caml_string_of_jsbytes("mouseup"),
     cst_mouseover=caml_string_of_jsbytes("mouseover"),
     cst_mousemove=caml_string_of_jsbytes("mousemove"),
     cst_mouseout=caml_string_of_jsbytes("mouseout"),
     cst_keypress=caml_string_of_jsbytes("keypress"),
     cst_keydown=caml_string_of_jsbytes("keydown"),
     cst_keyup=caml_string_of_jsbytes("keyup"),
     cst_mousewheel=caml_string_of_jsbytes("mousewheel"),
     cst_DOMMouseScroll=caml_string_of_jsbytes("DOMMouseScroll"),
     cst_touchstart=caml_string_of_jsbytes("touchstart"),
     cst_touchmove=caml_string_of_jsbytes("touchmove"),
     cst_touchend=caml_string_of_jsbytes("touchend"),
     cst_touchcancel=caml_string_of_jsbytes("touchcancel"),
     cst_dragstart=caml_string_of_jsbytes("dragstart"),
     cst_dragend=caml_string_of_jsbytes("dragend"),
     cst_dragenter=caml_string_of_jsbytes("dragenter"),
     cst_dragover=caml_string_of_jsbytes("dragover"),
     cst_dragleave=caml_string_of_jsbytes("dragleave"),
     cst_drag=caml_string_of_jsbytes("drag"),
     cst_drop=caml_string_of_jsbytes("drop"),
     cst_hashchange=caml_string_of_jsbytes("hashchange"),
     cst_change=caml_string_of_jsbytes("change"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_timeupdate=caml_string_of_jsbytes("timeupdate"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_scroll=caml_string_of_jsbytes("scroll"),
     cst_focus=caml_string_of_jsbytes("focus"),
     cst_blur=caml_string_of_jsbytes("blur"),
     cst_load$0=caml_string_of_jsbytes("load"),
     cst_unload=caml_string_of_jsbytes("unload"),
     cst_beforeunload=caml_string_of_jsbytes("beforeunload"),
     cst_resize=caml_string_of_jsbytes("resize"),
     cst_orientationchange=caml_string_of_jsbytes("orientationchange"),
     cst_popstate=caml_string_of_jsbytes("popstate"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_abort$0=caml_string_of_jsbytes("abort"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_online=caml_string_of_jsbytes("online"),
     cst_offline=caml_string_of_jsbytes("offline"),
     cst_checking=caml_string_of_jsbytes("checking"),
     cst_noupdate=caml_string_of_jsbytes("noupdate"),
     cst_downloading=caml_string_of_jsbytes("downloading"),
     cst_progress$0=caml_string_of_jsbytes("progress"),
     cst_updateready=caml_string_of_jsbytes("updateready"),
     cst_cached=caml_string_of_jsbytes("cached"),
     cst_obsolete=caml_string_of_jsbytes("obsolete"),
     cst_DOMContentLoaded=caml_string_of_jsbytes("DOMContentLoaded"),
     cst_animationstart=caml_string_of_jsbytes("animationstart"),
     cst_animationend=caml_string_of_jsbytes("animationend"),
     cst_animationiteration=caml_string_of_jsbytes("animationiteration"),
     cst_animationcancel=caml_string_of_jsbytes("animationcancel"),
     cst_canplay=caml_string_of_jsbytes("canplay"),
     cst_canplaythrough=caml_string_of_jsbytes("canplaythrough"),
     cst_durationchange=caml_string_of_jsbytes("durationchange"),
     cst_emptied=caml_string_of_jsbytes("emptied"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_gotpointercapture=caml_string_of_jsbytes("gotpointercapture"),
     cst_loadeddata=caml_string_of_jsbytes("loadeddata"),
     cst_loadedmetadata=caml_string_of_jsbytes("loadedmetadata"),
     cst_loadstart$0=caml_string_of_jsbytes("loadstart"),
     cst_lostpointercapture=caml_string_of_jsbytes("lostpointercapture"),
     cst_pause=caml_string_of_jsbytes("pause"),
     cst_play=caml_string_of_jsbytes("play"),
     cst_playing=caml_string_of_jsbytes("playing"),
     cst_pointerenter=caml_string_of_jsbytes("pointerenter"),
     cst_pointercancel=caml_string_of_jsbytes("pointercancel"),
     cst_pointerdown=caml_string_of_jsbytes("pointerdown"),
     cst_pointerleave=caml_string_of_jsbytes("pointerleave"),
     cst_pointermove=caml_string_of_jsbytes("pointermove"),
     cst_pointerout=caml_string_of_jsbytes("pointerout"),
     cst_pointerover=caml_string_of_jsbytes("pointerover"),
     cst_pointerup=caml_string_of_jsbytes("pointerup"),
     cst_ratechange=caml_string_of_jsbytes("ratechange"),
     cst_seeked=caml_string_of_jsbytes("seeked"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_stalled=caml_string_of_jsbytes("stalled"),
     cst_suspend=caml_string_of_jsbytes("suspend"),
     cst_volumechange=caml_string_of_jsbytes("volumechange"),
     cst_waiting=caml_string_of_jsbytes("waiting"),
     cst_Js_of_ocaml_Dom_html_Canva=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_submit$0=caml_string_of_jsbytes("submit"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_readystatechange=caml_string_of_jsbytes("readystatechange"),
     cst_loadstart$1=caml_string_of_jsbytes("loadstart"),
     cst_progress$1=caml_string_of_jsbytes("progress"),
     cst_abort$1=caml_string_of_jsbytes("abort"),
     cst_error$1=caml_string_of_jsbytes("error"),
     cst_load$1=caml_string_of_jsbytes("load"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_loadend$0=caml_string_of_jsbytes("loadend"),
     cst_Worker_onmessage_is_undefi$0=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefi=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_u=
      caml_string_of_jsbytes("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_string_of_jsbytes("webglcontextlost"),
     cst_webglcontextrestored=caml_string_of_jsbytes("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_string_of_jsbytes("webglcontextcreationerror"),
     cst_g=caml_string_of_jsbytes("g"),
     cst=caml_string_of_jsbytes("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_string_of_jsbytes(""),
     cst$13=caml_string_of_jsbytes(""),
     cst$21=caml_string_of_jsbytes(""),
     cst$14=caml_string_of_jsbytes("#"),
     cst$15=caml_string_of_jsbytes("?"),
     cst$20=caml_string_of_jsbytes(""),
     cst$16=caml_string_of_jsbytes("/"),
     cst$17=caml_string_of_jsbytes("/"),
     cst$19=caml_string_of_jsbytes(":"),
     cst$18=caml_string_of_jsbytes(""),
     cst_http$1=caml_string_of_jsbytes("http://"),
     cst$22=caml_string_of_jsbytes(""),
     cst$30=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes("#"),
     cst$24=caml_string_of_jsbytes("?"),
     cst$29=caml_string_of_jsbytes(""),
     cst$25=caml_string_of_jsbytes("/"),
     cst$26=caml_string_of_jsbytes("/"),
     cst$28=caml_string_of_jsbytes(":"),
     cst$27=caml_string_of_jsbytes(""),
     cst_https$1=caml_string_of_jsbytes("https://"),
     cst$31=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst$32=caml_string_of_jsbytes("#"),
     cst$33=caml_string_of_jsbytes("?"),
     cst$35=caml_string_of_jsbytes(""),
     cst$34=caml_string_of_jsbytes("/"),
     cst_file$2=caml_string_of_jsbytes("file://"),
     cst$12=caml_string_of_jsbytes(""),
     cst$11=caml_string_of_jsbytes(""),
     cst$10=caml_string_of_jsbytes(""),
     cst$9=caml_string_of_jsbytes(""),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes(""),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("="),
     cst$5=caml_string_of_jsbytes("&"),
     cst$2=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_file$0=caml_string_of_jsbytes("file"),
     cst_file$1=caml_string_of_jsbytes("file:"),
     cst_http=caml_string_of_jsbytes("http"),
     cst_http$0=caml_string_of_jsbytes("http:"),
     cst_https=caml_string_of_jsbytes("https"),
     cst_https$0=caml_string_of_jsbytes("https:"),
     cst$1=caml_string_of_jsbytes(" "),
     cst_2B=caml_string_of_jsbytes("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_string_of_jsbytes("+"),
     cst_Js_of_ocaml_Url_Not_an_htt=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0=
      caml_string_of_jsbytes
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_string_of_jsbytes
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_string_of_jsbytes("3.6.0"),
     git_version=caml_string_of_jsbytes(""),
     cst$38=caml_string_of_jsbytes(""),
     cst$41=caml_string_of_jsbytes("+"),
     cst_Jstable_keys=caml_string_of_jsbytes("Jstable.keys"),
     dummy_string=caml_string_of_jsbytes(""),
     dummy_int64=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_is_not_a_valid_length$0=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_string_of_jsbytes("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_string_of_jsbytes("length conversion error: "),
     cst_deg$0=caml_string_of_jsbytes("deg"),
     cst_grad$0=caml_string_of_jsbytes("grad"),
     cst_rad$0=caml_string_of_jsbytes("rad"),
     cst_turns$0=caml_string_of_jsbytes("turns"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst_turns=caml_string_of_jsbytes("turns"),
     cst_is_not_a_valid_length=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_d_d_s_S=caml_string_of_jsbytes("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=
      caml_string_of_jsbytes("length conversion error: "),
     cst_pc$0=caml_string_of_jsbytes("pc"),
     cst_ch$0=caml_string_of_jsbytes("ch"),
     cst_cm$0=caml_string_of_jsbytes("cm"),
     cst_em$1=caml_string_of_jsbytes("em"),
     cst_ex$0=caml_string_of_jsbytes("ex"),
     cst_gd$0=caml_string_of_jsbytes("gd"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_mm$0=caml_string_of_jsbytes("mm"),
     cst_pt$0=caml_string_of_jsbytes("pt"),
     cst_px$0=caml_string_of_jsbytes("px"),
     cst_rem$0=caml_string_of_jsbytes("rem"),
     cst_vh$0=caml_string_of_jsbytes("vh"),
     cst_vm$0=caml_string_of_jsbytes("vm"),
     cst_vw$0=caml_string_of_jsbytes("vw"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_px=caml_string_of_jsbytes("px"),
     cst_gd=caml_string_of_jsbytes("gd"),
     cst_rem=caml_string_of_jsbytes("rem"),
     cst_vw=caml_string_of_jsbytes("vw"),
     cst_vh=caml_string_of_jsbytes("vh"),
     cst_vm=caml_string_of_jsbytes("vm"),
     cst_ch=caml_string_of_jsbytes("ch"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst$40=caml_string_of_jsbytes("): "),
     cst_color_conversion_error$0=
      caml_string_of_jsbytes("color conversion error ("),
     cst$39=caml_string_of_jsbytes("): "),
     cst_color_conversion_error=
      caml_string_of_jsbytes("color conversion error ("),
     cst_is_not_a_valid_color$0=
      caml_string_of_jsbytes(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_string_of_jsbytes("rgb"),
     cst_rgba=caml_string_of_jsbytes("rgba"),
     cst_rgb$0=caml_string_of_jsbytes("rgb"),
     cst_rgba$0=caml_string_of_jsbytes("rgba"),
     cst_hsl=caml_string_of_jsbytes("hsl"),
     cst_hsla=caml_string_of_jsbytes("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_string_of_jsbytes("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_string_of_jsbytes(" is not a valid color"),
     cst_is_out_of_valid_range=
      caml_string_of_jsbytes(" is out of valid range"),
     partial=[8,[0,0,0],0,0,[12,41,0]],
     partial$0=[12,41,0],
     partial$1=[0,0,0],
     cst_lightgrey$0=caml_string_of_jsbytes("lightgrey"),
     cst_darkslategray$0=caml_string_of_jsbytes("darkslategray"),
     cst_cornsilk$0=caml_string_of_jsbytes("cornsilk"),
     cst_blue$0=caml_string_of_jsbytes("blue"),
     cst_aliceblue$0=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite$0=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua$0=caml_string_of_jsbytes("aqua"),
     cst_aquamarine$0=caml_string_of_jsbytes("aquamarine"),
     cst_azure$0=caml_string_of_jsbytes("azure"),
     cst_beige$0=caml_string_of_jsbytes("beige"),
     cst_bisque$0=caml_string_of_jsbytes("bisque"),
     cst_black$0=caml_string_of_jsbytes("black"),
     cst_blanchedalmond$0=caml_string_of_jsbytes("blanchedalmond"),
     cst_blueviolet$0=caml_string_of_jsbytes("blueviolet"),
     cst_brown$0=caml_string_of_jsbytes("brown"),
     cst_burlywood$0=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue$0=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse$0=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate$0=caml_string_of_jsbytes("chocolate"),
     cst_coral$0=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue$0=caml_string_of_jsbytes("cornflowerblue"),
     cst_darkkhaki$0=caml_string_of_jsbytes("darkkhaki"),
     cst_crimson$0=caml_string_of_jsbytes("crimson"),
     cst_cyan$0=caml_string_of_jsbytes("cyan"),
     cst_darkblue$0=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan$0=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod$0=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray$0=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen$0=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey$0=caml_string_of_jsbytes("darkgrey"),
     cst_darkmagenta$0=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen$0=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange$0=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid$0=caml_string_of_jsbytes("darkorchid"),
     cst_darkred$0=caml_string_of_jsbytes("darkred"),
     cst_darksalmon$0=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen$0=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue$0=caml_string_of_jsbytes("darkslateblue"),
     cst_greenyellow$0=caml_string_of_jsbytes("greenyellow"),
     cst_floralwhite$0=caml_string_of_jsbytes("floralwhite"),
     cst_darkslategrey$0=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise$0=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet$0=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink$0=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue$0=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray$0=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey$0=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue$0=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick$0=caml_string_of_jsbytes("firebrick"),
     cst_forestgreen$0=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia$0=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro$0=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite$0=caml_string_of_jsbytes("ghostwhite"),
     cst_gold$0=caml_string_of_jsbytes("gold"),
     cst_goldenrod$0=caml_string_of_jsbytes("goldenrod"),
     cst_gray$0=caml_string_of_jsbytes("gray"),
     cst_green$0=caml_string_of_jsbytes("green"),
     cst_lavenderblush$0=caml_string_of_jsbytes("lavenderblush"),
     cst_grey$0=caml_string_of_jsbytes("grey"),
     cst_honeydew$0=caml_string_of_jsbytes("honeydew"),
     cst_hotpink$0=caml_string_of_jsbytes("hotpink"),
     cst_indianred$0=caml_string_of_jsbytes("indianred"),
     cst_indigo$0=caml_string_of_jsbytes("indigo"),
     cst_ivory$0=caml_string_of_jsbytes("ivory"),
     cst_khaki$0=caml_string_of_jsbytes("khaki"),
     cst_lavender$0=caml_string_of_jsbytes("lavender"),
     cst_lawngreen$0=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon$0=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue$0=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral$0=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan$0=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray$0=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen$0=caml_string_of_jsbytes("lightgreen"),
     cst_paleturquoise$0=caml_string_of_jsbytes("paleturquoise"),
     cst_mediumslateblue$0=caml_string_of_jsbytes("mediumslateblue"),
     cst_limegreen$0=caml_string_of_jsbytes("limegreen"),
     cst_lightpink$0=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon$0=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen$0=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue$0=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray$0=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey$0=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue$0=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow$0=caml_string_of_jsbytes("lightyellow"),
     cst_lime$0=caml_string_of_jsbytes("lime"),
     cst_linen$0=caml_string_of_jsbytes("linen"),
     cst_magenta$0=caml_string_of_jsbytes("magenta"),
     cst_maroon$0=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine$0=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue$0=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid$0=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple$0=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen$0=caml_string_of_jsbytes("mediumseagreen"),
     cst_navy$0=caml_string_of_jsbytes("navy"),
     cst_mediumspringgreen$0=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise$0=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred$0=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue$0=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream$0=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose$0=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin$0=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite$0=caml_string_of_jsbytes("navajowhite"),
     cst_oldlace$0=caml_string_of_jsbytes("oldlace"),
     cst_olive$0=caml_string_of_jsbytes("olive"),
     cst_olivedrab$0=caml_string_of_jsbytes("olivedrab"),
     cst_orange$0=caml_string_of_jsbytes("orange"),
     cst_orangered$0=caml_string_of_jsbytes("orangered"),
     cst_orchid$0=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod$0=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen$0=caml_string_of_jsbytes("palegreen"),
     cst_skyblue$0=caml_string_of_jsbytes("skyblue"),
     cst_rosybrown$0=caml_string_of_jsbytes("rosybrown"),
     cst_palevioletred$0=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip$0=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff$0=caml_string_of_jsbytes("peachpuff"),
     cst_peru$0=caml_string_of_jsbytes("peru"),
     cst_pink$0=caml_string_of_jsbytes("pink"),
     cst_plum$0=caml_string_of_jsbytes("plum"),
     cst_powderblue$0=caml_string_of_jsbytes("powderblue"),
     cst_purple$0=caml_string_of_jsbytes("purple"),
     cst_red$0=caml_string_of_jsbytes("red"),
     cst_royalblue$0=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown$0=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon$0=caml_string_of_jsbytes("salmon"),
     cst_sandybrown$0=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen$0=caml_string_of_jsbytes("seagreen"),
     cst_seashell$0=caml_string_of_jsbytes("seashell"),
     cst_sienna$0=caml_string_of_jsbytes("sienna"),
     cst_silver$0=caml_string_of_jsbytes("silver"),
     cst_thistle$0=caml_string_of_jsbytes("thistle"),
     cst_slateblue$0=caml_string_of_jsbytes("slateblue"),
     cst_slategray$0=caml_string_of_jsbytes("slategray"),
     cst_slategrey$0=caml_string_of_jsbytes("slategrey"),
     cst_snow$0=caml_string_of_jsbytes("snow"),
     cst_springgreen$0=caml_string_of_jsbytes("springgreen"),
     cst_steelblue$0=caml_string_of_jsbytes("steelblue"),
     cst_tan$0=caml_string_of_jsbytes("tan"),
     cst_teal$0=caml_string_of_jsbytes("teal"),
     cst_tomato$0=caml_string_of_jsbytes("tomato"),
     cst_turquoise$0=caml_string_of_jsbytes("turquoise"),
     cst_violet$0=caml_string_of_jsbytes("violet"),
     cst_wheat$0=caml_string_of_jsbytes("wheat"),
     cst_white$0=caml_string_of_jsbytes("white"),
     cst_whitesmoke$0=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow$0=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen$0=caml_string_of_jsbytes("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_string_of_jsbytes(" is not a valid color name"),
     cst_aliceblue=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua=caml_string_of_jsbytes("aqua"),
     cst_aquamarine=caml_string_of_jsbytes("aquamarine"),
     cst_azure=caml_string_of_jsbytes("azure"),
     cst_beige=caml_string_of_jsbytes("beige"),
     cst_bisque=caml_string_of_jsbytes("bisque"),
     cst_black=caml_string_of_jsbytes("black"),
     cst_blanchedalmond=caml_string_of_jsbytes("blanchedalmond"),
     cst_blue=caml_string_of_jsbytes("blue"),
     cst_blueviolet=caml_string_of_jsbytes("blueviolet"),
     cst_brown=caml_string_of_jsbytes("brown"),
     cst_burlywood=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate=caml_string_of_jsbytes("chocolate"),
     cst_coral=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue=caml_string_of_jsbytes("cornflowerblue"),
     cst_cornsilk=caml_string_of_jsbytes("cornsilk"),
     cst_crimson=caml_string_of_jsbytes("crimson"),
     cst_cyan=caml_string_of_jsbytes("cyan"),
     cst_darkblue=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey=caml_string_of_jsbytes("darkgrey"),
     cst_darkkhaki=caml_string_of_jsbytes("darkkhaki"),
     cst_darkmagenta=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid=caml_string_of_jsbytes("darkorchid"),
     cst_darkred=caml_string_of_jsbytes("darkred"),
     cst_darksalmon=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue=caml_string_of_jsbytes("darkslateblue"),
     cst_darkslategray=caml_string_of_jsbytes("darkslategray"),
     cst_darkslategrey=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick=caml_string_of_jsbytes("firebrick"),
     cst_floralwhite=caml_string_of_jsbytes("floralwhite"),
     cst_forestgreen=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite=caml_string_of_jsbytes("ghostwhite"),
     cst_gold=caml_string_of_jsbytes("gold"),
     cst_goldenrod=caml_string_of_jsbytes("goldenrod"),
     cst_gray=caml_string_of_jsbytes("gray"),
     cst_grey=caml_string_of_jsbytes("grey"),
     cst_green=caml_string_of_jsbytes("green"),
     cst_greenyellow=caml_string_of_jsbytes("greenyellow"),
     cst_honeydew=caml_string_of_jsbytes("honeydew"),
     cst_hotpink=caml_string_of_jsbytes("hotpink"),
     cst_indianred=caml_string_of_jsbytes("indianred"),
     cst_indigo=caml_string_of_jsbytes("indigo"),
     cst_ivory=caml_string_of_jsbytes("ivory"),
     cst_khaki=caml_string_of_jsbytes("khaki"),
     cst_lavender=caml_string_of_jsbytes("lavender"),
     cst_lavenderblush=caml_string_of_jsbytes("lavenderblush"),
     cst_lawngreen=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen=caml_string_of_jsbytes("lightgreen"),
     cst_lightgrey=caml_string_of_jsbytes("lightgrey"),
     cst_lightpink=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow=caml_string_of_jsbytes("lightyellow"),
     cst_lime=caml_string_of_jsbytes("lime"),
     cst_limegreen=caml_string_of_jsbytes("limegreen"),
     cst_linen=caml_string_of_jsbytes("linen"),
     cst_magenta=caml_string_of_jsbytes("magenta"),
     cst_maroon=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen=caml_string_of_jsbytes("mediumseagreen"),
     cst_mediumslateblue=caml_string_of_jsbytes("mediumslateblue"),
     cst_mediumspringgreen=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite=caml_string_of_jsbytes("navajowhite"),
     cst_navy=caml_string_of_jsbytes("navy"),
     cst_oldlace=caml_string_of_jsbytes("oldlace"),
     cst_olive=caml_string_of_jsbytes("olive"),
     cst_olivedrab=caml_string_of_jsbytes("olivedrab"),
     cst_orange=caml_string_of_jsbytes("orange"),
     cst_orangered=caml_string_of_jsbytes("orangered"),
     cst_orchid=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen=caml_string_of_jsbytes("palegreen"),
     cst_paleturquoise=caml_string_of_jsbytes("paleturquoise"),
     cst_palevioletred=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff=caml_string_of_jsbytes("peachpuff"),
     cst_peru=caml_string_of_jsbytes("peru"),
     cst_pink=caml_string_of_jsbytes("pink"),
     cst_plum=caml_string_of_jsbytes("plum"),
     cst_powderblue=caml_string_of_jsbytes("powderblue"),
     cst_purple=caml_string_of_jsbytes("purple"),
     cst_red=caml_string_of_jsbytes("red"),
     cst_rosybrown=caml_string_of_jsbytes("rosybrown"),
     cst_royalblue=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon=caml_string_of_jsbytes("salmon"),
     cst_sandybrown=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen=caml_string_of_jsbytes("seagreen"),
     cst_seashell=caml_string_of_jsbytes("seashell"),
     cst_sienna=caml_string_of_jsbytes("sienna"),
     cst_silver=caml_string_of_jsbytes("silver"),
     cst_skyblue=caml_string_of_jsbytes("skyblue"),
     cst_slateblue=caml_string_of_jsbytes("slateblue"),
     cst_slategray=caml_string_of_jsbytes("slategray"),
     cst_slategrey=caml_string_of_jsbytes("slategrey"),
     cst_snow=caml_string_of_jsbytes("snow"),
     cst_springgreen=caml_string_of_jsbytes("springgreen"),
     cst_steelblue=caml_string_of_jsbytes("steelblue"),
     cst_tan=caml_string_of_jsbytes("tan"),
     cst_teal=caml_string_of_jsbytes("teal"),
     cst_thistle=caml_string_of_jsbytes("thistle"),
     cst_tomato=caml_string_of_jsbytes("tomato"),
     cst_turquoise=caml_string_of_jsbytes("turquoise"),
     cst_violet=caml_string_of_jsbytes("violet"),
     cst_wheat=caml_string_of_jsbytes("wheat"),
     cst_white=caml_string_of_jsbytes("white"),
     cst_whitesmoke=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen=caml_string_of_jsbytes("yellowgreen"),
     cst_vkern$0=caml_string_of_jsbytes("vkern"),
     cst_view$0=caml_string_of_jsbytes("view"),
     cst_use$0=caml_string_of_jsbytes("use"),
     cst_tspan$0=caml_string_of_jsbytes("tspan"),
     cst_tref$0=caml_string_of_jsbytes("tref"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_textpath$0=caml_string_of_jsbytes("textpath"),
     cst_text$1=caml_string_of_jsbytes("text"),
     cst_symbol$0=caml_string_of_jsbytes("symbol"),
     cst_switch$0=caml_string_of_jsbytes("switch"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_style$3=caml_string_of_jsbytes("style"),
     cst_stop$0=caml_string_of_jsbytes("stop"),
     cst_set$0=caml_string_of_jsbytes("set"),
     cst_script$3=caml_string_of_jsbytes("script"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_radialgradient$0=caml_string_of_jsbytes("radialgradient"),
     cst_polyline$0=caml_string_of_jsbytes("polyline"),
     cst_polygon$0=caml_string_of_jsbytes("polygon"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_mpath$0=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph$0=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_mask$0=caml_string_of_jsbytes("mask"),
     cst_lineargradient$0=caml_string_of_jsbytes("lineargradient"),
     cst_line$0=caml_string_of_jsbytes("line"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_hkern$0=caml_string_of_jsbytes("hkern"),
     cst_glyphref$0=caml_string_of_jsbytes("glyphref"),
     cst_glyph$0=caml_string_of_jsbytes("glyph"),
     cst_g$1=caml_string_of_jsbytes("g"),
     cst_foreignobject=caml_string_of_jsbytes("foreignobject"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src$0=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name$0=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format$0=caml_string_of_jsbytes("font-face-format"),
     cst_font_face$0=caml_string_of_jsbytes("font-face"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_ellipse$0=caml_string_of_jsbytes("ellipse"),
     cst_desc$0=caml_string_of_jsbytes("desc"),
     cst_defs$0=caml_string_of_jsbytes("defs"),
     cst_cursor$0=caml_string_of_jsbytes("cursor"),
     cst_clippath$0=caml_string_of_jsbytes("clippath"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_animatetransform$0=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion$0=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor$0=caml_string_of_jsbytes("animatecolor"),
     cst_animate$0=caml_string_of_jsbytes("animate"),
     cst_altglyphitem$0=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef$0=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph$0=caml_string_of_jsbytes("altglyph"),
     cst_a$3=caml_string_of_jsbytes("a"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_textpath=caml_string_of_jsbytes("textpath"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_script$2=caml_string_of_jsbytes("script"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_radialgradient=caml_string_of_jsbytes("radialgradient"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     cst_mask=caml_string_of_jsbytes("mask"),
     cst_lineargradient=caml_string_of_jsbytes("lineargradient"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_glyphref=caml_string_of_jsbytes("glyphref"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format=caml_string_of_jsbytes("font-face-format"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_clippath=caml_string_of_jsbytes("clippath"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_animatetransform=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor=caml_string_of_jsbytes("animatecolor"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_altglyphitem=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph=caml_string_of_jsbytes("altglyph"),
     cst_a$2=caml_string_of_jsbytes("a"),
     cst_Js_of_ocaml_Dom_svg_SVGErr=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_svg.SVGError"),
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib=global_data.Stdlib,
     Stdlib_callback=global_data.Stdlib__callback,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_printf=global_data.Stdlib__printf,
     Js_of_ocaml=[0];
    caml_register_global(1634,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _d_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom.ml"),351,67],
     _e_=[0,caml_string_of_jsbytes("transparent")],
     _f_=[0,caml_string_of_jsbytes("native")],
     _j_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2792,58],
     _i_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2791,61],
     _h_=
      [0,
       [11,
        caml_string_of_jsbytes("getElementById_exn: "),
        [3,0,[11,caml_string_of_jsbytes(" not found"),0]]],
       caml_string_of_jsbytes("getElementById_exn: %S not found")],
     _l_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/form.ml"),177,13],
     _k_=[0,1],
     _m_=
      [0,caml_string_of_jsbytes("lib/js_of_ocaml/xmlHttpRequest.ml"),129,75],
     _n_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/regexp.ml"),34,64],
     _o_=[0,caml_string_of_jsbytes(""),0],
     _ci_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cj_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ck_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cl_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b6_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b7_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b8_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b9_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b__=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b$_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ca_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cb_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cc_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cd_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ce_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cf_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cg_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ch_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b5_=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("aliceblue"),
         caml_string_of_jsbytes("antiquewhite"),
         caml_string_of_jsbytes("aqua"),
         caml_string_of_jsbytes("aquamarine"),
         caml_string_of_jsbytes("azure"),
         caml_string_of_jsbytes("beige"),
         caml_string_of_jsbytes("bisque"),
         caml_string_of_jsbytes("black"),
         caml_string_of_jsbytes("blanchedalmond"),
         caml_string_of_jsbytes("blue"),
         caml_string_of_jsbytes("blueviolet"),
         caml_string_of_jsbytes("brown"),
         caml_string_of_jsbytes("burlywood"),
         caml_string_of_jsbytes("cadetblue"),
         caml_string_of_jsbytes("chartreuse"),
         caml_string_of_jsbytes("chocolate"),
         caml_string_of_jsbytes("coral"),
         caml_string_of_jsbytes("cornflowerblue"),
         caml_string_of_jsbytes("cornsilk"),
         caml_string_of_jsbytes("crimson"),
         caml_string_of_jsbytes("cyan"),
         caml_string_of_jsbytes("darkblue"),
         caml_string_of_jsbytes("darkcyan"),
         caml_string_of_jsbytes("darkgoldenrod"),
         caml_string_of_jsbytes("darkgray"),
         caml_string_of_jsbytes("darkgreen"),
         caml_string_of_jsbytes("darkgrey"),
         caml_string_of_jsbytes("darkkhaki"),
         caml_string_of_jsbytes("darkmagenta"),
         caml_string_of_jsbytes("darkolivegreen"),
         caml_string_of_jsbytes("darkorange"),
         caml_string_of_jsbytes("darkorchid"),
         caml_string_of_jsbytes("darkred"),
         caml_string_of_jsbytes("darksalmon"),
         caml_string_of_jsbytes("darkseagreen"),
         caml_string_of_jsbytes("darkslateblue"),
         caml_string_of_jsbytes("darkslategray"),
         caml_string_of_jsbytes("darkslategrey"),
         caml_string_of_jsbytes("darkturquoise"),
         caml_string_of_jsbytes("darkviolet"),
         caml_string_of_jsbytes("deeppink"),
         caml_string_of_jsbytes("deepskyblue"),
         caml_string_of_jsbytes("dimgray"),
         caml_string_of_jsbytes("dimgrey"),
         caml_string_of_jsbytes("dodgerblue"),
         caml_string_of_jsbytes("firebrick"),
         caml_string_of_jsbytes("floralwhite"),
         caml_string_of_jsbytes("forestgreen"),
         caml_string_of_jsbytes("fuchsia"),
         caml_string_of_jsbytes("gainsboro"),
         caml_string_of_jsbytes("ghostwhite"),
         caml_string_of_jsbytes("gold"),
         caml_string_of_jsbytes("goldenrod"),
         caml_string_of_jsbytes("gray"),
         caml_string_of_jsbytes("green"),
         caml_string_of_jsbytes("greenyellow"),
         caml_string_of_jsbytes("grey"),
         caml_string_of_jsbytes("honeydew"),
         caml_string_of_jsbytes("hotpink"),
         caml_string_of_jsbytes("indianred"),
         caml_string_of_jsbytes("indigo"),
         caml_string_of_jsbytes("ivory"),
         caml_string_of_jsbytes("khaki"),
         caml_string_of_jsbytes("lavender"),
         caml_string_of_jsbytes("lavenderblush"),
         caml_string_of_jsbytes("lawngreen"),
         caml_string_of_jsbytes("lemonchiffon"),
         caml_string_of_jsbytes("lightblue"),
         caml_string_of_jsbytes("lightcoral"),
         caml_string_of_jsbytes("lightcyan"),
         caml_string_of_jsbytes("lightgoldenrodyellow"),
         caml_string_of_jsbytes("lightgray"),
         caml_string_of_jsbytes("lightgreen"),
         caml_string_of_jsbytes("lightgrey"),
         caml_string_of_jsbytes("lightpink"),
         caml_string_of_jsbytes("lightsalmon"),
         caml_string_of_jsbytes("lightseagreen"),
         caml_string_of_jsbytes("lightskyblue"),
         caml_string_of_jsbytes("lightslategray"),
         caml_string_of_jsbytes("lightslategrey"),
         caml_string_of_jsbytes("lightsteelblue"),
         caml_string_of_jsbytes("lightyellow"),
         caml_string_of_jsbytes("lime"),
         caml_string_of_jsbytes("limegreen"),
         caml_string_of_jsbytes("linen"),
         caml_string_of_jsbytes("magenta"),
         caml_string_of_jsbytes("maroon"),
         caml_string_of_jsbytes("mediumaquamarine"),
         caml_string_of_jsbytes("mediumblue"),
         caml_string_of_jsbytes("mediumorchid"),
         caml_string_of_jsbytes("mediumpurple"),
         caml_string_of_jsbytes("mediumseagreen"),
         caml_string_of_jsbytes("mediumslateblue"),
         caml_string_of_jsbytes("mediumspringgreen"),
         caml_string_of_jsbytes("mediumturquoise"),
         caml_string_of_jsbytes("mediumvioletred"),
         caml_string_of_jsbytes("midnightblue"),
         caml_string_of_jsbytes("mintcream"),
         caml_string_of_jsbytes("mistyrose"),
         caml_string_of_jsbytes("moccasin"),
         caml_string_of_jsbytes("navajowhite"),
         caml_string_of_jsbytes("navy"),
         caml_string_of_jsbytes("oldlace"),
         caml_string_of_jsbytes("olive"),
         caml_string_of_jsbytes("olivedrab"),
         caml_string_of_jsbytes("orange"),
         caml_string_of_jsbytes("orangered"),
         caml_string_of_jsbytes("orchid"),
         caml_string_of_jsbytes("palegoldenrod"),
         caml_string_of_jsbytes("palegreen"),
         caml_string_of_jsbytes("paleturquoise"),
         caml_string_of_jsbytes("palevioletred"),
         caml_string_of_jsbytes("papayawhip"),
         caml_string_of_jsbytes("peachpuff"),
         caml_string_of_jsbytes("peru"),
         caml_string_of_jsbytes("pink"),
         caml_string_of_jsbytes("plum"),
         caml_string_of_jsbytes("powderblue"),
         caml_string_of_jsbytes("purple"),
         caml_string_of_jsbytes("red"),
         caml_string_of_jsbytes("rosybrown"),
         caml_string_of_jsbytes("royalblue"),
         caml_string_of_jsbytes("saddlebrown"),
         caml_string_of_jsbytes("salmon"),
         caml_string_of_jsbytes("sandybrown"),
         caml_string_of_jsbytes("seagreen"),
         caml_string_of_jsbytes("seashell"),
         caml_string_of_jsbytes("sienna"),
         caml_string_of_jsbytes("silver"),
         caml_string_of_jsbytes("skyblue"),
         caml_string_of_jsbytes("slateblue"),
         caml_string_of_jsbytes("slategray"),
         caml_string_of_jsbytes("slategrey"),
         caml_string_of_jsbytes("snow"),
         caml_string_of_jsbytes("springgreen"),
         caml_string_of_jsbytes("steelblue"),
         caml_string_of_jsbytes("tan"),
         caml_string_of_jsbytes("teal"),
         caml_string_of_jsbytes("thistle"),
         caml_string_of_jsbytes("tomato"),
         caml_string_of_jsbytes("turquoise"),
         caml_string_of_jsbytes("violet"),
         caml_string_of_jsbytes("wheat"),
         caml_string_of_jsbytes("white"),
         caml_string_of_jsbytes("whitesmoke"),
         caml_string_of_jsbytes("yellow"),
         caml_string_of_jsbytes("yellowgreen")]),
     _b4_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_string_of_jsbytes("#%02X%02X%02X")],
     _bY_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("rgb(%d,%d,%d)")],
     _bZ_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_string_of_jsbytes("rgb(%d%%,%d%%,%d%%)")],
     _b0_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,[0,0,0],0,0,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d,%d,%d,%f)")],
     _b1_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d%%,%d%%,%d%%,%f)")],
     _b2_=
      [0,
       [11,
        caml_string_of_jsbytes("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("hsl(%d,%d%%,%d%%)")],
     _b3_=
      [0,
       [11,
        caml_string_of_jsbytes("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,
            37,
            [12,44,[4,0,0,0,[12,37,[12,44,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("hsla(%d,%d%%,%d%%,%f)")],
     _v_=[0,240,248,255],
     _w_=[0,250,235,215],
     _x_=[0,0,255,255],
     _y_=[0,127,255,212],
     _z_=[0,240,255,255],
     _A_=[0,245,245,220],
     _B_=[0,255,228,196],
     _C_=[0,0,0,0],
     _D_=[0,255,235,205],
     _E_=[0,0,0,255],
     _F_=[0,138,43,226],
     _G_=[0,165,42,42],
     _H_=[0,222,184,135],
     _I_=[0,95,158,160],
     _J_=[0,127,255,0],
     _K_=[0,210,105,30],
     _L_=[0,255,127,80],
     _M_=[0,100,149,237],
     _N_=[0,255,248,220],
     _O_=[0,220,20,60],
     _P_=[0,0,255,255],
     _Q_=[0,0,0,139],
     _R_=[0,0,139,139],
     _S_=[0,184,134,11],
     _T_=[0,169,169,169],
     _U_=[0,0,100,0],
     _V_=[0,169,169,169],
     _W_=[0,189,183,107],
     _X_=[0,139,0,139],
     _Y_=[0,85,107,47],
     _Z_=[0,255,140,0],
     ___=[0,153,50,204],
     _$_=[0,139,0,0],
     _aa_=[0,233,150,122],
     _ab_=[0,143,188,143],
     _ac_=[0,72,61,139],
     _ad_=[0,47,79,79],
     _ae_=[0,47,79,79],
     _af_=[0,0,206,209],
     _ag_=[0,148,0,211],
     _ah_=[0,255,20,147],
     _ai_=[0,0,191,255],
     _aj_=[0,105,105,105],
     _ak_=[0,105,105,105],
     _al_=[0,30,144,255],
     _am_=[0,178,34,34],
     _an_=[0,255,250,240],
     _ao_=[0,34,139,34],
     _ap_=[0,255,0,255],
     _aq_=[0,220,220,220],
     _ar_=[0,248,248,255],
     _as_=[0,255,215,0],
     _at_=[0,218,165,32],
     _au_=[0,128,128,128],
     _av_=[0,128,128,128],
     _aw_=[0,0,128,0],
     _ax_=[0,173,255,47],
     _ay_=[0,240,255,240],
     _az_=[0,255,105,180],
     _aA_=[0,205,92,92],
     _aB_=[0,75,0,130],
     _aC_=[0,255,255,240],
     _aD_=[0,240,230,140],
     _aE_=[0,230,230,250],
     _aF_=[0,255,240,245],
     _aG_=[0,124,252,0],
     _aH_=[0,255,250,205],
     _aI_=[0,173,216,230],
     _aJ_=[0,240,128,128],
     _aK_=[0,224,255,255],
     _aL_=[0,250,250,210],
     _aM_=[0,211,211,211],
     _aN_=[0,144,238,144],
     _aO_=[0,211,211,211],
     _aP_=[0,255,182,193],
     _aQ_=[0,255,160,122],
     _aR_=[0,32,178,170],
     _aS_=[0,135,206,250],
     _aT_=[0,119,136,153],
     _aU_=[0,119,136,153],
     _aV_=[0,176,196,222],
     _aW_=[0,255,255,224],
     _aX_=[0,0,255,0],
     _aY_=[0,50,205,50],
     _aZ_=[0,250,240,230],
     _a0_=[0,255,0,255],
     _a1_=[0,128,0,0],
     _a2_=[0,102,205,170],
     _a3_=[0,0,0,205],
     _a4_=[0,186,85,211],
     _a5_=[0,147,112,219],
     _a6_=[0,60,179,113],
     _a7_=[0,123,104,238],
     _a8_=[0,0,250,154],
     _a9_=[0,72,209,204],
     _a__=[0,199,21,133],
     _a$_=[0,25,25,112],
     _ba_=[0,245,255,250],
     _bb_=[0,255,228,225],
     _bc_=[0,255,228,181],
     _bd_=[0,255,222,173],
     _be_=[0,0,0,128],
     _bf_=[0,253,245,230],
     _bg_=[0,128,128,0],
     _bh_=[0,107,142,35],
     _bi_=[0,255,165,0],
     _bj_=[0,255,69,0],
     _bk_=[0,218,112,214],
     _bl_=[0,238,232,170],
     _bm_=[0,152,251,152],
     _bn_=[0,175,238,238],
     _bo_=[0,219,112,147],
     _bp_=[0,255,239,213],
     _bq_=[0,255,218,185],
     _br_=[0,205,133,63],
     _bs_=[0,255,192,203],
     _bt_=[0,221,160,221],
     _bu_=[0,176,224,230],
     _bv_=[0,128,0,128],
     _bw_=[0,255,0,0],
     _bx_=[0,188,143,143],
     _by_=[0,65,105,225],
     _bz_=[0,139,69,19],
     _bA_=[0,250,128,114],
     _bB_=[0,244,164,96],
     _bC_=[0,46,139,87],
     _bD_=[0,255,245,238],
     _bE_=[0,160,82,45],
     _bF_=[0,192,192,192],
     _bG_=[0,135,206,235],
     _bH_=[0,106,90,205],
     _bI_=[0,112,128,144],
     _bJ_=[0,112,128,144],
     _bK_=[0,255,250,250],
     _bL_=[0,0,255,127],
     _bM_=[0,70,130,180],
     _bN_=[0,210,180,140],
     _bO_=[0,0,128,128],
     _bP_=[0,216,191,216],
     _bQ_=[0,255,99,71],
     _bR_=[0,64,224,208],
     _bS_=[0,238,130,238],
     _bT_=[0,245,222,179],
     _bU_=[0,255,255,255],
     _bV_=[0,245,245,245],
     _bW_=[0,255,255,0],
     _bX_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_string[1],
     init=Stdlib_string[2],
     copy=Stdlib_string[3],
     sub=Stdlib_string[4],
     fill=Stdlib_string[5],
     blit=Stdlib_string[6],
     concat=Stdlib_string[7],
     iter=Stdlib_string[8],
     iteri=Stdlib_string[9],
     map=Stdlib_string[10],
     mapi=Stdlib_string[11],
     trim=Stdlib_string[12],
     escaped=Stdlib_string[13],
     index=Stdlib_string[14],
     index_opt=Stdlib_string[15],
     rindex=Stdlib_string[16],
     rindex_opt=Stdlib_string[17],
     index_from=Stdlib_string[18],
     index_from_opt=Stdlib_string[19],
     rindex_from=Stdlib_string[20],
     rindex_from_opt=Stdlib_string[21],
     contains=Stdlib_string[22],
     contains_from=Stdlib_string[23],
     rcontains_from=Stdlib_string[24],
     uppercase=Stdlib_string[25],
     lowercase=Stdlib_string[26],
     capitalize=Stdlib_string[27],
     uncapitalize=Stdlib_string[28],
     uppercase_ascii=Stdlib_string[29],
     lowercase_ascii=Stdlib_string[30],
     capitalize_ascii=Stdlib_string[31],
     uncapitalize_ascii=Stdlib_string[32],
     compare$0=Stdlib_string[33],
     split_on_char=Stdlib_string[35],
     to_seq=Stdlib_string[36],
     to_seqi=Stdlib_string[37],
     of_seq=Stdlib_string[38],
     equal$0=runtime.caml_string_equal,
     String=
      [0,
       make,
       init,
       copy,
       sub,
       fill,
       blit,
       concat,
       iter,
       iteri,
       map,
       mapi,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$0,
       split_on_char,
       to_seq,
       to_seqi,
       of_seq,
       equal$0],
     chr=Stdlib_char[1],
     escaped$0=Stdlib_char[2],
     lowercase$0=Stdlib_char[3],
     uppercase$0=Stdlib_char[4],
     lowercase_ascii$0=Stdlib_char[5],
     uppercase_ascii$0=Stdlib_char[6],
     compare$1=Stdlib_char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1637,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t37=undefined;
    function return$0(_gO_){return _gO_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gN_=1 - (x == no_handler?1:0);return _gN_?caml_call1(f,x):_gN_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gM_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gM_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gL_){return _gL_}
    function map$1(x,f){return x === t37?t37:caml_call1(f,x)}
    function bind$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function test$0(x){return x !== t37?1:0}
    function iter$1(x,f)
     {var _gK_=x !== t37?1:0;return _gK_?caml_call1(f,x):_gK_}
    function case$1(x,f,g){return x === t37?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t37?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t37}
    function to_option$0(x)
     {function _gJ_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gJ_)}
    var
     Optdef=
      [0,
       t37,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gH_(param){return caml_call1(g,x)}
      var _gI_=caml_call1(f,x);
      return caml_call2(Opt[8],_gI_,_gH_)}
    function coerce_opt(x,f,g)
     {function _gF_(param){return caml_call1(g,x)}
      var _gG_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gG_,_gF_)}
    var
     true$0=true,
     false$0=false,
     string_constr=Unsafe[1].String,
     regExp_withFlags=Unsafe[1].RegExp,
     object_constructor=Unsafe[1].Object;
    function object_keys(o){return object_constructor.keys(o)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gE_){return _gE_}
    function match_result(_gD_){return _gD_}
    var
     date_ms=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Stdlib_callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_string_of_jsstring(e.toString())]}
      return 0}
    caml_call1(Stdlib_printexc[9],_a_);
    function _b_(e)
     {return e instanceof array_length
              ?0
              :[0,caml_string_of_jsstring(e.toString())]}
    caml_call1(Stdlib_printexc[9],_b_);
    function string_of_error(e){return caml_string_of_jsstring(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x)
     {return export_js(caml_jsstring_of_string(field),x)}
    function export_all(obj)
     {var keys=object_keys(obj);
      return keys.forEach
              (caml_js_wrap_callback
                (function(key,param,_gC_){return export_js(key,obj[key])}))}
    function _c_(_gB_){return _gB_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gA_){return _gA_},
       t37,
       _c_,
       Opt,
       Optdef,
       true$0,
       false$0,
       string_constr,
       regExp_withFlags,
       regExp_withFlags,
       regExp_withFlags,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1641,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gz_=nodeList.item(i),match=caml_call1(Opt[10],_gz_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_list[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType && 4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _gw_(param)
       {function _gy_(param){throw Stdlib[8]}
        return caml_call2(Opt[8],e.srcElement,_gy_)}
      var target=caml_call2(Opt[8],e.target,_gw_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gx_=function(param){throw [0,Assert_failure,_d_]};
          return caml_call2(Opt[8],target.parentNode,_gx_)}
        return target}
      return target}
    var make$0=caml_jsstring_of_string,Event=[0,make$0];
    function addEventListenerWithOptions(e,typ,capture,once,passive,h)
     {if(e.addEventListener === t37)
       {var
         ev="on".concat(typ),
         callback=
          function(e)
           {var _gt_=[0,h,e,[0]];
            return function(_gu_,_gv_)
             {return runtime.caml_js_call(_gt_,_gu_,_gv_)}};
        e.attachEvent(ev,callback);
        return function(param){return e.detachEvent(ev,callback)}}
      var opts={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(b){return opts.capture = b});
      iter(once,function(b){return opts.once = b});
      iter(passive,function(b){return opts.passive = b});
      e.addEventListener(typ,h,opts);
      return function(param){return e.removeEventListener(typ,h,opts)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    function createCustomEvent(bubbles,cancelable,detail,typ)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var opts={};
      opt_iter(function(x){return opts.bubbles = ! ! x},bubbles);
      opt_iter(function(x){return opts.cancelable = ! ! x},cancelable);
      opt_iter(function(x){return opts.detail = x},detail);
      var constr=Unsafe[1].CustomEvent;
      return new constr(typ,opts)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1644,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     uint8Array_fromBuffer=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set,
     get$1=caml_js_get,
     unsafe_get=caml_js_get,
     dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new uint8Array_fromBuffer(ab);
      return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       runtime.caml_ba_kind_of_typed_array,
       runtime.caml_ba_to_typed_array,
       runtime.caml_ba_from_typed_array,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1645,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var blob_constr=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gp_=0;
      if(endings)
       var _gq_=116179762 <= endings[1]?_e_:_f_,_gr_=_gq_;
      else
       var _gr_=0;
      var
       _gs_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gr_],_gp_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v)
             {var v$0=v[1];return [0,[0,name,caml_jsstring_of_string(v$0)]]}
            return 0},
          _gs_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_array[12],options))
         :t37;
      return new blob_constr(caml_js_from_array(a),options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,caml_jsstring_of_string(s)])}
    function blob_from_any(contentType,endings,l)
     {function _gn_(param)
       {var _go_=param[1];
        if(155580615 === _go_){var s=param[2];return s}
        if(486041214 <= _go_)
         {if(1037850489 <= _go_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _go_)
         {var s$0=param[2];return caml_jsstring_of_string(s$0)}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_list[17],_gn_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1(Stdlib[2],cst_can_t_retrieve_file_name_n)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof blob_constr?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_gm_){return _gm_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1647,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gk_(o){return o}
      function _gl_(param)
       {var protocol=loc.protocol,hostname=loc.hostname,port=loc.port;
        if
         (caml_call2(symbol$8,protocol.length,0)
          &&
          caml_call2(symbol$8,hostname.length,0))
         return "";
        var origin=protocol.concat("//",hostname);
        return caml_call2(symbol$9,port.length,0)
                ?origin.concat(":",loc.port)
                :origin}
      return caml_call3(Optdef[7],loc.origin,_gl_,_gk_)}
    var _g_=Unsafe[1],document$0=_g_.document;
    function getElementById(id)
     {function _gh_(pnode){return pnode}
      function _gi_(param){throw Stdlib[8]}
      var _gj_=document$0.getElementById(caml_jsstring_of_string(id));
      return caml_call3(Opt[7],_gj_,_gi_,_gh_)}
    function getElementById_exn(id)
     {function _gd_(pnode){return pnode}
      function _ge_(param)
       {var _gg_=caml_call2(Stdlib_printf[4],_h_,id);
        return caml_call1(Stdlib[2],_gg_)}
      var _gf_=document$0.getElementById(caml_jsstring_of_string(id));
      return caml_call3(Opt[7],_gf_,_ge_,_gd_)}
    function getElementById_opt(id)
     {var _gc_=document$0.getElementById(caml_jsstring_of_string(id));
      return caml_call1(Opt[10],_gc_)}
    function getElementById_coerce(id,coerce)
     {function _f__(e)
       {var _gb_=caml_call1(coerce,e);return caml_call1(Opt[10],_gb_)}
      function _f$_(param){return 0}
      var _ga_=document$0.getElementById(caml_jsstring_of_string(id));
      return caml_call3(Opt[7],_ga_,_f$_,_f__)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(doc,name)
     {return doc.createElement(caml_jsstring_of_string(name))}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type && 0 === name)return createElement(doc,elt);
        var _f4_=createElementSyntax[1];
        if(785140586 === _f4_)
         {try
           {var
             el=document$0.createElement('<input name="x">'),
             _f7_=el.tagName.toLowerCase() === "input"?1:0,
             _f8_=_f7_?el.name === "x"?1:0:_f7_,
             _f5_=_f8_}
          catch(_f9_){var _f5_=0}
          var _f6_=_f5_?982028505:-1003883683;
          createElementSyntax[1] = _f6_;
          continue}
        if(982028505 <= _f4_)
         {var a=new array_length();
          a.push("<",caml_jsstring_of_string(elt));
          opt_iter
           (type,
            function(t){a.push(' type="',caml_js_html_escape(t),'"');return 0});
          opt_iter
           (name,
            function(n){a.push(' name="',caml_js_html_escape(n),'"');return 0});
          a.push(">");
          return doc.createElement(a.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canva,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t37
       ?function(e){return e.innerHTML === t37?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var _f3_=caml_jsstring_of_string(tag);
      return e.tagName.toLowerCase() === _f3_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t37 && ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _f0_(param)
       {var match=caml_string_of_jsstring(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _f1_=function(param){throw [0,Assert_failure,_i_]};
          return caml_call2(Optdef[8],e.fromElement,_f1_)}
        function _f2_(param){throw [0,Assert_failure,_j_]}
        return caml_call2(Optdef[8],e.toElement,_f2_)}
      return caml_call2(Optdef[8],e.relatedTarget,_f0_)}
    function eventAbsolutePosition(e)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fW_(x)
       {function _fY_(y){return [0,x,y]}
        function _fZ_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fZ_,_fY_)}
      function _fX_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fX_,_fW_)}
    function elementClientPosition(e)
     {var
       r=e.getBoundingClientRect(),
       body=document$0.body,
       html=document$0.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fU_(x){return x}
      function _fV_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fV_,_fU_)}
    function addMousewheelEventListenerWith(e,capture,once,passive,h)
     {var d=createDiv(document$0);
      d.setAttribute("onmousewheel","return;");
      if(typeof d.onmousewheel === "function")
       {var
         _fQ_=
          handler
           (function(e)
             {function _fS_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fS_) | 0) / 40 | 0;
              function _fT_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fT_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[11],capture,once,passive,_fQ_)}
      var
       _fR_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[12],capture,once,passive,_fR_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWith(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_string_of_jsstring(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fP_=switcher;
        if(67 <= _fP_)
         switch(_fP_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fP_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return v?v:caml_call1(f,value)}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fI_=evt.keyCode;
      function _fJ_(_fO_){return run_next(_fI_,try_key_code_normal,_fO_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fK_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fF_=evt.keyCode,
           _fK_=function(_fM_){return run_next(_fF_,try_key_code_left,_fM_)};
          break;
         case 1:
          var
           _fG_=evt.keyCode,
           _fK_=function(_fL_){return run_next(_fG_,try_key_code_right,_fL_)};
          break;
         default:
          var
           _fH_=evt.keyCode,
           _fK_=function(_fN_){return run_next(_fH_,try_key_code_numpad,_fN_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return v?v:caml_call3(Optdef[7],value,make_unidentified,f)}),
                 _fK_),
               _fJ_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fD_=[0,caml_call1(Stdlib_uchar[8],value)];return _fD_}
       catch(_fE_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var key=caml_call2(Optdef[8],evt.key,empty_string),match=key.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(key.charCodeAt(0) | 0):0}
    function element$1(_fC_){return _fC_}
    function tagged(e)
     {var tag=caml_string_of_jsbytes(e.tagName.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _fA_(e){return [0,tagged(e)]}
      function _fB_(param){return 0}
      return caml_call3(Opt[7],e,_fB_,_fA_)}
    function taggedEvent(ev)
     {function _fl_(ev){return [0,ev]}
      function _fm_(param)
       {function _fo_(ev){return [1,ev]}
        function _fp_(param)
         {function _fr_(ev){return [2,ev]}
          function _fs_(param)
           {function _fu_(ev){return [3,ev]}
            function _fv_(param)
             {function _fx_(ev){return [4,ev]}
              function _fy_(param){return [5,ev]}
              var _fz_=popStateEvent(ev);
              return caml_call3(Opt[7],_fz_,_fy_,_fx_)}
            var _fw_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fw_,_fv_,_fu_)}
          var _ft_=wheelEvent(ev);
          return caml_call3(Opt[7],_ft_,_fs_,_fr_)}
        var _fq_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fq_,_fp_,_fo_)}
      var _fn_=mouseEvent(ev);
      return caml_call3(Opt[7],_fn_,_fm_,_fl_)}
    function opt_taggedEvent(ev)
     {function _fj_(ev){return [0,taggedEvent(ev)]}
      function _fk_(param){return 0}
      return caml_call3(Opt[7],ev,_fk_,_fj_)}
    function stopPropagation(ev)
     {function _fh_(param){return ev.stopPropagation()}
      function _fi_(param){return ev.cancelBubble = true$0}
      return caml_call3(Optdef[7],ev.stopPropagation,_fi_,_fh_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _g_.requestAnimationFrame,
             [0,
              _g_.mozRequestAnimationFrame,
              [0,
               _g_.webkitRequestAnimationFrame,
               [0,
                _g_.oRequestAnimationFrame,
                [0,_g_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _fe_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_list[35],_fe_,l),
             _ff_=function(callback){return req(callback)};
            return _ff_}
          catch(_fg_)
           {_fg_ = caml_wrap_exception(_fg_);
            if(_fg_ === Stdlib[8])
             {var
               now=function(param){return new date_ms().getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _g_.setTimeout(callback,dt$0);
                return 0}}
            throw _fg_}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_g_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var remain=step - 2147483000.,step$0=overflow_limit;
        else
         var remain=0.,step$0=step;
        var cb=remain == 0.?callback:function(_fd_){return loop(remain,_fd_)};
        id[1] = [0,_g_.setTimeout(caml_js_wrap_callback(cb),step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _fc_=id[1];
      if(_fc_){var x=_fc_[1];id[1] = 0;return _g_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       document$0,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _g_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWith,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1650,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       _fa_=caml_call2(symbol$9,elt.name.length,0),
       _fb_=_fa_?1 - (elt.disabled | 0):_fa_;
      return _fb_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _e0_(i)
       {var _e$_=form.elements.item(i);return caml_call1(Opt[10],_e$_)}
      var
       _e1_=caml_call2(Stdlib_array[2],length,_e0_),
       elements=caml_call1(Stdlib_array[11],_e1_);
      function _e2_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_string_of_jsstring(v$0.name),
                value=v$0.value,
                match=caml_string_of_jsbytes(v$0.type.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(caml_call2(symbol$8,list.length,0))
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1 && match$1[1])
                      {var
                        _e6_=function(i){return list.item(i)},
                        _e7_=caml_call2(Stdlib_array[2],list.length,_e6_),
                        _e8_=caml_call1(Stdlib_array[11],_e7_);
                       return filter_map$0
                               (function(f)
                                 {var match=caml_call1(Opt[10],f);
                                  if(match)
                                   {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                  return 0},
                                _e8_)}
                     var _e9_=list.item(0),match$2=caml_call1(Opt[10],_e9_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 var switch$0=0;
                 if(caml_string_notequal(match,cst_password))
                  {if(caml_string_notequal(match,cst_radio))
                    {var switch$1=0;
                     if
                      (caml_string_notequal(match,cst_reset)
                       &&
                       caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       switch$0 = 1;
                       switch$1 = 1}
                     if(! switch$1)return 0}}
                 else
                  switch$0 = 1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_string_of_jsstring(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _e4_=
                   function(i)
                    {var _e__=v$1.options.item(i);
                     return caml_call1(Opt[10],_e__)},
                  options=caml_call2(Stdlib_array[2],v$1.options.length,_e4_),
                  _e5_=caml_call1(Stdlib_array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _e5_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_string_of_jsstring(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _e3_=caml_call2(Stdlib_list[17],_e2_,elements),
       contents=caml_call1(Stdlib_list[14],_e3_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eY_=form_elt[2],_eZ_=form_elt[1];
      if(781515420 <= _eY_[1])
       {var file=_eY_[2];return f.append(caml_jsstring_of_string(_eZ_),file)}
      var s=_eY_[2];
      return f.append(caml_jsstring_of_string(_eZ_),s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eV_=form_elements(0,form);
      function _eW_(_eX_){return append(contents,_eX_)}
      caml_call2(Stdlib_list[15],_eW_,_eV_);
      return contents}
    function get_form_contents(form)
     {var _eS_=form_elements(_k_,form);
      function _eT_(param)
       {var _eU_=param[2];
        if(typeof _eU_ !== "number" && -976970511 === _eU_[1])
         {var s=_eU_[2],name=param[1];
          return [0,name,caml_string_of_jsstring(s)]}
        throw [0,Assert_failure,_l_]}
      return caml_call2(Stdlib_list[17],_eT_,_eS_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1651,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0];
    function create(param)
     {var
       xmlHttpRequest=Unsafe[1].XMLHttpRequest,
       activeXObject=Unsafe[1].activeXObject;
      try
       {var _eN_=new xmlHttpRequest();return _eN_}
      catch(_eO_)
       {try
         {var _eM_=new activeXObject("Msxml2.XMLHTTP");return _eM_}
        catch(_eP_)
         {try
           {var _eL_=new activeXObject("Msxml3.XMLHTTP");return _eL_}
          catch(_eQ_)
           {try
             {var _eK_=new activeXObject("Microsoft.XMLHTTP");return _eK_}
            catch(_eR_){throw [0,Assert_failure,_m_]}}}}}
    var Js_of_ocaml_XmlHttpRequest=[0,create,Event$1];
    caml_register_global
     (1652,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var worker=Unsafe[1].Worker;
    function create$0(script)
     {return new worker(caml_jsstring_of_string(script))}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t37)
       caml_call1(Stdlib[1],cst_Worker_import_scripts_is_u);
      var
       _eI_=caml_call1(Stdlib_array[12],scripts),
       _eJ_=caml_call2(Stdlib_array[15],caml_jsstring_of_string,_eI_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eJ_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t37)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(msg)
     {if(Unsafe[1].postMessage === t37)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi$0);
      return Unsafe[1].postMessage(msg)}
    var
     Js_of_ocaml_Worker=
      [0,create$0,import_scripts,set_onmessage,post_message];
    caml_register_global(1653,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1654,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":true$0,
       "depth":true$0,
       "stencil":false$0,
       "antialias":true$0,
       "premultipliedAlpha":false$0,
       "preserveDrawingBuffer":false$0,
       "preferLowPowerToHighPerformance":false$0,
       "failIfMajorPerformanceCaveat":false$0},
     webglcontextlost=caml_call1(Event$0[83],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[83],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[83],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(c)
     {var ctx=c.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:c.getContext("experimental-webgl")}
    function getContextWithAttributes(c,attribs)
     {var ctx=c.getContext("webgl",attribs);
      return caml_call1(Opt[5],ctx)
              ?ctx
              :c.getContext("experimental-webgl",attribs)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1655,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"g")}
    function regexp_case_fold(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"gi")}
    function regexp_with_flag(s,f)
     {return new
              regExp_withFlags
              (caml_jsbytes_of_string(s),
               caml_jsstring_of_string(caml_call2(Stdlib[28],cst_g,f)))}
    function blunt_str_array_get(a,i)
     {function _eH_(param){throw [0,Assert_failure,_n_]}
      return caml_string_of_jsbytes(caml_call2(Optdef[8],a[i],_eH_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       _eF_=r.exec(caml_jsbytes_of_string(s)),
       _eG_=caml_call2(Opt[3],_eF_,match_result);
      return caml_call1(Opt[10],_eG_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      function _eC_(res){return [0,res.index,res]}
      var
       _eD_=r.exec(caml_jsbytes_of_string(s)),
       _eE_=caml_call2(Opt[3],_eD_,_eC_);
      return caml_call1(Opt[10],_eE_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _eB_=caml_call2(Optdef[3],r[i],caml_string_of_jsbytes);
      return caml_call1(Optdef[10],_eB_)}
    var quote_repl_re=new regExp_withFlags("[$]","g");
    function quote_repl(s)
     {return caml_jsbytes_of_string(s).replace(quote_repl_re,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      return caml_string_of_jsbytes
              (caml_jsbytes_of_string(s).replace(r,quote_repl(s_by)))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=match?match$0?"mi":"i":match$0?"m":"",
       r$0=new regExp_withFlags(r.source,flags);
      return caml_string_of_jsbytes
              (caml_jsbytes_of_string(s).replace(r$0,quote_repl(s_by)))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r,i))}
    var quote_re=regexp(cst);
    function quote(s)
     {return caml_string_of_jsbytes
              (caml_jsbytes_of_string(s).replace(quote_re,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1656,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var
     plus_re=regexp_string(cst$0),
     plus_re_js_string=new regExp_withFlags("\\+","g");
    function urldecode_js_string_string(s)
     {plus_re_js_string.lastIndex = 0;
      return caml_string_of_jsbytes
              (unescape(s.replace(plus_re_js_string," ")))}
    function urldecode(s)
     {return caml_string_of_jsbytes
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_htt,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _ez_=caml_call3(String[18],s,i,47),j=_ez_}
        catch(_eA_)
         {_eA_ = caml_wrap_exception(_eA_);
          if(_eA_ !== Stdlib[8])throw _eA_;
          var j=l}
        var word=caml_call3(String[4],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a && ! caml_string_notequal(a[1],cst$2))
       {var _ey_=a[2];
        if(! _ey_)return 0;
        if(! caml_string_notequal(_ey_[1],cst$3) && ! _ey_[2])return _o_}
      return a}
    function encode_arguments(l)
     {function _et_(param)
       {var
         v=param[2],
         n=param[1],
         _ev_=urlencode(0,v),
         _ew_=caml_call2(Stdlib[28],cst$4,_ev_),
         _ex_=urlencode(0,n);
        return caml_call2(Stdlib[28],_ex_,_ew_)}
      var _eu_=caml_call2(Stdlib_list[17],_et_,l);
      return caml_call2(String[7],cst$5,_eu_)}
    function decode_arguments_js_string(s)
     {var
       arr=s.split(caml_jsstring_of_string(caml_call2(String[1],1,38))),
       len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _el_=idx$0 - 1 | 0,
             _em_=
              function(s)
               {function _er_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _es_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_es_]}
                var
                 index=
                  s.indexOf
                   (caml_jsstring_of_string(caml_call2(String[1],1,61)));
                if(caml_call2(symbol$5,index,0))
                 var _eq_=t37;
                else
                 var
                  _ep_=s.slice(index + 1 | 0),
                  _eq_=[0,s.slice(0,index),_ep_];
                return caml_call3(Optdef[7],_eq_,interrupt,_er_)},
             _en_=
              aux
               ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_em_),acc],_el_);
            return _en_}
          catch(_eo_)
           {_eo_ = caml_wrap_exception(_eo_);
            if(_eo_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _eo_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     url_re=
      new
       regExp_withFlags
       (caml_jsbytes_of_string(cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0)),
     file_re=new regExp_withFlags(caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee));
    function url_of_js_string(s)
     {function _d4_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_string_of_jsbytes(prot_string.toLowerCase());
        if
         (caml_string_notequal(match,cst_file$0)
          &&
          caml_string_notequal(match,cst_file$1))
         {var switch$0=0;
          if
           (caml_string_notequal(match,cst_http)
            &&
            caml_string_notequal(match,cst_http$0))
           {var switch$1=0;
            if
             (caml_string_notequal(match,cst_https)
              &&
              caml_string_notequal(match,cst_https$0))
             switch$1 = 1;
            if(! switch$1){var ssl=1;switch$0 = 2}}
          else
           switch$0 = 1;
          var switch$2=0;
          switch(switch$0)
           {case 1:var ssl=0;switch$2 = 1;break;
            case 0:break;
            default:switch$2 = 1}
          if(switch$2)
           {var
             _ec_=function(param){return caml_jsbytes_of_string(cst$7)},
             path_str=
              urldecode_js_string_string(caml_call2(Optdef[8],res[6],_ec_)),
             _ed_=function(param){return caml_jsbytes_of_string(cst$8)},
             _ee_=
              urldecode_js_string_string(caml_call2(Optdef[8],res[10],_ed_)),
             _ef_=function(param){return caml_jsbytes_of_string(cst$9)},
             _eg_=
              decode_arguments_js_string(caml_call2(Optdef[8],res[8],_ef_)),
             _eh_=path_of_path_string(path_str),
             _ei_=function(param){return caml_jsbytes_of_string(cst$10)},
             s=caml_string_of_jsbytes(caml_call2(Optdef[8],res[4],_ei_)),
             _ej_=
              caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
             url=
              [0,
               urldecode_js_string_string
                (caml_call2(Optdef[8],res[2],interrupt)),
               _ej_,
               _eh_,
               path_str,
               _eg_,
               _ee_],
             _ek_=ssl?[1,url]:[0,url];
            return [0,_ek_]}}
        throw Not_an_http_protocol}
      function _d5_(param)
       {function _d7_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _d__(param){return caml_jsbytes_of_string(cst$11)}
          var _d$_=caml_string_of_jsbytes(caml_call2(Optdef[8],res[6],_d__));
          function _ea_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _eb_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_ea_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_eb_,_d$_]]]}
        function _d8_(param){return 0}
        var _d9_=file_re.exec(s);
        return caml_call3(Opt[7],_d9_,_d8_,_d7_)}
      var _d6_=url_re.exec(s);
      return caml_call3(Opt[7],_d6_,_d5_,_d4_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _dr_=urlencode(0,frag),_ds_=caml_call2(Stdlib[28],cst$14,_dr_);
         else
          var _ds_=cst$21;
         if(args)
          var
           _dt_=encode_arguments(args),
           _du_=caml_call2(Stdlib[28],cst$15,_dt_);
         else
          var _du_=cst$20;
         var
          _dv_=caml_call2(Stdlib[28],_du_,_ds_),
          _dw_=function(x){return urlencode(0,x)},
          _dx_=caml_call2(Stdlib_list[17],_dw_,path),
          _dy_=caml_call2(String[7],cst$16,_dx_),
          _dz_=caml_call2(Stdlib[28],_dy_,_dv_),
          _dA_=caml_call2(Stdlib[28],cst$17,_dz_);
         if(80 === port)
          var _dB_=cst$18;
         else
          var
           _dF_=caml_call1(Stdlib[33],port),
           _dB_=caml_call2(Stdlib[28],cst$19,_dF_);
         var
          _dC_=caml_call2(Stdlib[28],_dB_,_dA_),
          _dD_=urlencode(0,host),
          _dE_=caml_call2(Stdlib[28],_dD_,_dC_);
         return caml_call2(Stdlib[28],cst_http$1,_dE_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _dG_=urlencode(0,frag$0),
           _dH_=caml_call2(Stdlib[28],cst$23,_dG_);
         else
          var _dH_=cst$30;
         if(args$0)
          var
           _dI_=encode_arguments(args$0),
           _dJ_=caml_call2(Stdlib[28],cst$24,_dI_);
         else
          var _dJ_=cst$29;
         var
          _dK_=caml_call2(Stdlib[28],_dJ_,_dH_),
          _dL_=function(x){return urlencode(0,x)},
          _dM_=caml_call2(Stdlib_list[17],_dL_,path$0),
          _dN_=caml_call2(String[7],cst$25,_dM_),
          _dO_=caml_call2(Stdlib[28],_dN_,_dK_),
          _dP_=caml_call2(Stdlib[28],cst$26,_dO_);
         if(443 === port$0)
          var _dQ_=cst$27;
         else
          var
           _dU_=caml_call1(Stdlib[33],port$0),
           _dQ_=caml_call2(Stdlib[28],cst$28,_dU_);
         var
          _dR_=caml_call2(Stdlib[28],_dQ_,_dP_),
          _dS_=urlencode(0,host$0),
          _dT_=caml_call2(Stdlib[28],_dS_,_dR_);
         return caml_call2(Stdlib[28],cst_https$1,_dT_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dV_=urlencode(0,frag$1),
           _dW_=caml_call2(Stdlib[28],cst$32,_dV_);
         else
          var _dW_=cst$36;
         if(args$1)
          var
           _dX_=encode_arguments(args$1),
           _dY_=caml_call2(Stdlib[28],cst$33,_dX_);
         else
          var _dY_=cst$35;
         var
          _dZ_=caml_call2(Stdlib[28],_dY_,_dW_),
          _d0_=function(x){return urlencode(0,x)},
          _d1_=caml_call2(Stdlib_list[17],_d0_,path$1),
          _d2_=caml_call2(String[7],cst$34,_d1_),
          _d3_=caml_call2(Stdlib[28],_d2_,_dZ_);
         return caml_call2(Stdlib[28],cst_file$2,_d3_)}}
    var _p_=caml_call1(Optdef[2],_g_.location);
    if(caml_call1(Optdef[5],_p_))
     var _q_=_g_.location;
    else
     var
      t40=function(param,_dq_){return 0},
      t39=function(param,_dp_){return 0},
      t38=function(param){return 0},
      _q_=
       {"href":"",
        "protocol":"",
        "host":"",
        "hostname":"",
        "port":"",
        "pathname":"",
        "search":"",
        "hash":"",
        "origin":t37,
        "reload":caml_js_wrap_meth_callback(t38),
        "replace":caml_js_wrap_meth_callback(t39),
        "assign":caml_js_wrap_meth_callback(t40)};
    var
     host=urldecode_js_string_string(_q_.hostname),
     protocol=urldecode_js_string_string(_q_.protocol),
     _r_=0,
     port=
      function(param)
        {try
          {var _dn_=[0,caml_int_of_string(caml_string_of_jsbytes(_q_.port))];
           return _dn_}
         catch(_do_)
          {_do_ = caml_wrap_exception(_do_);
           if(_do_[1] === Stdlib[7])return 0;
           throw _do_}}
       (_r_),
     path_string=urldecode_js_string_string(_q_.pathname),
     path=path_of_path_string(path_string),
     _s_=_q_.search.charAt(0) === "?"?_q_.search.slice(1):_q_.search,
     arguments$0=decode_arguments_js_string(_s_);
    function get_fragment(param)
     {function _dj_(res){return caml_string_of_jsstring(res[1])}
      function _dk_(param){return cst$37}
      var _dl_=new regExp_withFlags("#(.*)"),_dm_=_q_.href.match(_dl_);
      return caml_call3(Opt[7],_dm_,_dk_,_dj_)}
    function set_fragment(s)
     {return _q_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_q_.href)}
    function set$0(u)
     {return _q_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_q_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1658,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1659,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[60],name);
      caml_call2(Stdlib[66],oc,content);
      return caml_call1(Stdlib[76],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_string_of_jsbytes(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    var unmount=runtime.caml_unmount;
    if(caml_call2(String[38],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _cm_=caml_call2(Stdlib[28],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Stdlib[28],s,_cm_);
    var
     _t_=runtime.caml_create_file,
     _u_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_di_){return runtime.caml_list_mount_point(_di_)},
       unmount,
       mount,
       _u_,
       _t_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1660,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var resizeObserver=Unsafe[1].ResizeObserver;
    function is_supported$0(param)
     {return caml_call1(Optdef[5],resizeObserver)}
    function observe(node,f,box,param)
     {var obs=new resizeObserver(caml_js_wrap_callback(f));
      if(box)
       {var box$0=box[1],opts={};opts.box = box$0;obs.observe(node,opts)}
      else
       obs.observe(node);
      return obs}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,resizeObserver,is_supported$0,observe];
    caml_register_global
     (1661,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    function empty_mutation_observer_init(param){return {}}
    var mutationObserver=Unsafe[1].MutationObserver;
    function is_supported$1(param)
     {return caml_call1(Optdef[5],mutationObserver)}
    function observe$0
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var obs=new mutationObserver(caml_js_wrap_callback(f)),cfg={};
      opt_iter(child_list,function(v){return cfg.childList = v});
      opt_iter(attributes,function(v){return cfg.attributes = v});
      opt_iter(character_data,function(v){return cfg.characterData = v});
      opt_iter(subtree,function(v){return cfg.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return cfg.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return cfg.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return cfg.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Stdlib_array[12],l))});
      obs.observe(node,cfg);
      return obs}
    var
     Js_of_ocaml_MutationObserver=
      [0,
       empty_mutation_observer_init,
       mutationObserver,
       is_supported$1,
       observe$0];
    caml_register_global
     (1662,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var obj=Unsafe[1].Object;
    function create$1(param){return new obj()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       key_array=Unsafe[1].Object.keys(t),
       res=[0,0],
       _de_=key_array.length - 1 | 0,
       _dd_=0;
      if(! (_de_ < 0))
       {var i=_dd_;
        for(;;)
         {var
           _df_=function(param){return caml_call1(Stdlib[2],cst_Jstable_keys)},
           key=caml_call2(Optdef[8],key_array[i],_df_),
           _dg_=res[1];
          res[1] = [0,key.substring(0,key.length - 1 | 0),_dg_];
          var _dh_=i + 1 | 0;
          if(_de_ !== i){var i=_dh_;continue}
          break}}
      return caml_call1(Stdlib_list[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$1,add$0,remove,find,keys];
    caml_register_global(1663,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var json=Unsafe[1].JSON;
    function reviver(this$0,key,value)
     {if(typeof value == typeof "foo")return caml_string_of_jsbytes(value);
      if
       (value instanceof array_length
        &&
        4
        ===
        value.length
        &&
        255
        ===
        value[0])
       return runtime.caml_int64_create_lo_mi_hi(value[1],value[2],value[3]);
      return value}
    var input_reviver=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(s){return json.parse(s,input_reviver)}
    var
     mlString_constr=dummy_string.constructor,
     mlInt64_constr=dummy_int64.constructor;
    function output_reviver(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value instanceof mlInt64_constr
                ?caml_js_from_array([0,255,value.lo,value.mi,value.hi])
                :value}
    function output(obj){return json.stringify(obj,output_reviver)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1664,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _dc_=param;
      if(74 <= _dc_)
       {if(111 <= _dc_)
         switch(_dc_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_dc_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _dc_)
       switch(_dc_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_dc_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      var _db_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color_name);
      throw [0,Stdlib[6],_db_]}
    function rgb_of_name(param)
     {var _da_=param;
      if(74 <= _da_)
       {if(111 <= _da_)
         switch(_da_)
          {case 111:return _bo_;
           case 112:return _bp_;
           case 113:return _bq_;
           case 114:return _br_;
           case 115:return _bs_;
           case 116:return _bt_;
           case 117:return _bu_;
           case 118:return _bv_;
           case 119:return _bw_;
           case 120:return _bx_;
           case 121:return _by_;
           case 122:return _bz_;
           case 123:return _bA_;
           case 124:return _bB_;
           case 125:return _bC_;
           case 126:return _bD_;
           case 127:return _bE_;
           case 128:return _bF_;
           case 129:return _bG_;
           case 130:return _bH_;
           case 131:return _bI_;
           case 132:return _bJ_;
           case 133:return _bK_;
           case 134:return _bL_;
           case 135:return _bM_;
           case 136:return _bN_;
           case 137:return _bO_;
           case 138:return _bP_;
           case 139:return _bQ_;
           case 140:return _bR_;
           case 141:return _bS_;
           case 142:return _bT_;
           case 143:return _bU_;
           case 144:return _bV_;
           case 145:return _bW_;
           default:return _bX_}
        switch(_da_)
         {case 74:return _aP_;
          case 75:return _aQ_;
          case 76:return _aR_;
          case 77:return _aS_;
          case 78:return _aT_;
          case 79:return _aU_;
          case 80:return _aV_;
          case 81:return _aW_;
          case 82:return _aX_;
          case 83:return _aY_;
          case 84:return _aZ_;
          case 85:return _a0_;
          case 86:return _a1_;
          case 87:return _a2_;
          case 88:return _a3_;
          case 89:return _a4_;
          case 90:return _a5_;
          case 91:return _a6_;
          case 92:return _a7_;
          case 93:return _a8_;
          case 94:return _a9_;
          case 95:return _a__;
          case 96:return _a$_;
          case 97:return _ba_;
          case 98:return _bb_;
          case 99:return _bc_;
          case 100:return _bd_;
          case 101:return _be_;
          case 102:return _bf_;
          case 103:return _bg_;
          case 104:return _bh_;
          case 105:return _bi_;
          case 106:return _bj_;
          case 107:return _bk_;
          case 108:return _bl_;
          case 109:return _bm_;
          default:return _bn_}}
      if(37 <= _da_)
       switch(_da_)
        {case 37:return _ae_;
         case 38:return _af_;
         case 39:return _ag_;
         case 40:return _ah_;
         case 41:return _ai_;
         case 42:return _aj_;
         case 43:return _ak_;
         case 44:return _al_;
         case 45:return _am_;
         case 46:return _an_;
         case 47:return _ao_;
         case 48:return _ap_;
         case 49:return _aq_;
         case 50:return _ar_;
         case 51:return _as_;
         case 52:return _at_;
         case 53:return _au_;
         case 54:return _av_;
         case 55:return _aw_;
         case 56:return _ax_;
         case 57:return _ay_;
         case 58:return _az_;
         case 59:return _aA_;
         case 60:return _aB_;
         case 61:return _aC_;
         case 62:return _aD_;
         case 63:return _aE_;
         case 64:return _aF_;
         case 65:return _aG_;
         case 66:return _aH_;
         case 67:return _aI_;
         case 68:return _aJ_;
         case 69:return _aK_;
         case 70:return _aL_;
         case 71:return _aM_;
         case 72:return _aN_;
         default:return _aO_}
      switch(_da_)
       {case 0:return _v_;
        case 1:return _w_;
        case 2:return _x_;
        case 3:return _y_;
        case 4:return _z_;
        case 5:return _A_;
        case 6:return _B_;
        case 7:return _C_;
        case 8:return _D_;
        case 9:return _E_;
        case 10:return _F_;
        case 11:return _G_;
        case 12:return _H_;
        case 13:return _I_;
        case 14:return _J_;
        case 15:return _K_;
        case 16:return _L_;
        case 17:return _M_;
        case 18:return _N_;
        case 19:return _O_;
        case 20:return _P_;
        case 21:return _Q_;
        case 22:return _R_;
        case 23:return _S_;
        case 24:return _T_;
        case 25:return _U_;
        case 26:return _V_;
        case 27:return _W_;
        case 28:return _X_;
        case 29:return _Y_;
        case 30:return _Z_;
        case 31:return ___;
        case 32:return _$_;
        case 33:return _aa_;
        case 34:return _ab_;
        case 35:return _ac_;
        default:return _ad_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_printf[4],_bY_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_printf[4],_bZ_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_printf[4],_b0_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_printf[4],_b1_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_printf[4],_b2_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_printf[4],_b3_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _c8_=caml_call2(symbol$5,i,0),
         _c9_=_c8_ || caml_call2(symbol$9,i,255);
        if(_c9_)
         {var
           _c__=caml_call1(Stdlib[33],i),
           _c$_=caml_call2(Stdlib[28],_c__,cst_is_out_of_valid_range);
          throw [0,Stdlib[6],_c$_]}
        return _c9_}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_printf[4],_b4_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       rgb_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d)),
       rgb_pct_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0)),
       rgba_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d)),
       rgba_pct_re=
        new
         regExp_withFlags
         (caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0)),
       hsl_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d)),
       hsla_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d));
      if
       (!
        (rgb_re.test(s) | 0)
        &&
        !
        (rgba_re.test(s) | 0)
        &&
        !
        (rgb_pct_re.test(s) | 0)
        &&
        !
        (rgba_pct_re.test(s) | 0)
        &&
        !
        (hsl_re.test(s) | 0)
        &&
        !
        (hsla_re.test(s) | 0))
       {var _c5_=caml_string_of_jsstring(s);
        if(caml_call2(Stdlib_list[33],_c5_,_b5_))return s;
        var
         _c6_=caml_string_of_jsstring(s),
         _c7_=caml_call2(Stdlib[28],_c6_,cst_is_not_a_valid_color);
        throw [0,Stdlib[6],_c7_]}
      return s}
    function js(c)
     {if(0 === c[0])
       {var n=c[1];return caml_jsstring_of_string(string_of_name(n))}
      return caml_jsstring_of_string(string_of_t(c))}
    function ml(c)
     {var s=caml_string_of_jsstring(c);
      try
       {var _cS_=[0,name_of_string(s)];return _cS_}
      catch(_cT_)
       {_cT_ = caml_wrap_exception(_cT_);
        if(_cT_[1] === Stdlib[6])
         {var
           fail=
            function(param)
             {var _c4_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color$0);
              throw [0,Stdlib[6],_c4_]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _c2_=caml_int_of_string(i);return _c2_}
                catch(_c3_)
                 {_c3_ = caml_wrap_exception(_c3_);
                  if(_c3_[1] === Stdlib[6])
                   var s=_c3_[2];
                  else
                   {if(_c3_[1] !== Stdlib[7])throw _c3_;var s=_c3_[2]}
                  var
                   _cZ_=caml_call2(Stdlib[28],cst$39,s),
                   _c0_=caml_call2(Stdlib[28],i,_cZ_),
                   _c1_=caml_call2(Stdlib[28],cst_color_conversion_error,_c0_);
                  throw [0,Stdlib[6],_c1_]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cX_=caml_float_of_string(f);return _cX_}
              catch(_cY_)
               {_cY_ = caml_wrap_exception(_cY_);
                if(_cY_[1] === Stdlib[6])
                 var s=_cY_[2];
                else
                 {if(_cY_[1] !== Stdlib[7])throw _cY_;var s=_cY_[2]}
                var
                 _cU_=caml_call2(Stdlib[28],cst$40,s),
                 _cV_=caml_call2(Stdlib[28],f,_cU_),
                 _cW_=caml_call2(Stdlib[28],cst_color_conversion_error$0,_cV_);
                throw [0,Stdlib[6],_cW_]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cA_=match$0[1];
              if(! caml_string_notequal(_cA_,cst_rgb))
               {if(alpha)return fail(0);
                var _cE_=i_of_s_o(blue),_cF_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cF_,_cE_]]}
              if(! caml_string_notequal(_cA_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cB_=f_of_s(a),
                   _cC_=i_of_s_o(blue),
                   _cD_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cD_,_cC_,_cB_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cG_=match$2[1];
              if(! caml_string_notequal(_cG_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cK_=i_of_s_o(blue$0),_cL_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cL_,_cK_]]}
              if(! caml_string_notequal(_cG_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cH_=f_of_s(a$0),
                   _cI_=i_of_s_o(blue$0),
                   _cJ_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cJ_,_cI_,_cH_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cM_=match$4[1];
              if(! caml_string_notequal(_cM_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cQ_=i_of_s_o(blue$1),_cR_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cR_,_cQ_]]}
              if(! caml_string_notequal(_cM_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cN_=f_of_s(a$1),
                   _cO_=i_of_s_o(blue$1),
                   _cP_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cP_,_cO_,_cN_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cT_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_printf[4],_b6_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_printf[4],_b7_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_printf[4],_b8_,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_printf[4],_b9_,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_printf[4],_b__,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_printf[4],_b$_,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_printf[4],_ca_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_printf[4],_cb_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_printf[4],_cc_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_printf[4],_cd_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_printf[4],_ce_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_printf[4],_cf_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_printf[4],_cg_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_printf[4],_ch_,f$12,cst_pc)}}
    function js$0(t){return caml_jsstring_of_string(string_of_t$0(t))}
    function ml$0(t)
     {var s=caml_string_of_jsstring(t);
      if(caml_call2(String[38],s,cst_0$0))return 0;
      function fail(param)
       {var _cz_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length);
        throw [0,Stdlib[6],_cz_]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cx_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cw_=caml_call2(Stdlib[28],cst_length_conversion_error,s$0);
              throw [0,Stdlib[6],_cw_]}
            throw exn}
          var f$0=_cx_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cy_=match$1[1],switch$0=caml_string_compare(_cy_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cy_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cy_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cy_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cy_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cy_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cy_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cy_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cy_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cy_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cy_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cy_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cy_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cy_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_printf[4],_ci_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_printf[4],_cj_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_printf[4],_ck_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_printf[4],_cl_,f$2,cst_turns)}}
    function js$1(t){return caml_jsstring_of_string(string_of_t$1(t))}
    function ml$1(j)
     {var s=caml_string_of_jsstring(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {var _cv_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length$0);
        throw [0,Stdlib[6],_cv_]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _ct_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cs_=caml_call2(Stdlib[28],cst_length_conversion_error$0,s$0);
              throw [0,Stdlib[6],_cs_]}
            throw exn}
          var f$0=_ct_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cu_=match$1[1];
          if(! caml_string_notequal(_cu_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_cu_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_cu_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_cu_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1665,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cr_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cr_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1666,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     xmlns="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGErr,caml_fresh_oo_id(0)];
    function createElement$0(doc,name)
     {return doc.createElementNS
              ("http://www.w3.org/2000/svg",caml_jsstring_of_string(name))}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$1=Unsafe[1].document;
    function getElementById$0(id)
     {function _co_(e){if(e instanceof svg_element)return e;throw Stdlib[8]}
      function _cp_(param){throw Stdlib[8]}
      var _cq_=Unsafe[1].document.getElementById(caml_jsstring_of_string(id));
      return caml_call3(Opt[7],_cq_,_cp_,_co_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var _cn_=caml_jsstring_of_string(tag);
      return e.tagName.toLowerCase() === _cn_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       xmlns,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$1,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1667,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1668,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1669,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$2(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$2];
    caml_register_global
     (1670,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":false$0,
              "numeric":false$0,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t37,
              "hour12":t37,
              "hourCycle":t37,
              "formatMatcher":"best fit",
              "weekday":t37,
              "era":t37,
              "year":t37,
              "month":t37,
              "day":t37,
              "hour":t37,
              "minute":t37,
              "second":t37,
              "timeZoneName":t37}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t37,
              "currencyDisplay":t37,
              "useGrouping":true$0,
              "minimumIntegerDigits":t37,
              "minimumFractionDigits":t37,
              "maximumFractionDigits":t37,
              "minimumSignificantDigits":t37,
              "maximumSignificantDigits":t37}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$3(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$3];
    caml_register_global(1671,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0];
    caml_register_global(1672,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 ".mechanic.eobjs/byte/dune__exe__Mechanic.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_mul=runtime.caml_mul,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_R_initialiser_compl_tement=
      caml_string_of_jsbytes
       ("R\xc3\xa9initialiser compl\xc3\xa8tement le formulaire ?"),
     cst$7=caml_string_of_jsbytes(""),
     cst_nom_prenom$0=caml_string_of_jsbytes("nom_prenom"),
     cst$8=caml_string_of_jsbytes(""),
     cst_arrivee$0=caml_string_of_jsbytes("arrivee"),
     cst$9=caml_string_of_jsbytes(""),
     cst_depart$0=caml_string_of_jsbytes("depart"),
     cst$5=caml_string_of_jsbytes("\xc2\xa0\xe2\x82\xac"),
     cst_qte=caml_string_of_jsbytes("_qte"),
     cst$6=caml_string_of_jsbytes("\xc2\xa0\xe2\x82\xac"),
     cst_total=caml_string_of_jsbytes("total"),
     cst_benvoi=caml_string_of_jsbytes("benvoi"),
     cst_subject_R_servation_linge_=
      caml_string_of_jsbytes
       ("?subject=R\xc3\xa9servation linge Dubuval&body="),
     cst_mailto=caml_string_of_jsbytes("mailto:"),
     cst$3=caml_string_of_jsbytes(", "),
     cst$4=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(" : "),
     cst_nom_prenom=caml_string_of_jsbytes("nom_prenom"),
     cst_arrivee=caml_string_of_jsbytes("arrivee"),
     cst_depart=caml_string_of_jsbytes("depart"),
     cst$1=caml_string_of_jsbytes("_"),
     cst$0=caml_string_of_jsbytes("_"),
     cst=caml_string_of_jsbytes(""),
     cst_compute=caml_string_of_jsbytes("compute"),
     cst_reset_form=caml_string_of_jsbytes("reset_form"),
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib=global_data.Stdlib,
     Inventaire_linge=global_data.Inventaire_linge,
     Stdlib_fun=global_data.Stdlib__fun,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     _g_=
      [0,
       [11,caml_string_of_jsbytes(" ("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes(" (%s)")],
     _h_=
      [0,
       [11,
        caml_string_of_jsbytes("\xe2\x80\x94 "),
        [4,
         0,
         0,
         0,
         [12,32,[2,0,[2,0,[12,37,[11,caml_string_of_jsbytes("0A"),0]]]]]]],
       caml_string_of_jsbytes("\xe2\x80\x94 %d %s%s%%0A")],
     _f_=[0,0,0],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("----- R\xc3\xa9servation linge Dubuval, Les terrasses des Choseaux, Appartement B6 -----"),
        [12,37,[11,caml_string_of_jsbytes("0A"),0]]],
       caml_string_of_jsbytes
        ("----- R\xc3\xa9servation linge Dubuval, Les terrasses des Choseaux, Appartement B6 -----%%0A")],
     _c_=
      [0,
       [11,
        caml_string_of_jsbytes("Locataire : "),
        [2,0,[12,37,[11,caml_string_of_jsbytes("0A"),0]]]],
       caml_string_of_jsbytes("Locataire : %s%%0A")],
     _d_=
      [0,
       [11,
        caml_string_of_jsbytes("Date d\xe2\x80\x99arriv\xc3\xa9e : "),
        [2,0,[12,37,[11,caml_string_of_jsbytes("0A"),0]]]],
       caml_string_of_jsbytes("Date d\xe2\x80\x99arriv\xc3\xa9e : %s%%0A")],
     _e_=
      [0,
       [11,
        caml_string_of_jsbytes("Date de d\xc3\xa9part : "),
        [2,0,[12,37,[11,caml_string_of_jsbytes("0A"),0]]]],
       caml_string_of_jsbytes("Date de d\xc3\xa9part : %s%%0A")],
     _i_=
      [0,
       [12,
        37,
        [11,
         caml_string_of_jsbytes("0ATotal : "),
         [4,
          0,
          0,
          0,
          [11,
           caml_string_of_jsbytes(" \xe2\x82\xac"),
           [12,37,[11,caml_string_of_jsbytes("0A"),0]]]]]],
       caml_string_of_jsbytes("%%0ATotal : %d \xe2\x82\xac%%0A")];
    function set_string_input_by_id(nm,v)
     {var
       match=
        caml_call2(Js_of_ocaml_Dom_html[5],nm,Js_of_ocaml_Dom_html[117][33]);
      if(match)
       {var inp=match[1];return inp.value = caml_jsstring_of_string(v)}
      return 0}
    function read_string_input_by_id(nm)
     {var
       match=
        caml_call2(Js_of_ocaml_Dom_html[5],nm,Js_of_ocaml_Dom_html[117][33]);
      if(match){var inp=match[1];return caml_string_of_jsstring(inp.value)}
      return cst}
    function zero_int_input_by_id(nm)
     {var
       match=
        caml_call2(Js_of_ocaml_Dom_html[5],nm,Js_of_ocaml_Dom_html[117][50]);
      if(match)
       {var inp=match[1];
        return inp.value = caml_jsstring_of_string(caml_call1(Stdlib[33],0))}
      return 0}
    function read_int_input_by_id(nm)
     {var
       match=
        caml_call2(Js_of_ocaml_Dom_html[5],nm,Js_of_ocaml_Dom_html[117][50]);
      if(match)
       {var inp=match[1];
        return runtime.caml_int_of_string(caml_string_of_jsstring(inp.value))}
      return 0}
    function set_td_by_id(nm,v)
     {var
       match=
        caml_call2(Js_of_ocaml_Dom_html[5],nm,Js_of_ocaml_Dom_html[117][54]);
      if(match)
       {var td=match[1];return td.innerHTML = caml_jsstring_of_string(v)}
      return 0}
    function field_id_by_fourniture(f)
     {var _ae_=f[4];
      function _af_(param)
       {var
         p=param[1],
         _ag_=caml_call1(Inventaire_linge[4],p),
         _ah_=caml_call2(Stdlib[28],cst$0,_ag_);
        return caml_call2(Stdlib[28],f[1],_ah_)}
      return caml_call2(Stdlib_list[17],_af_,_ae_)}
    function field_id_and_piece_by_fournitu(f)
     {var _$_=f[4];
      function _aa_(param)
       {var
         p=param[1],
         _ab_=caml_call1(Inventaire_linge[5],p),
         _ac_=caml_call1(Inventaire_linge[4],p),
         _ad_=caml_call2(Stdlib[28],cst$1,_ac_);
        return [0,caml_call2(Stdlib[28],f[1],_ad_),_ab_]}
      return caml_call2(Stdlib_list[17],_aa_,_$_)}
    var
     _a_=
      caml_call2(Stdlib_list[17],field_id_by_fourniture,Inventaire_linge[6]),
     all_names=caml_call1(Stdlib_list[13],_a_);
    function email_body(param)
     {var b=caml_call1(Stdlib_buffer[1],500);
      caml_call2(Stdlib_printf[5],b,_b_);
      var _D_=read_string_input_by_id(cst_nom_prenom);
      caml_call3(Stdlib_printf[5],b,_c_,_D_);
      var _E_=read_string_input_by_id(cst_arrivee);
      caml_call3(Stdlib_printf[5],b,_d_,_E_);
      var _F_=read_string_input_by_id(cst_depart);
      caml_call3(Stdlib_printf[5],b,_e_,_F_);
      var _G_=Inventaire_linge[6];
      function _H_(f)
       {var _U_=field_id_and_piece_by_fournitu(f);
        function _V_(param,_X_)
         {var
           short$0=_X_[2],
           field_id=_X_[1],
           detail=param[2],
           s=param[1],
           q=read_int_input_by_id(field_id);
          if(0 < q)
           var
            _Y_=caml_call1(Stdlib[33],q),
            _Z_=caml_call2(Stdlib[28],cst$2,_Y_),
            ___=[0,caml_call2(Stdlib[28],short$0,_Z_),detail];
          else
           var ___=detail;
          return [0,s + q | 0,___]}
        var param=caml_call3(Stdlib_list[22],_V_,_f_,_U_),_W_=param[1];
        if(0 === _W_)return 0;
        var detail=param[2];
        return [0,[0,f[2],_W_,detail]]}
      var _I_=caml_call2(Stdlib_list[20],_H_,_G_);
      function _J_(param)
       {var detail=param[3],q=param[2],descr=param[1];
        if(detail)
         var
          _S_=caml_call2(Stdlib_string[7],cst$3,detail),
          _T_=caml_call2(Stdlib_printf[4],_g_,_S_);
        else
         var _T_=cst$4;
        return caml_call5(Stdlib_printf[5],b,_h_,q,descr,_T_)}
      caml_call2(Stdlib_list[15],_J_,_I_);
      var _K_=Inventaire_linge[6],_L_=0;
      function _M_(total,f)
       {var _O_=field_id_by_fourniture(f),_P_=0;
        function _Q_(s,field_id)
         {return s + read_int_input_by_id(field_id) | 0}
        var _R_=caml_call3(Stdlib_list[22],_Q_,_P_,_O_);
        return total + caml_mul(f[3],_R_) | 0}
      var _N_=caml_call3(Stdlib_list[22],_M_,_L_,_K_);
      caml_call3(Stdlib_printf[5],b,_i_,_N_);
      return caml_call1(Stdlib_buffer[2],b)}
    function update_msg(param)
     {var
       match=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_benvoi,Js_of_ocaml_Dom_html[117][2]);
      if(match)
       {var
         a=match[1],
         _A_=email_body(0),
         _B_=caml_call2(Stdlib[28],cst_subject_R_servation_linge_,_A_),
         _C_=caml_call2(Stdlib[28],Inventaire_linge[2],_B_);
        return a.href
               =
               caml_jsstring_of_string(caml_call2(Stdlib[28],cst_mailto,_C_))}
      return 0}
    function compute(param)
     {var _j_=Inventaire_linge[6];
      function _k_(f)
       {var _u_=field_id_by_fourniture(f),_v_=0;
        function _w_(s,field_id)
         {return s + read_int_input_by_id(field_id) | 0}
        var
         qte=caml_call3(Stdlib_list[22],_w_,_v_,_u_),
         _x_=caml_call1(Stdlib[33],caml_mul(qte,f[3])),
         _y_=caml_call2(Stdlib[28],_x_,cst$5);
        set_td_by_id(f[1],_y_);
        var _z_=caml_call1(Stdlib[33],qte);
        return set_td_by_id(caml_call2(Stdlib[28],f[1],cst_qte),_z_)}
      caml_call2(Stdlib_list[15],_k_,_j_);
      var _l_=Inventaire_linge[6],_m_=0;
      function _n_(total,f)
       {var _q_=field_id_by_fourniture(f),_r_=0;
        function _s_(s,field_id)
         {return s + read_int_input_by_id(field_id) | 0}
        var _t_=caml_call3(Stdlib_list[22],_s_,_r_,_q_);
        return total + caml_mul(f[3],_t_) | 0}
      var
       _o_=caml_call3(Stdlib_list[22],_n_,_m_,_l_),
       _p_=caml_call1(Stdlib[33],_o_);
      set_td_by_id(cst_total,caml_call3(Stdlib_fun[2],Stdlib[28],cst$6,_p_));
      return update_msg(0)}
    function reset_form(param)
     {var
       doit=
        Js_of_ocaml_Dom_html[8].confirm
         (caml_jsstring_of_string(cst_R_initialiser_compl_tement))
        |
        0;
      return doit
              ?(set_string_input_by_id(cst_nom_prenom$0,cst$7),
                set_string_input_by_id(cst_arrivee$0,cst$8),
                set_string_input_by_id(cst_depart$0,cst$9),
                caml_call2(Stdlib_list[15],zero_int_input_by_id,all_names),
                compute(0))
              :doit}
    caml_call2(Js_of_ocaml_Js[48],cst_compute,compute);
    caml_call2(Js_of_ocaml_Js[48],cst_reset_form,reset_form);
    var
     Dune_exe_Mechanic=
      [0,
       set_string_input_by_id,
       read_string_input_by_id,
       zero_int_input_by_id,
       read_int_input_by_id,
       set_td_by_id,
       field_id_by_fourniture,
       field_id_and_piece_by_fournitu,
       all_names,
       email_body,
       update_msg,
       compute,
       reset_form];
    runtime.caml_register_global(49,Dune_exe_Mechanic,"Dune__exe__Mechanic");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJtZWNoYW5pYy5iYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJjYW1sX2ludDY0X2lzX3plcm8iLCJ4IiwiY2FtbF9zdHJfcmVwZWF0IiwibiIsInMiLCJyIiwibCIsImNhbWxfaW50NjRfb2Zmc2V0IiwiTWF0aCIsImNhbWxfcmFpc2VfY29uc3RhbnQiLCJ0YWciLCJjYW1sX2dsb2JhbF9kYXRhIiwiY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSIsIk1sSW50NjQiLCJsbyIsIm1pIiwiaGkiLCJ0aGlzIiwieGhpIiwiaCIsInNpZ24iLCJvZmZzZXQiLCJtb2R1bHVzIiwiZGl2aXNvciIsInF1b3RpZW50IiwieSIsInEiLCJjYW1sX2ludDY0X29mX2ludDMyIiwiY2FtbF9pbnQ2NF90b19pbnQzMiIsImNhbWxfaW50NjRfaXNfbmVnYXRpdmUiLCJjYW1sX2ludDY0X25lZyIsImNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyIsImEiLCJpIiwibGVuIiwiZiIsIlN0cmluZyIsIm51bGwiLCJjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIiwiY2FtbF9qc2J5dGVzX29mX3N0cmluZyIsImNhbWxfcmFpc2Vfd2l0aF9hcmciLCJhcmciLCJqc29vX2lzX2FzY2lpIiwiY2FtbF91dGYxNl9vZl91dGY4IiwiYiIsInQiLCJjIiwiYzEiLCJjMiIsInYiLCJqIiwiTWxCeXRlcyIsImNvbnRlbnRzIiwibGVuZ3RoIiwiY29udGVudCIsImNhbWxfYnl0ZXNfb2ZfanNieXRlcyIsImNhbWxfc3RyaW5nX29mX2pzYnl0ZXMiLCJjYW1sX3JhaXNlX3dpdGhfc3RyaW5nIiwibXNnIiwiY2FtbF9pbnZhbGlkX2FyZ3VtZW50IiwiY2FtbF9wYXJzZV9mb3JtYXQiLCJmbXQiLCJjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nIiwicmF3YnVmZmVyIiwiYnVmZmVyIiwiY2FtbF9pbnQ2NF9mb3JtYXQiLCJ3YmFzZSIsImN2dGJsIiwicCIsImNhbWxfZXhwbTFfZmxvYXQiLCJ6IiwiY2FtbF9qc3N0cmluZ19vZl9zdHJpbmciLCJqb29fZ2xvYmFsX29iamVjdCIsImNhbWxfY3VycmVudF9kaXIiLCJjYW1sX21ha2VfcGF0aCIsIm5hbWUiLCJjb21wIiwibmNvbXAiLCJjYW1sX2lzX21sX2J5dGVzIiwiY2FtbF9pc19tbF9zdHJpbmciLCJjYW1sX2J5dGVzX29mX2FycmF5IiwiY2FtbF9ieXRlc19vZl9zdHJpbmciLCJjYW1sX3V0Zjhfb2ZfdXRmMTYiLCJkIiwiY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyIsImNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIiwiY2FtbF9yYWlzZV9zeXNfZXJyb3IiLCJjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSIsImNhbWxfYnl0ZXNfYm91bmRfZXJyb3IiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2J5dGVzX2dldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkiLCJBcnJheSIsImNhbWxfYmxpdF9ieXRlcyIsInMxIiwiaTEiLCJzMiIsImkyIiwiY2FtbF9ibGl0X3N0cmluZyIsImUiLCJNbEZpbGUiLCJNbEZha2VGaWxlIiwib2xkIiwiYnVmIiwicG9zIiwiY2xlbiIsIm5ld19zdHIiLCJvbGRfZGF0YSIsIk1sRmFrZURldmljZSIsInJvb3QiLCJyZXMiLCJuYW1lX3NsYXNoIiwiUmVnRXhwIiwic2VlbiIsIm0iLCJvayIsImZpbGUiLCJieXRlcyIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX2FycmF5X29mX3N0cmluZyIsImNhbWxfYXJyYXlfb2ZfYnl0ZXMiLCJjYW1sX2J5dGVzX3Vuc2FmZV9zZXQiLCJjYW1sX2J5dGVzX3NldCIsIk1sTm9kZUZpbGUiLCJmZCIsInJlcXVpcmUiLCJlcnIiLCJidWZfb2Zmc2V0IiwiTWxOb2RlRGV2aWNlIiwiY29uc3RzIiwia2V5IiwibyIsImNhbWxfcm9vdCIsImZzX25vZGVfc3VwcG9ydGVkIiwianNvb19tb3VudF9wb2ludCIsInJlc29sdmVfZnNfZGV2aWNlIiwicGF0aCIsImNhbWxfc3lzX2lzX2RpcmVjdG9yeSIsImNhbWxfcmFpc2Vfbm90X2ZvdW5kIiwiY2FtbF9zeXNfZ2V0ZW52IiwiZyIsInVuZGVmaW5lZCIsInNoaWZ0X3JpZ2h0X25hdCIsIm5hdDEiLCJvZnMxIiwibGVuMSIsIm5hdDIiLCJvZnMyIiwibmJpdHMiLCJ3cmFwIiwiY2FtbF9uYW1lZF92YWx1ZXMiLCJjYW1sX25hbWVkX3ZhbHVlIiwibm0iLCJjYW1sX2dyX3N0YXRlIiwiY2FtbF9ncl9zdGF0ZV9nZXQiLCJjYW1sX2dyX3BvaW50X2NvbG9yIiwiaW0iLCJNbE9iamVjdFRhYmxlIiwiTmFpdmVMb29rdXAiLCJvYmpzIiwiY2FtbF9mYWlsd2l0aCIsImNhbWxfc3lzX3JlbmFtZSIsIm9fcm9vdCIsIm5fcm9vdCIsImNhbWxfbG9nMTBfZmxvYXQiLCJjYW1sX3J1bnRpbWVfd2FybmluZ3MiLCJjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIiwiYm9vbCIsImNhbWxfY2xhc3NpZnlfZmxvYXQiLCJpc0Zpbml0ZSIsImlzTmFOIiwiY2FtbF9tbF9yZWZpbGxfaW5wdXQiLCJjaGFuIiwic3RyIiwic3RyX2xlbiIsImNhbWxfbWxfY2hhbm5lbHMiLCJjYW1sX21sX21heV9yZWZpbGxfaW5wdXQiLCJjaGFuaWQiLCJjYW1sX2FycmF5X2JvdW5kX2Vycm9yIiwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUiLCJjYW1sX2djX21pbm9yIiwiY2FtbF9pbnQ2NF9vZl9ieXRlcyIsImNhbWxfYmFfdWludDhfZ2V0NjQiLCJiYSIsImkwIiwib2ZzIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsImI2IiwiYjciLCJiOCIsImNhbWxfaW50NjRfdG9fYnl0ZXMiLCJjYW1sX2ludDY0X21hcnNoYWwiLCJ3cml0ZXIiLCJzaXplcyIsImNhbWxfYmFfbnVtX2RpbXMiLCJjYW1sX3JldHVybl9leG5fY29uc3RhbnQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jcmVhdGVfZmlsZSIsImNhbWxfZnNfaW5pdCIsInRtcCIsImNhbWxfc2V0X3BhcnNlcl90cmFjZSIsImNhbWxfbGlzdF9vZl9qc19hcnJheSIsInVuaXhfZ2V0dGltZW9mZGF5IiwiRGF0ZSIsImNhbWxfbXVsIiwiY2FtbF9oYXNoX21peF9pbnQiLCJudW1fZGlnaXRzX25hdCIsIm5hdCIsImNhbWxfaGFzaF9uYXQiLCJjYW1sX2NhbGxfZ2VuIiwiYXJncyIsImFyZ3NMZW4iLCJleHRyYV9hcmdzIiwiYXJndW1lbnRzIiwibmFyZ3MiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzIiwiY2FtbF9zeXNfY2hkaXIiLCJkaXIiLCJjYW1sX2djX2NvdW50ZXJzIiwiY2FtbF9ncl9zeW5jaHJvbml6ZSIsImxvZzJfb2siLCJqc29vX2Zsb29yX2xvZzIiLCJJbmZpbml0eSIsImNhbWxfaW50MzJfYml0c19vZl9mbG9hdCIsImZsb2F0MzJhIiwiaW50MzJhIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkiLCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQiLCJleHAiLCJrIiwicjMiLCJyMiIsInIxIiwiY2FtbF9iYV9zZXJpYWxpemUiLCJzeiIsImNvbXBsZXgiLCJjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50Iiwia2luZCIsImNhbWxfYmFfY3JlYXRlX2J1ZmZlciIsInNpemUiLCJ2aWV3IiwiZGF0YSIsImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyIsImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyIsIk5hTiIsImNhbWxfYmFfZ2V0X3NpemUiLCJkaW1zIiwibl9kaW1zIiwiY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkiLCJjYW1sX2ludDY0X2hpMzIiLCJjYW1sX2ludDY0X2xvMzIiLCJNbF9CaWdhcnJheSIsImxheW91dCIsInJlIiwidG90YWwiLCJrMSIsImsyIiwiTWxfQmlnYXJyYXlfY18xXzEiLCJjYW1sX2JhX2NyZWF0ZV91bnNhZmUiLCJzaXplX3Blcl9lbGVtZW50IiwiY2FtbF9iYV9kZXNlcmlhbGl6ZSIsInJlYWRlciIsIm51bV9kaW1zIiwic2l4dHkiLCJpbnQ2NCIsImNhbWxfYmFfY29tcGFyZSIsImNhbWxfaGFzaF9taXhfaW50NjQiLCJjYW1sX2hhc2hfbWl4X2Zsb2F0IiwidjAiLCJjYW1sX2JhX2hhc2giLCJudW1fZWx0cyIsInciLCJjYW1sX2ludDMyX3VubWFyc2hhbCIsImNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCIsImNhbWxfaW50NjRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9oYXNoIiwiY2FtbF9jdXN0b21fb3BzIiwiY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tIiwiY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tIiwibnVtIiwiY3VzdG9tIiwic3dhcCIsImNhbWxfY29tcGFyZV92YWxfdGFnIiwiTnVtYmVyIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX2NvbXBhcmVfdmFsIiwic3RhY2siLCJ0YWdfYSIsInRhZ19iIiwiY2FtbF9ncmVhdGVydGhhbiIsImRpdl9oZWxwZXIiLCJkaXZfZGlnaXRfbmF0IiwibmF0cSIsIm9mc3EiLCJuYXRyIiwib2ZzciIsInJlbSIsIm51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCIsInNoaWZ0X2xlZnRfbmF0IiwiTWxOYXQiLCJjcmVhdGVfbmF0IiwiYXJyIiwic2V0X3RvX3plcm9fbmF0IiwiaW5jcl9uYXQiLCJjYXJyeV9pbiIsImNhcnJ5IiwiYWRkX25hdCIsImxlbjIiLCJuYXRfb2ZfYXJyYXkiLCJtdWx0X2RpZ2l0X25hdCIsIm5hdDMiLCJvZnMzIiwieDEiLCJ4MiIsIngzIiwiZGVjcl9uYXQiLCJib3Jyb3ciLCJzdWJfbmF0IiwiY29tcGFyZV9uYXQiLCJkaXZfbmF0IiwicXVvIiwiY2FtbF9iYV9ibGl0Iiwic3JjIiwiZHN0IiwiaXNfZGlnaXRfaW50IiwiY2FtbF9pbnQ2NF9kaXYiLCJjYW1sX2pzX2h0bWxfZW50aXRpZXMiLCJlbnRpdHkiLCJ0ZW1wIiwiZG9jdW1lbnQiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfYXJndiIsIm1haW4iLCJhcmd2IiwiYXJnczIiLCJjYW1sX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJldmFsIiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QiLCJsb2MiLCJzaGFwZSIsInVuZGVmX21vZHVsZSIsIl94IiwibG9vcCIsInN0cnVjdCIsImlkeCIsInNlcmlhbGl6ZV9uYXQiLCJjYW1sX21lbXByb2Zfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX3N5c19leGl0IiwiY29kZSIsImNhbWxfanNfZnJvbV9hcnJheSIsImNhbWxfYmFfcmVzaGFwZSIsInZpbmQiLCJuZXdfZGltIiwiY2FtbF9vb19sYXN0X2lkIiwiY2FtbF9zZXRfb29faWQiLCJjYW1sX2dyX2ZpbGxfcmVjdCIsImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhIiwic3RyMSIsInBvczEiLCJiYTIiLCJwb3MyIiwic2xpY2UiLCJjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUiLCJqc25hbWUiLCJjYW1sX2dldF9nbG9iYWxfZGF0YSIsImNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQiLCJjYW1sX2JhX3VpbnQ4X2dldDE2IiwiY2FtbF9jb21wYXJlIiwiY2FtbF9mcmVzaF9vb19pZCIsImNhbWxfaW50NjRfdG9fZmxvYXQiLCJjYW1sX2JhX2dldF8xIiwiY2FtbF9iaWdzdHJpbmdfbWVtY21wIiwiY2FtbF9uZXdfc3RyaW5nIiwiY2FtbF9iYV91aW50OF9nZXQzMiIsImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgiLCJjYW1sX29ial9ibG9jayIsImNhbWxfZ3JfY2xlYXJfZ3JhcGgiLCJiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIiwiYnMiLCJseG9yX2RpZ2l0X25hdCIsImNhbWxfZmluYWxfcmVsZWFzZSIsImNhbWxfanNfdG9fYXJyYXkiLCJjYW1sX2dyX3Bsb3QiLCJjb2xvciIsImNhbWxfYnl0ZXNfc2V0NjQiLCJpNjQiLCJjYW1sX2J5dGVzX3NldDE2IiwiaTE2IiwiY2FtbF9zdHJpbmdfc2V0MTYiLCJjYW1sX2ludDY0X2Jzd2FwIiwiY2FtbF9maWxsX2J5dGVzIiwiY2FtbF9maWxsX3N0cmluZyIsImNhbWxfZ2NfbWFqb3IiLCJjYW1sX2xleF9hcnJheSIsImNhbWxfbGV4X2VuZ2luZSIsInRibCIsInN0YXJ0X3N0YXRlIiwibGV4YnVmIiwibGV4X2J1ZmZlciIsImxleF9idWZmZXJfbGVuIiwibGV4X3N0YXJ0X3BvcyIsImxleF9jdXJyX3BvcyIsImxleF9sYXN0X3BvcyIsImxleF9sYXN0X2FjdGlvbiIsImxleF9lb2ZfcmVhY2hlZCIsImxleF9iYXNlIiwibGV4X2JhY2t0cmsiLCJsZXhfZGVmYXVsdCIsImxleF90cmFucyIsImxleF9jaGVjayIsInN0YXRlIiwiYmFzZSIsImJhY2t0cmsiLCJjYW1sX3N5c19maWxlX2V4aXN0cyIsImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QiLCJjYW1sX2FycmF5X3N1YiIsImEyIiwiY2FtbF9ieXRlc19lcXVhbCIsImNhbWxfZ3Jfc2l6ZV94IiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiIsImNhbWxfY29zaF9mbG9hdCIsImNhbWxfZXBoZV9rZXlfb2Zmc2V0IiwiY2FtbF93ZWFrX2NoZWNrIiwiY2FtbF9lcGhlX2NoZWNrX2tleSIsImNhbWxfaGFzaF9taXhfZmluYWwiLCJjYW1sX2dyX3RleHRfc2l6ZSIsInR4dCIsImNhbWxfbGV4X3J1bl9tZW0iLCJtZW0iLCJjdXJyX3BvcyIsImNhbWxfbGV4X3J1bl90YWciLCJjYW1sX25ld19sZXhfZW5naW5lIiwibGV4X21lbSIsImxleF9iYXNlX2NvZGUiLCJsZXhfYmFja3Rya19jb2RlIiwibGV4X2RlZmF1bHRfY29kZSIsImxleF90cmFuc19jb2RlIiwibGV4X2NoZWNrX2NvZGUiLCJsZXhfY29kZSIsInBjX29mZiIsInBzdGF0ZSIsImJhc2VfY29kZSIsImNhbWxfYmFfdWludDhfc2V0NjQiLCJjYW1sX3N5c19leGVjdXRhYmxlX25hbWUiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbWxfZmx1c2giLCJvdXRwdXQiLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY29tcGFyZV9uYXRfcmVhbCIsImNhbWxfZ2Nfc2V0IiwiY2FtbF9qc19nZXQiLCJjYW1sX2djX2NvbXBhY3Rpb24iLCJjYW1sX3dlYWtfZ2V0IiwiY2FtbF9lcGhlX2dldF9rZXkiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhIiwid2luX2NsZWFudXAiLCJjYW1sX3N5c19jbG9zZSIsImNhbWxfbWxfY2xvc2VfY2hhbm5lbCIsImNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlIiwiZXhuIiwiZm9yY2UiLCJjYW1sX3N5c19pc2F0dHkiLCJfY2hhbiIsImlzX2RpZ2l0X3plcm8iLCJ1bml4X2luZXRfYWRkcl9vZl9zdHJpbmciLCJjYW1sX2pzX3NldCIsImNhbWxfYXJyYXlfZ2V0IiwiYXJyYXkiLCJpbmRleCIsImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX21sX3NlZWtfaW5fNjQiLCJjYW1sX2ludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX25vdGVxdWFsIiwiY2FtbF9zeXNfY29uc3RfaW50X3NpemUiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayIsImNhbWxfaXNfanMiLCJjYW1sX2JhX2RpbSIsImNhbWxfYmFfZGltXzEiLCJ1bml4X2xvY2FsdGltZSIsImRfbnVtIiwiamFudWFyeWZpcnN0IiwiZG95IiwiamFuIiwianVsIiwic3RkVGltZXpvbmVPZmZzZXQiLCJjYW1sX2pzX21ldGhfY2FsbCIsImNhbWxfd2Vha19jcmVhdGUiLCJjYW1sX2VwaGVfY3JlYXRlIiwiY2FtbF9qc190b19ieXRlX3N0cmluZyIsInVuaXhfbWt0aW1lIiwidG0iLCJ0bTIiLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX2J5dGVzX2dldDY0IiwiY2FtbF93ZWFrX3NldCIsImNhbWxfc3lzX3JlbW92ZSIsImNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yIiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJjYW1sX2h5cG90X2Zsb2F0IiwiY2FtbF9qc19jYWxsIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfaGFzaF9taXhfanNieXRlcyIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9ncl9maWxsX3BvbHkiLCJhciIsImNhbWxfZ2NfcXVpY2tfc3RhdCIsImNhbWxfcmFpc2VfZW5kX29mX2ZpbGUiLCJjYW1sX21sX2lucHV0X2ludCIsImNhbWxfZ3JfZGlzcGxheV9tb2RlIiwibnRoX2RpZ2l0X25hdCIsImNhbWxfYXJyYXlfYmxpdCIsImExIiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJtMyIsIm1hbnRpc3NhIiwicGFyc2VJbnQiLCJleHBvbmVudCIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4iLCJjYW1sX2xpc3RfdG9fanNfYXJyYXkiLCJjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsInZhbHVlIiwiZmxhZ3MiLCJub19zaGFyaW5nIiwiY2xvc3VyZXMiLCJpbnRlcm5fb2JqX3RhYmxlIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJvcHMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJvbGRfcG9zIiwidHlwZV9vZl92IiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmciLCJjYW1sX3JhaXNlX25vdF9hX2RpciIsImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kIiwiY21kIiwidW5peF9pc2F0dHkiLCJmaWxlRGVzY3JpcHRvciIsInR0eSIsImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uIiwiZGVzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJjYW1sX2dyX29wZW5fc3Vid2luZG93IiwianNfcHJpbnRfc3Rkb3V0IiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSIsImNhbWxfbWQ1X2J5dGVzIiwiYWRkIiwieHgiLCJmZiIsImdnIiwiaGgiLCJpaSIsIm1kNSIsImNhbWxfYmFfc2V0X2dlbmVyaWMiLCJjYW1sX2VwaGVfc2V0X2tleSIsImNhbWxfYnl0ZXNfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImJpdHMiLCJvbmUiLCJjYW1sX2dyX3NpemVfeSIsImNhbWxfbWxfcG9zX2luIiwiY2FtbF9pbnQ2NF9hbmQiLCJjYW1sX3N5c19jb25zdF93b3JkX3NpemUiLCJjYW1sX3N0ZF9vdXRwdXQiLCJzbGVuIiwianNfcHJpbnRfc3RkZXJyIiwiY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCIsImluZm8iLCJjYW1sX3N5c19vcGVuIiwiX3Blcm1zIiwiTWxTdHJpbmdSZWFkZXIiLCJjYW1sX2Zsb2F0X29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciIsIl9tYWdpYyIsIl9ibG9ja19sZW4iLCJudW1fb2JqZWN0cyIsIl9zaXplXzMyIiwiX3NpemVfNjQiLCJvYmpfY291bnRlciIsImludGVybl9yZWMiLCJoZWFkZXIiLCJleHBlY3RlZF9zaXplIiwiY2FtbF9zdHJpbmdfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMiLCJjYW1sX3N0cmluZ19nZXQiLCJyZV9tYXRjaCIsInJlX3dvcmRfbGV0dGVycyIsIm9wY29kZXMiLCJpc193b3JkX2xldHRlciIsImluX2JpdHNldCIsInJlX21hdGNoX2ltcGwiLCJwYXJ0aWFsIiwicHJvZyIsImNwb29sIiwibm9ybXRhYmxlIiwibnVtZ3JvdXBzIiwibnVtcmVnaXN0ZXJzIiwic3RhcnRjaGFycyIsInBjIiwicXVpdCIsImdyb3VwcyIsInJlX3JlZ2lzdGVyIiwiYmFja3RyYWNrIiwiaXRlbSIsInB1c2giLCJhY2NlcHQiLCJyZXN1bHQiLCJwcmVmaXhfbWF0Y2giLCJvcCIsInNhcmciLCJ1YXJnIiwiZ3JvdXAiLCJFcnJvciIsInJlX3NlYXJjaF9iYWNrd2FyZCIsImNhbWxfanNfZnJvbV9zdHJpbmciLCJjYW1sX2JhX3N1YiIsImNoYW5nZWRfZGltIiwibXVsIiwibmV3X2RpbXMiLCJuZXdfZGF0YSIsImNhbWxfZ2NfZnVsbF9tYWpvciIsImNhbWxfYnl0ZXNfc2V0MzIiLCJpMzIiLCJjYW1sX2dyX3NpZ2lvX3NpZ25hbCIsImNhbWxfYmFfdWludDhfc2V0MzIiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCIsImNhbWxfc2lnbmJpdF9mbG9hdCIsImNhbWxfZ3JfY3VycmVudF94IiwiY2FtbF9ncl9zZXRfbGluZV93aWR0aCIsImNhbWxfZ3Jfc2V0X2ZvbnQiLCJjYW1sX2dyX3NldF9jb2xvciIsImNvbnZlcnQiLCJudW1iZXIiLCJjX3N0ciIsImNhbWxfZ3JfbW92ZXRvIiwiY2FtbF9ncl9yZXNpemVfd2luZG93IiwiY2FtbF9ncl9zdGF0ZV9pbml0IiwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IiwidGEiLCJjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkiLCJjYW1sX21sX3NlZWtfb3V0IiwiY2FtbF9qc190eXBlb2YiLCJjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZSIsImJ0IiwiY2FtbF9ncl9saW5ldG8iLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUiLCJjYW1sX2JhX2RpbV8zIiwiY2FtbF9lcGhlX2RhdGFfb2Zmc2V0IiwiY2FtbF9lcGhlX2NoZWNrX2RhdGEiLCJjYW1sX2J5dGVzX2dldDE2IiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY2FtbF9qc19mcm9tX2Jvb2wiLCJjYW1sX21sX3NldF9jaGFubmVsX25hbWUiLCJjYW1sX2dyX2Nsb3NlX2dyYXBoIiwiY2FtbF9jcmVhdGVfc3RyaW5nIiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9tZDVfY2hhbiIsImNoYW5fbGVuIiwiY2FtbF9vYmpfZHVwIiwiY2FtbF93ZWFrX2dldF9jb3B5IiwiY2FtbF9tbF9vdXRwdXRfYnl0ZXMiLCJzdHJpbmciLCJqc3N0cmluZyIsImlkIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX2VwaGVfZ2V0X2RhdGEiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiY2FtbF9hcnJheV9hcHBlbmQiLCJsMSIsImwyIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwiLCJjYW1sX2pzX2V4cHIiLCJjYW1sX2ludDY0X211bCIsImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiX3VuaXQiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfaGFzaF91bml2X3BhcmFtIiwiY291bnQiLCJsaW1pdCIsIm9iaiIsImhhc2hfYWNjdSIsImhhc2hfYXV4IiwianNieXRlcyIsImNhbWxfc3RyaW5nX2VxdWFsIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwicmVfcmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwiY3VyIiwic3RhcnQiLCJlbmQiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMiLCJiYTEiLCJieXRlczIiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwiY2FtbF90b19qc19zdHJpbmciLCJjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UiLCJjYW1sX3BhcnNlX2RpZ2l0IiwiY2FtbF9pbnQ2NF9vZl9zdHJpbmciLCJiYXNlNjQiLCJ0aHJlc2hvbGQiLCJyZV9zZWFyY2hfZm9yd2FyZCIsImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9tYWtlX3ZlY3QiLCJpbml0IiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX2pzX3ZhciIsImNhbWxfdHJ1bmNfZmxvYXQiLCJjYW1sX2VwaGVfYmxpdF9kYXRhIiwiY2FtbF9pc19wcmludGFibGUiLCJjYW1sX2VxdWFsIiwicmVfcGFydGlhbF9tYXRjaCIsImNhbWxfc3lzX3JhbmRvbV9zZWVkIiwibm93IiwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZSIsImNhbWxfYmFfZ2V0XzIiLCJ3aW5faGFuZGxlX2ZkIiwiY2FtbF9iYV91aW50OF9zZXQxNiIsImNhbWxfanNfZGVsZXRlIiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwiY2FtbF9saXN0X21vdW50X3BvaW50IiwicHJldiIsImNhbWxfbWFyc2hhbF9jb25zdGFudHMiLCJjYW1sX2pzX2VxdWFscyIsImJpZ3N0cmluZ190b190eXBlZF9hcnJheSIsImNhbWxfZ3JfYXJjX2F1eCIsImN0eCIsImN4IiwiY3kiLCJyeSIsInJ4Iiwicm90IiwieFBvcyIsInlQb3MiLCJ4UG9zX3ByZXYiLCJ5UG9zX3ByZXYiLCJzcGFjZSIsImRlbHRhIiwiY2FtbF9ncl9maWxsX2FyYyIsImNhbWxfYmFfc2xpY2UiLCJudW1faW5kcyIsInN1Yl9kaW1zIiwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSIsImdldDMyIiwiY2FtbF9pbnB1dF92YWx1ZSIsImNhbWxfYmFfa2luZCIsImNhbWxfanNfZnVuX2NhbGwiLCJjYW1sX2pzX3B1cmVfZXhwciIsImNvbXBhcmVfZGlnaXRzX25hdCIsImNhbWxfbWxfaW5wdXQiLCJjYW1sX2dyX3dhaXRfZXZlbnQiLCJfZXZsIiwiY2FtbF9ncl9zaWdpb19oYW5kbGVyIiwiY2FtbF9oYXNoX21peF9iaWdzdHJpbmciLCJjYW1sX3JlY29yZF9iYWNrdHJhY2UiLCJ1bml4X2dtdGltZSIsImNhbWxfc3lzX2dldF9jb25maWciLCJjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUiLCJ1bml4X3RpbWUiLCJjYW1sX21sX291dF9jaGFubmVsc19saXN0IiwiYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciIsImFiIiwiY2FtbF9tb2QiLCJjYW1sX2JhX2luaXQiLCJyZV9zdHJpbmdfbWF0Y2giLCJCaWdTdHJpbmdSZWFkZXIiLCJjYW1sX2dyX2R1bXBfaW1hZ2UiLCJjYW1sX2JhX2dldF9nZW5lcmljIiwiY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSIsImNhbWxfZm9ybWF0X2Zsb2F0IiwidG9GaXhlZCIsImRwIiwicHJlYyIsImNhbWxfbW91bnRfYXV0b2xvYWQiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmciLCJjYW1sX3N0cmluZ19sZXNzdGhhbiIsImNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuIiwiY2FtbF9kaXYiLCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weSIsImNhbWxfc3lzX2dldF9hcmd2IiwiY2FtbF9qc190b19ib29sIiwiY2FtbF9ncl9jcmVhdGVfaW1hZ2UiLCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5IiwiY2FtbF9sZXNzdGhhbiIsImNhbWxfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QiLCJjYW1sX3JlZ2lzdGVyX2dsb2JhbCIsIm5hbWVfb3B0IiwibXVsdF9uYXQiLCJsZW4zIiwic3F1YXJlX25hdCIsImNhbWxfanNfZnJvbV9mbG9hdCIsImNhbWxfZmxvYXRhcnJheV9jcmVhdGUiLCJjYW1sX2djX3N0YXQiLCJjYW1sX3N5c19tb2RpZnlfYXJndiIsImNhbWxfbWV0aG9kX2NhY2hlIiwiY2FtbF9nZXRfcHVibGljX21ldGhvZCIsImNhY2hlaWQiLCJtZXRocyIsImxpIiwiY2FtbF9qc19nZXRfY29uc29sZSIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIiwiY2hhbm5lbCIsImJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSIsImNhbWxfcm91bmRfZmxvYXQiLCJjYW1sX29qc19uZXdfYXJyIiwiRiIsImNvbXBsZW1lbnRfbmF0IiwiY2FtbF9qc19yZWdleHBzIiwiY2FtbF9qc19odG1sX2VzY2FwZSIsImNhbWxfYmFfZGltXzIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX2xkZXhwX2Zsb2F0IiwiY2FtbF9ncl9zdGF0ZV9zZXQiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IiwiYXJpdHkiLCJjYW1sX2JhX3NldF8xIiwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2siLCJsYW5kX2RpZ2l0X25hdCIsImNhbWxfaW50NjRfbW9kIiwiY2FtbF9vYmpfc2V0X3RhZyIsImNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuIiwiY2FtbF9pbnQzMl9ic3dhcCIsIndpbl9zdGFydHVwIiwiY2FtbF9iYV9zZXRfMyIsImNhbWxfanNfaW5zdGFuY2VvZiIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nIiwibnRoX2RpZ2l0X25hdF9uYXRpdmUiLCJzZXRfZGlnaXRfbmF0X25hdGl2ZSIsImRpZ2l0IiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX2dyX3N0YXRlX2NyZWF0ZSIsImNhbnZhcyIsImNvbnRleHQiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2siLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9iYV9tYXBfZmlsZSIsInZmZCIsInNoYXJlZCIsImNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUiLCJhcmduIiwiY2FtbF9iYV9jcmVhdGVfZnJvbSIsImRhdGExIiwiZGF0YTIiLCJqc3R5cCIsImNhbWxfdGFuaF9mbG9hdCIsImNhbWxfZ3JfZHJhd19zdHIiLCJkeCIsImNhbWxfZ3JfZHJhd19zdHJpbmciLCJjYW1sX2dyX2RyYXdfY2hhciIsImNhbWxfdW5tb3VudCIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX21sX3Bvc19pbl82NCIsImNhbWxfZ3JfZHJhd19pbWFnZSIsImltYWdlIiwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUiLCJfY2hhbm5lbCIsImNhbWxfc3RyaW5nX3NldCIsImNhbWxfbWxfcG9zX291dCIsImNhbWxfc3BhY2V0aW1lX2VuYWJsZWQiLCJjYW1sX2J5dGVzX25vdGVxdWFsIiwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMiLCJjYW1sX2pzX29iamVjdCIsImNhbWxfYmFfY3JlYXRlIiwiZGltc19tbCIsImNhbWxfd2Vha19ibGl0IiwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJtb2RlIiwiY2FtbF9maW5hbF9yZWdpc3RlciIsImNhbWxfZ3JfZHJhd19yZWN0IiwiY2FtbF9zdHJpbmdfZ2V0MTYiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZXBoZV9ibGl0X2tleSIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2hhc2hfbWl4X3N0cmluZyIsImNhbWxfaGFzaCIsInNlZWQiLCJxdWV1ZSIsInJkIiwid3IiLCJjYW1sX29ial90YWciLCJGdW5jdGlvbiIsImNhbWxfYmFfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2pzX2V4cG9ydF92YXIiLCJtb2R1bGUiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9mcmV4cF9mbG9hdCIsIm5lZyIsImNhbWxfc3RyaW5nX2dldDY0IiwiY2FtbF9tbF9wb3Nfb3V0XzY0IiwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3ciLCJjYW1sX3NldF9zdGF0aWNfZW52IiwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0IiwiY2FtbF9qc19uZXciLCJjYW1sX2dyX2N1cnJlbnRfeSIsImNhbWxfZm9ybWF0X2ludCIsImNhbWxfb2JqX3RydW5jYXRlIiwiY2FtbF9qc190b19zdHJpbmciLCJpc19kaWdpdF9vZGQiLCJjYW1sX3J1bnRpbWVfdmFyaWFudCIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCIsImNhbWxfYXJyYXlfY29uY2F0IiwiY2FtbF9ncl9vcGVuX2dyYXBoIiwiZ2V0Iiwic3BlY3MiLCJ0YXJnZXQiLCJzdGF0dXMiLCJ3aW4iLCJkb2MiLCJ0aXRsZSIsImJvZHkiLCJjYW1sX2VwaGVfc2V0X2RhdGEiLCJjYW1sX21ha2VfZmxvYXRfdmVjdCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2xvZzFwX2Zsb2F0IiwiY2FtbF9pbnQ2NF9vciIsImNhbWxfbGF6eV9tYWtlX2ZvcndhcmQiLCJsb3JfZGlnaXRfbmF0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl93aW5kb3dfaWQiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJzZXRfZGlnaXRfbmF0IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kIiwicmVhbCIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX2luaXRpYWxfdGltZSIsImNhbWxfc3lzX3RpbWUiLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJzdHlsZSIsImV4cF9zaWduIiwic2lnbl9zdHIiLCJjc3QiLCJ4X3N0ciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX21vZGZfZmxvYXQiLCJjYW1sX2djX2dldCIsImNhbWxfZmxvYXRfY29tcGFyZSIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJlbnYiLCJFUlJDT0RFIiwidGVzdHNoaWZ0Iiwic2hpZnQiLCJzaGlmdF9yZWNvdmVyIiwicmVkdWNlIiwiUkVBRF9UT0tFTiIsIlJBSVNFX1BBUlNFX0VSUk9SIiwiR1JPV19TVEFDS1NfMSIsIkdST1dfU1RBQ0tTXzIiLCJDT01QVVRFX1NFTUFOVElDX0FDVElPTiIsIkNBTExfRVJST1JfRlVOQ1RJT04iLCJlbnZfc19zdGFjayIsImVudl92X3N0YWNrIiwiZW52X3N5bWJfc3RhcnRfc3RhY2siLCJlbnZfc3ltYl9lbmRfc3RhY2siLCJlbnZfc3RhY2tzaXplIiwiZW52X3N0YWNrYmFzZSIsImVudl9jdXJyX2NoYXIiLCJlbnZfbHZhbCIsImVudl9zeW1iX3N0YXJ0IiwiZW52X3N5bWJfZW5kIiwiZW52X2FzcCIsImVudl9ydWxlX2xlbiIsImVudl9ydWxlX251bWJlciIsImVudl9zcCIsImVudl9zdGF0ZSIsImVudl9lcnJmbGFnIiwidGJsX3RyYW5zbF9jb25zdCIsInRibF90cmFuc2xfYmxvY2siLCJ0YmxfbGhzIiwidGJsX2xlbiIsInRibF9kZWZyZWQiLCJ0YmxfZGdvdG8iLCJ0Ymxfc2luZGV4IiwidGJsX3JpbmRleCIsInRibF9naW5kZXgiLCJ0YmxfdGFibGVzaXplIiwidGJsX3RhYmxlIiwidGJsX2NoZWNrIiwibjEiLCJuMiIsInN0YXRlMSIsInNwIiwiZXJyZmxhZyIsImFzcCIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfc3RyaW5nX25vdGVxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfZ3JfbWFrZV9pbWFnZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwiemVybyQyIiwib25lJDIiLCJtaW51c19vbmUkMiIsIm1pbl9pbnQkMiIsIm1heF9pbnQkMiIsImR1bW15X3BvcyIsInplcm9fcG9zIiwic3ViX2Zvcm1hdCIsImZvcm1hdHRpbmdfbGl0IiwibG9jZm10IiwibnVsbCQwIiwiY3VycmVudF9kaXJfbmFtZSIsInBhcmVudF9kaXJfbmFtZSIsImRpcl9zZXAiLCJxdW90ZXF1b3RlIiwibnVsbCQxIiwiY3VycmVudF9kaXJfbmFtZSQwIiwicGFyZW50X2Rpcl9uYW1lJDAiLCJkaXJfc2VwJDAiLCJudWxsJDIiLCJjdXJyZW50X2Rpcl9uYW1lJDEiLCJwYXJlbnRfZGlyX25hbWUkMSIsImRpcl9zZXAkMSIsInplcm8kNCIsIm9uZSQ0IiwiaSIsImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInByZWMiLCJwYWQkMSIsImljb252IiwicHJlYyQwIiwicGFkJDIiLCJpY29udiQwIiwicHJlYyQxIiwicGFkJDMiLCJpY29udiQxIiwicHJlYyQyIiwicGFkJDQiLCJpY29udiQyIiwicHJlYyQzIiwicGFkJDUiLCJmY29udiIsInBhZCQ2Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJwYWQkNyIsImZtdHR5JDAiLCJwYWQkOCIsInJlc3QkMTQiLCJyZXN0JDE1IiwicmVzdCQxNiIsImZtdGluZ19saXQiLCJyZXN0JDE3IiwiZm10aW5nX2dlbiIsInJlc3QkMTgiLCJyZXN0JDE5IiwiY2hhcl9zZXQiLCJ3aWR0aF9vcHQiLCJyZXN0JDIwIiwiY291bnRlciIsInJlc3QkMjEiLCJyZXN0JDIyIiwiaWduIiwicmVzdCQyMyIsImYiLCJhcml0eSIsInMiLCJ4IiwieSIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbiIsIm1heF9pbnQiLCJzMSIsInMyIiwibDEiLCJsMiIsIm4iLCJiIiwibCIsImkkMCIsInRvX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJhcHBlbmQiLCJ0bCIsImhkIiwibW9kZSIsInBlcm0iLCJuYW1lIiwiYyIsIml0ZXIiLCJhIiwib2MiLCJvZnMiLCJsZW4iLCJjaGFuIiwidiIsImljIiwidW5zYWZlX3JlYWxseV9pbnB1dCIsIm9mcyQwIiwibGVuJDAiLCJyIiwibGVuJDEiLCJvZnMkMSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsImFjY3UiLCJiZWciLCJhY2N1JDAiLCJyZXMiLCJzdHIyIiwic3RyMSIsImV4aXRfZnVuY3Rpb24iLCJnIiwiZl9hbHJlYWR5X3JhbiIsInJldGNvZGUiLCJlbXB0eSIsInJldHVybiQwIiwibWFwIiwic2VxIiwibmV4dCIsImZpbHRlcl9tYXAiLCJzZXEkMCIsImZpbHRlciIsImZsYXRfbWFwJDAiLCJmbGF0X21hcF9hcHAkMCIsInRhaWwiLCJmbGF0X21hcF9hcHAiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImFjYyIsImFjYyQwIiwiYWNjJDEiLCJub25lIiwic29tZSIsInZhbHVlIiwibyIsImRlZmF1bHQkMCIsImdldCIsImJpbmQiLCJqb2luIiwibWFwJDAiLCJmb2xkIiwiaXRlciQwIiwiaXNfbm9uZSIsImlzX3NvbWUiLCJlcXVhbCIsImVxIiwibzAiLCJvMSIsInYxIiwidjAiLCJjb21wYXJlIiwiY21wIiwidG9fcmVzdWx0IiwidG9fbGlzdCIsInRvX3NlcSIsIm9rIiwiZXJyb3IiLCJlIiwidmFsdWUkMCIsImdldF9vayIsImdldF9lcnJvciIsImJpbmQkMCIsImpvaW4kMCIsIm1hcCQxIiwibWFwX2Vycm9yIiwiZm9sZCQwIiwiaXRlciQxIiwiaXRlcl9lcnJvciIsImlzX29rIiwiaXNfZXJyb3IiLCJlcXVhbCQwIiwicjAiLCJtYXRjaCIsImUxIiwiY29tcGFyZSQwIiwidG9fb3B0aW9uIiwidG9fbGlzdCQwIiwidG9fc2VxJDAiLCJlcXVhbCQxIiwiY29tcGFyZSQxIiwidG9faW50IiwidG9fZmxvYXQiLCJ0b19zdHJpbmckMCIsImVzY2FwZWQiLCJzJDAiLCJsb3dlcmNhc2UiLCJ1cHBlcmNhc2UiLCJsb3dlcmNhc2VfYXNjaWkiLCJ1cHBlcmNhc2VfYXNjaWkiLCJjb21wYXJlJDIiLCJjMSIsImMyIiwiZXF1YWwkMiIsIm1pbiQwIiwibWF4JDAiLCJsb19ib3VuZCIsImhpX2JvdW5kIiwiYm9tIiwicmVwIiwic3VjYyIsInUiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsJDMiLCJjb21wYXJlJDMiLCJoYXNoIiwibWF0Y2gkMSIsImxlbmd0aCIsInBhcmFtJDAiLCJjb25zIiwibnRoIiwibCQwIiwibiQwIiwibCQxIiwibiQxIiwibnRoX29wdCIsInJldl9hcHBlbmQiLCJsMSQwIiwibDIkMCIsImwxJDEiLCJsMiQxIiwicmV2IiwiaW5pdF9hdXgiLCJyZXZfaW5pdF90aHJlc2hvbGQiLCJwYXJhbSIsImFjY3UkMSIsImEyIiwiYTEiLCJwIiwicGFpciIsInJlc3VsdCIsInhzIiwicnkiLCJyeCIsInQyIiwiaDIiLCJ0MSIsImgxIiwic29ydCIsIngyIiwieDEiLCJ0bCQxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJyZXZfc29ydCIsInRsJDAiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJjJDYiLCJhY2N1JDIiLCJhdXgiLCJkaXJlY3QiLCJkZXB0aCIsInN5bWJvbCQxIiwibGVmdCIsInJpZ2h0IiwiZHN0b2ZmIiwic3Jjb2ZmIiwiY3B5bGVuIiwib2ZzMSIsIm9mczIiLCJzZXAiLCJzZXBsZW4iLCJkc3QiLCJpc19zcGFjZSIsImoiLCJhcHBseTEiLCJpbmRleF9yZWMiLCJsaW0iLCJpJDEiLCJpbmRleF9yZWNfb3B0IiwicmluZGV4X3JlYyIsInJpbmRleF9yZWNfb3B0IiwibmV3X2xlbiIsIm5ld19idWYiLCJpc19zcGFjZSQwIiwiaW5kZXhfcmVjJDAiLCJpbmRleF9yZWNfb3B0JDAiLCJyaW5kZXhfcmVjJDAiLCJyaW5kZXhfcmVjX29wdCQwIiwiZXF1YWwkNiIsImNvbXBhcmUkNiIsInRvX3N0cmluZyQyIiwidG9fYnVmZmVyIiwiYnVmZiIsImZsYWdzIiwiaGVhZGVyX3NpemUiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwibWFyc2hhbCIsIm9iaiIsInVubWFyc2hhbCIsInBvcyIsImZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3RvciIsImxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yXyIsImxhenlfdGFnIiwiY2xvc3VyZV90YWciLCJvYmplY3RfdGFnIiwiaW5maXhfdGFnIiwiZm9yd2FyZF90YWciLCJub19zY2FuX3RhZyIsImFic3RyYWN0X3RhZyIsInN0cmluZ190YWciLCJkb3VibGVfdGFnIiwiZG91YmxlX2FycmF5X3RhZyIsImN1c3RvbV90YWciLCJpbnRfdGFnIiwib3V0X29mX2hlYXBfdGFnIiwidW5hbGlnbmVkX3RhZyIsIm9mX3ZhbCIsInNsb3QiLCJpZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsImV4dGVuc2lvbl9uYW1lIiwiZXh0ZW5zaW9uX2lkIiwibWF4X2VwaGVfbGVuZ3RoIiwiY3JlYXRlIiwibGVuZ3RoJDAiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCIsIm1zZyIsImdldF9rZXkiLCJnZXRfa2V5X2NvcHkiLCJzZXRfa2V5IiwidW5zZXRfa2V5IiwiY2hlY2tfa2V5IiwiYmxpdF9rZXkiLCJlMiIsIm8yIiwic3giLCJzeSIsImluaXQiLCJsYSIsImxiIiwicmVzJDAiLCJsaXN0X2xlbmd0aCIsInBhcmFtJDEiLCJoZCQwIiwibWF4c29uIiwiaTMxIiwidHJpY2tsZWRvd24iLCJ0cmlja2xlIiwiYnViYmxlZG93biIsImJ1YmJsZSIsImkkMiIsImUkMCIsImZhdGhlciIsIm1lcmdlIiwic3JjMW9mcyIsInNyYzFsZW4iLCJzcmMyIiwic3JjMm9mcyIsInNyYzJsZW4iLCJkc3RvZnMiLCJzcmMxciIsInNyYzJyIiwiczIkMSIsInMxJDEiLCJpMSIsImkyIiwiZCIsImkyJDAiLCJkJDAiLCJzMiQwIiwiaTEkMCIsImQkMSIsInMxJDAiLCJpc29ydHRvIiwic3Jjb2ZzIiwic29ydHRvIiwidCIsInplcm8iLCJvbmUiLCJtaW51c19vbmUiLCJpc19maW5pdGUiLCJpc19pbmZpbml0ZSIsImlzX25hbiIsInBpIiwiaXNfaW50ZWdlciIsInN1Y2MkMCIsInByZWQkMCIsImVxdWFsJDciLCJtaW4kMSIsIm1heCQxIiwibWluX21heCIsIm1pbl9udW0iLCJtYXhfbnVtIiwibWluX21heF9udW0iLCJoYXNoJDAiLCJ1bnNhZmVfZmlsbCIsInVuc2FmZV9ibGl0Iiwic3JjIiwic29mcyIsImRvZnMiLCJjaGVjayIsIm1ha2UkMSIsImluaXQkMyIsImFwcGVuZCQxIiwiY29uY2F0JDIiLCJobGVuIiwic3ViJDIiLCJjb3B5JDIiLCJmaWxsJDEiLCJibGl0JDIiLCJ0b19saXN0JDIiLCJvZl9saXN0JDAiLCJoIiwiaXRlciQ2IiwiaXRlcjIkMSIsIm1hcCQ2IiwibWFwMiQxIiwiaXRlcmkkMyIsIm1hcGkkMyIsImZvbGRfbGVmdCQyIiwiZm9sZF9yaWdodCQxIiwiZXhpc3RzJDEiLCJmb3JfYWxsJDEiLCJtZW0kMSIsIm1lbV9pZWVlIiwic29ydCQwIiwic3RhYmxlX3NvcnQiLCJ0b19zZXEkNSIsInRvX3NlcWkkMiIsIm9mX3NlcSQzIiwibWFwX3RvX2FycmF5IiwibWFwX2Zyb21fYXJyYXkiLCJ6ZXJvJDAiLCJvbmUkMCIsIm1pbnVzX29uZSQwIiwiYWJzJDAiLCJtYXhfaW50JDAiLCJtaW5faW50JDAiLCJsb2dub3QiLCJlcXVhbCQ4IiwiY29tcGFyZSQ3IiwidG9fc3RyaW5nJDMiLCJ6ZXJvJDEiLCJvbmUkMSIsIm1pbnVzX29uZSQxIiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJtaW5faW50JDEiLCJtYXhfaW50JDEiLCJsb2dub3QkMCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyQ0Iiwib2Zfc3RyaW5nX29wdCQwIiwiY29tcGFyZSQ4IiwiZXF1YWwkOSIsInVuc2lnbmVkX2NvbXBhcmUiLCJtIiwidW5zaWduZWRfZGl2IiwicSIsInVuc2lnbmVkX3JlbSIsInN1Y2MkMiIsInByZWQkMiIsImFicyQyIiwibG9nbm90JDEiLCJtYXhfaW50JDMiLCJ1bnNpZ25lZF90b19pbnQkMCIsInRvX3N0cmluZyQ1Iiwib2Zfc3RyaW5nX29wdCQxIiwiY29tcGFyZSQ5IiwiZXF1YWwkMTAiLCJ1bnNpZ25lZF9jb21wYXJlJDAiLCJ1bnNpZ25lZF9kaXYkMCIsInVuc2lnbmVkX3JlbSQwIiwiemVybyQzIiwib25lJDMiLCJtaW51c19vbmUkMyIsInN1Y2MkMyIsInByZWQkMyIsImFicyQzIiwibWluX2ludCQzIiwibWF4X2ludCQ0IiwibG9nbm90JDIiLCJ1bnNpZ25lZF90b19pbnQkMSIsInRvX3N0cmluZyQ2Iiwib2Zfc3RyaW5nX29wdCQyIiwiY29tcGFyZSQxMCIsImVxdWFsJDExIiwidW5zaWduZWRfY29tcGFyZSQxIiwidW5zaWduZWRfZGl2JDEiLCJ1bnNpZ25lZF9yZW0kMSIsImVuZ2luZSIsInRibCIsInN0YXRlIiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJhcmckMSIsImNtZCQwIiwiZXhuIiwiY3Vycl9jaGFyIiwidG9rIiwicGVla192YWwiLCJzeW1ib2xfc3RhcnRfcG9zIiwic3QiLCJlbiIsInN5bWJvbF9lbmRfcG9zIiwicmhzX3N0YXJ0X3BvcyIsInJoc19lbmRfcG9zIiwic3ltYm9sX3N0YXJ0Iiwic3ltYm9sX2VuZCIsInJoc19zdGFydCIsInJoc19lbmQiLCJpc19jdXJyZW50X2xvb2thaGVhZCIsInBhcnNlX2Vycm9yIiwiaGVpZ2h0IiwiaGwiLCJoJDAiLCJociIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiIsImxybCIsInJyIiwicnYiLCJybCIsInJsciIsInJsdiIsInJsbCIsImFkZCIsInNpbmdsZXRvbiIsImFkZF9taW5fZWxlbWVudCIsImFkZF9tYXhfZWxlbWVudCIsInJoIiwibGgiLCJtaW5fZWx0IiwibWluX2VsdF9vcHQiLCJtYXhfZWx0IiwibWF4X2VsdF9vcHQiLCJyZW1vdmVfbWluX2VsdCIsInIkMCIsImNvbmNhdCIsInNwbGl0IiwicHJlcyIsInByZXMkMCIsImlzX2VtcHR5IiwibWVtIiwicmVtb3ZlIiwidW5pb24iLCJyMiIsInYyIiwicjEiLCJyMiQwIiwicjEkMCIsImludGVyIiwic3BsaXRfYmlzIiwiZGlzam9pbnQiLCJkaWZmIiwiY29uc19lbnVtIiwicyQxIiwiZSQxIiwiZTIkMiIsImUxJDIiLCJlMiQwIiwiZTEkMCIsImUyJDEiLCJlMSQxIiwic3Vic2V0IiwiZm9yX2FsbCIsImV4aXN0cyIsInB2IiwicGFydGl0aW9uIiwibGYiLCJsdCIsInJmIiwicnQiLCJjYXJkaW5hbCIsImVsZW1lbnRzX2F1eCIsImVsZW1lbnRzIiwiZmluZCIsImZpbmRfZmlyc3QiLCJ2JDAiLCJmaW5kX2ZpcnN0X29wdCIsImZpbmRfbGFzdCIsImZpbmRfbGFzdF9vcHQiLCJmaW5kX29wdCIsIm9mX2xpc3QiLCJzdWIiLCJsJDMiLCJ4MCIsImwkNCIsIngwJDAiLCJsJDUiLCJ4MCQxIiwibmwiLCJtaWQiLCJsJDIiLCJ4NCIsImFkZF9zZXEiLCJvZl9zZXEiLCJzZXFfb2ZfZW51bSIsInRvX3NlcV9mcm9tIiwibG93IiwibGQiLCJscmQiLCJyZCIsInJsZCIsImRhdGEiLCJtaW5fYmluZGluZyIsIm1pbl9iaW5kaW5nX29wdCIsIm1heF9iaW5kaW5nIiwibWF4X2JpbmRpbmdfb3B0IiwicmVtb3ZlX21pbl9iaW5kaW5nIiwidXBkYXRlIiwiZGF0YSQwIiwibWFwaSIsIm0kMCIsImFkZF9taW5fYmluZGluZyIsImsiLCJhZGRfbWF4X2JpbmRpbmciLCJjb25jYXRfb3Jfam9pbiIsImQxIiwiZDIiLCJkMiQwIiwiZDEkMCIsImQyJDEiLCJkMSQxIiwicHZkIiwibSQxIiwibTEiLCJtMiIsImJpbmRpbmdzX2F1eCIsImJpbmRpbmdzIiwiY3JlYXRlJDAiLCJjbGVhciIsImNvcHkkMyIsInB1c2giLCJwb3AiLCJwb3Bfb3B0IiwidG9wIiwidG9wX29wdCIsImxlbmd0aCQxIiwiaXRlciQ3IiwiZm9sZCQxIiwidG9fc2VxJDYiLCJvZl9zZXEkNCIsImNyZWF0ZSQxIiwiY2xlYXIkMCIsImNlbGwiLCJwZWVrIiwiY29udGVudCIsInBlZWtfb3B0IiwidGFrZSIsInRha2Vfb3B0IiwiY29weSQ0IiwicV9yZXMiLCJwcmV2IiwiaXNfZW1wdHkkMCIsImxlbmd0aCQyIiwiaXRlciQ4IiwiZm9sZCQyIiwidHJhbnNmZXIiLCJxMSIsInEyIiwidG9fc2VxJDciLCJhZGRfc2VxJDAiLCJvZl9zZXEkNSIsInJhaXNlX3VuZGVmaW5lZCIsImZvcmNlX2xhenlfYmxvY2siLCJibGsiLCJjbG9zdXJlIiwiZm9yY2VfdmFsX2xhenlfYmxvY2siLCJmb3JjZSIsImx6diIsImZvcmNlX3ZhbCIsImZyb21fZnVuIiwiZnJvbV92YWwiLCJpc192YWwiLCJjb3VudCIsImZpbGxfYnVmZiIsImdldF9kYXRhIiwiZDExIiwiYSQwIiwiYSQxIiwicGVla19kYXRhIiwicGVlayQwIiwianVua19kYXRhIiwianVuayIsIm5nZXRfZGF0YSIsImFsIiwibnBlZWsiLCJlbXB0eSQxIiwiaXRlciQ5Iiwic3RybSIsImZyb20iLCJvZl9saXN0JDEiLCJvZl9zdHJpbmckMCIsIm9mX2J5dGVzIiwib2ZfY2hhbm5lbCIsImlhcHAiLCJpY29ucyIsImlzaW5nIiwibGFwcCIsImxjb25zIiwibHNpbmciLCJzZW1wdHkiLCJzbGF6eSIsImR1bXAiLCJkdW1wX2RhdGEiLCJjcmVhdGUkMiIsImNvbnRlbnRzIiwidG9fYnl0ZXMiLCJzdWIkMyIsImJsaXQkMyIsIm50aCQwIiwibGVuZ3RoJDMiLCJjbGVhciQxIiwicmVzZXQiLCJyZXNpemUiLCJtb3JlIiwib2xkX3BvcyIsIm9sZF9sZW4iLCJuZXdfYnVmZmVyIiwiYWRkX2NoYXIiLCJhZGRfdXRmXzhfdWNoYXIiLCJwb3MkMCIsInBvcyQxIiwiYWRkX3V0Zl8xNmJlX3VjaGFyIiwidSQwIiwiaGkiLCJsbyIsImFkZF91dGZfMTZsZV91Y2hhciIsImFkZF9zdWJzdHJpbmciLCJvZmZzZXQiLCJuZXdfcG9zaXRpb24iLCJhZGRfc3ViYnl0ZXMiLCJhZGRfc3RyaW5nIiwiYWRkX2J5dGVzIiwiYWRkX2J1ZmZlciIsImJzIiwiYWRkX2NoYW5uZWwiLCJhbHJlYWR5X3JlYWQiLCJ0b19yZWFkIiwiYWxyZWFkeV9yZWFkJDAiLCJ0b19yZWFkJDAiLCJvdXRwdXRfYnVmZmVyIiwiYWRkX3N1YnN0aXR1dGUiLCJsaW0kMSIsInByZXZpb3VzIiwiaSQ3IiwiY3VycmVudCIsImkkOCIsIm9wZW5pbmciLCJpJDYiLCJsaW0kMCIsImkkMyIsInN0b3AiLCJpJDQiLCJpJDUiLCJrJDIiLCJrJDAiLCJrJDEiLCJuZXh0X2kiLCJpZGVudCIsImkkOSIsImkkMTAiLCJpJDExIiwidHJ1bmNhdGUiLCJ0b19zZXEkOCIsInRvX3NlcWkkMyIsImFkZF9zZXEkMSIsIm9mX3NlcSQ2IiwiYWRkX2ludDgiLCJhZGRfaW50MTZfbmUiLCJhZGRfaW50MzJfbmUiLCJhZGRfaW50NjRfbmUiLCJhZGRfaW50MTZfbGUiLCJhZGRfaW50MTZfYmUiLCJ4JDAiLCJhZGRfaW50MzJfbGUiLCJhZGRfaW50MzJfYmUiLCJhZGRfaW50NjRfbGUiLCJhZGRfaW50NjRfYmUiLCJjcmVhdGVfY2hhcl9zZXQiLCJhZGRfaW5fY2hhcl9zZXQiLCJzdHJfaW5kIiwibWFzayIsImZyZWV6ZV9jaGFyX3NldCIsInJldl9jaGFyX3NldCIsImNoYXJfc2V0JDAiLCJpc19pbl9jaGFyX3NldCIsInBhZF9vZl9wYWRfb3B0IiwicGFkX29wdCIsIndpZHRoIiwicGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IiwiZm10IiwicGFkX29wdCQwIiwicGFkX29wdCQxIiwicGFkX29wdCQyIiwicGFkX29wdCQzIiwicGFkX29wdCQ0IiwicHJlY19vcHQiLCJwYWRfb3B0JDUiLCJuZGVjIiwicGFkX29wdCQ2IiwicGFkX29wdCQ3IiwicGFkX29wdCQ4IiwiZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24iLCJidWZmZXJfY3JlYXRlIiwiaW5pdF9zaXplIiwiYnVmZmVyX2NoZWNrX3NpemUiLCJvdmVyaGVhZCIsIm1pbl9sZW4iLCJuZXdfc3RyIiwiYnVmZmVyX2FkZF9jaGFyIiwiYnVmZmVyX2FkZF9zdHJpbmciLCJzdHJfbGVuIiwiYnVmZmVyX2NvbnRlbnRzIiwiY2hhcl9vZl9pY29udiIsImNoYXJfb2ZfZmNvbnYiLCJjRiIsImJwcmludF9wYWR0eSIsInBhZHR5IiwiYnByaW50X2lnbm9yZWRfZmxhZyIsImlnbl9mbGFnIiwiYnByaW50X3BhZF9vcHQiLCJicHJpbnRfcGFkZGluZyIsInBhZHR5JDAiLCJicHJpbnRfcHJlY2lzaW9uIiwiYnByaW50X2ljb252X2ZsYWciLCJicHJpbnRfYWx0aW50X2ZtdCIsImJwcmludF9mY29udl9mbGFnIiwic3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0Iiwic3RyJDAiLCJicHJpbnRfY2hhcl9saXRlcmFsIiwiYnByaW50X3N0cmluZ19saXRlcmFsIiwiYnByaW50X2ZtdHR5Iiwic3ViX2ZtdHR5Iiwic3ViX2ZtdHR5JDAiLCJpbnRfb2ZfY3VzdG9tX2FyaXR5Iiwic3RyaW5nX29mX2ZtdCIsImZtdCQxIiwiY2hyJDAiLCJzdHIkMSIsInByaW50X2NoYXIiLCJpc19hbG9uZSQwIiwiaXNfYWxvbmUiLCJhZnRlciIsImJlZm9yZSIsImokMCIsImokMSIsImZtdCQwIiwic3ltbSIsImZtdHR5X3JlbF9kZXQiLCJkZSIsImVkIiwiYWYiLCJmYSIsImRlJDAiLCJlZCQwIiwiYWYkMCIsImZhJDAiLCJkZSQxIiwiZWQkMSIsImFmJDEiLCJmYSQxIiwiZGUkMiIsImVkJDIiLCJhZiQyIiwiZmEkMiIsImRlJDMiLCJlZCQzIiwiYWYkMyIsImZhJDMiLCJkZSQ0IiwiZWQkNCIsImFmJDQiLCJmYSQ0IiwiZGUkNSIsImVkJDUiLCJhZiQ1IiwiZmEkNSIsImRlJDYiLCJlZCQ2IiwiYWYkNiIsImZhJDYiLCJkZSQ3IiwiZWQkNyIsImFmJDciLCJmYSQ3IiwiZGUkOCIsImVkJDgiLCJhZiQ4IiwiZmEkOCIsInRyYW5zIiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJyZXN0MiIsInJlc3QyJDAiLCJyZXN0MiQxIiwicmVzdDIkMiIsInJlc3QyJDMiLCJyZXN0MiQ0IiwicmVzdDIkNSIsInJlc3QyJDYiLCJyZXN0MiQ3IiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImZtdHR5X29mX3BhZGRpbmdfZm10dHkiLCJmbXR0eV9vZl9jdXN0b20iLCJhcml0eSQwIiwiZm10dHlfb2ZfZm10IiwidHlfcmVzdCIsInByZWNfdHkiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJ0eSQwIiwiZm10dHkkNCIsImZtdHR5JDUiLCJ0eXBlX3BhZGRpbmciLCJ3IiwidHlwZV9wYWRwcmVjIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwiZm10dHlfcmVzdCIsImZtdF9yZXN0IiwiZm10dHlfcmVzdCQwIiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXR0eV9yZXN0JDEiLCJmbXQkMiIsImZtdF9yZXN0JDIiLCJmbXR0eV9yZXN0JDIiLCJmbXQkMyIsImZtdF9yZXN0JDMiLCJmbXR0eV9yZXN0JDMiLCJmbXQkNCIsImZtdF9yZXN0JDQiLCJmbXR0eV9yZXN0JDQiLCJmbXQkNSIsImZtdF9yZXN0JDUiLCJmbXR0eV9yZXN0JDUiLCJwcmVjJDQiLCJmbXR0eSQ2IiwiZm10JDYiLCJmbXRfcmVzdCQ2IiwicHJlYyQ1IiwiZm10dHlfcmVzdCQ2IiwicHJlYyQ2IiwiZm10dHkkNyIsImZtdCQ3IiwiZm10X3Jlc3QkNyIsInByZWMkNyIsImZtdHR5X3Jlc3QkNyIsInByZWMkOCIsImZtdHR5JDgiLCJmbXQkOCIsImZtdF9yZXN0JDgiLCJmbXR0eV9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10JDkiLCJmbXRfcmVzdCQ5IiwiZm10dHkkMTAiLCJmbXQkMTAiLCJmbXRfcmVzdCQxMCIsImZtdHR5JDExIiwiZm10JDExIiwiZm10X3Jlc3QkMTEiLCJmbXR0eSQxMiIsImZtdCQxMiIsImZtdHR5X3Jlc3QkOSIsImZtdF9yZXN0JDEyIiwiZm10dHkkMTMiLCJmbXQkMTMiLCJmbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdHR5X3Jlc3QkMTEiLCJmbXRfcmVzdCQxNCIsImZtdHR5JDE1IiwiZm10JDE1IiwiZm10dHlfcmVzdCQxMiIsImZtdF9yZXN0JDE1IiwiZm10dHkkMTYiLCJmbXQkMTYiLCJmbXRfcmVzdCQxNiIsImZtdHR5JDE3IiwiZm10JDE3IiwiZm10X3Jlc3QkMTciLCJmb3JtYXR0aW5nX2dlbiIsImZtdHR5MyIsImZtdDMiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTgiLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOSIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDIwIiwiZm10JDIwIiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIxIiwiZm10JDIxIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsImZtdHR5JDIyIiwiZm10JDIyIiwic3ViX2ZtdHR5JDQiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsInN1Yl9mbXR0eV9yZXN0JDMiLCJzdWJfZm10dHlfcmVzdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkNSIsInN1Yl9mbXR0eV9yZXN0JDYiLCJzdWJfZm10dHlfcmVzdCQ3Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDE0Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwic3ViX2ZtdHR5X3Jlc3QkMTYiLCJzdWIyX2ZtdHR5JDEiLCJzdWIxX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTciLCJzdWIyX2ZtdHR5JDIiLCJzdWIxX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxOCIsInN1Yl9mbXR0eV9yZXN0JDE5Iiwic3ViX2ZtdHR5X3Jlc3QkMjAiLCJzdWJfZm10dHlfcmVzdCQyMSIsInN1Yl9mbXR0eV9yZXN0JDIyIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJzdWJfZm10dHlfcmVzdCQyNCIsInN1Yl9mbXR0eV9yZXN0JDI1Iiwic3ViX2ZtdHR5X3Jlc3QkMjYiLCJyZWNhc3QiLCJmaXhfcGFkZGluZyIsIndpZHRoJDAiLCJmaXhfaW50X3ByZWNpc2lvbiIsInJlcyQxIiwic3RyaW5nX3RvX2NhbWxfc3RyaW5nIiwiZm9ybWF0X29mX2Zjb252Iiwic3ltYiIsInRyYW5zZm9ybV9pbnRfYWx0IiwiZGlnaXRzIiwicHV0IiwiY29udmVydF9pbnQiLCJjb252ZXJ0X2ludDMyIiwiY29udmVydF9uYXRpdmVpbnQiLCJjb252ZXJ0X2ludDY0IiwiY29udmVydF9mbG9hdCIsImhleCIsInNpZ24iLCJjYW1sX3NwZWNpYWxfdmFsIiwic3RyaW5nX29mX2ZtdHR5IiwibWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24iLCJtYWtlX3ByaW50ZiIsInAkMCIsInAkMSIsIm1ha2VfcGFkZGluZyIsIm5ld19hY2MiLCJtYWtlX3ByaW50ZiQwIiwiYWNjJDIiLCJhY2MkMyIsImFjYyQ0IiwiayQzIiwia2FjYyIsImskNCIsIm1ha2VfaWdub3JlZF9wYXJhbSQwIiwibWFrZV9jdXN0b20kMCIsIm1ha2VfaW52YWxpZF9hcmciLCJtYWtlX2Zyb21fZm10dHkkMCIsIm1ha2VfZnJvbV9mbXR0eSIsIm1ha2VfY3VzdG9tIiwibWFrZV9pZ25vcmVkX3BhcmFtIiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJtYWtlX2lwcmludGYiLCJtYWtlX2lwcmludGYkMCIsImtvYyIsInJlc3QkMjQiLCJyZXN0JDI1IiwiZm5fb2ZfY3VzdG9tX2FyaXR5JDAiLCJmbl9vZl9jdXN0b21fYXJpdHkiLCJvdXRwdXRfYWNjIiwicCQyIiwicCQzIiwicCQ0IiwiYnVmcHV0X2FjYyIsInN0cnB1dF9hY2MiLCJmYWlsd2l0aF9tZXNzYWdlIiwib3Blbl9ib3hfb2Zfc3RyaW5nIiwiaW52YWxpZF9ib3giLCJwYXJzZV9zcGFjZXMiLCJwYXJzZV9sd29yZCIsInBhcnNlX2ludCIsIndzdGFydCIsIndlbmQiLCJib3hfbmFtZSIsIm5zdGFydCIsIm5lbmQiLCJpbmRlbnQiLCJleHBfZW5kIiwiYm94X3R5cGUiLCJtYWtlX3BhZGRpbmdfZm10X2ViYiIsIm1ha2VfcGFkcHJlY19mbXRfZWJiIiwiZm10X2ViYl9vZl9zdHJpbmciLCJsZWdhY3lfYmVoYXZpb3IiLCJmbGFnIiwibGVnYWN5X2JlaGF2aW9yJDAiLCJpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIiwidW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IiwiZW5kX2luZCIsImludmFsaWRfZm9ybWF0X3dpdGhvdXQiLCJleHBlY3RlZF9jaGFyYWN0ZXIiLCJleHBlY3RlZCIsImFkZF9saXRlcmFsIiwibGl0X3N0YXJ0Iiwic2l6ZSIsInBhcnNlIiwic3RyX2luZCQyIiwicGFyc2VfZmxhZ3MiLCJzdHJfaW5kJDAiLCJwYXJzZV90YWciLCJwYXJzZV9nb29kX2JyZWFrIiwicGFyc2VfbWFnaWNfc2l6ZSIsInN0cl9pbmQkMSIsInBhcnNlX2NvbnZlcnNpb24iLCJwY3RfaW5kIiwicGx1cyIsInNwYWNlIiwicGFkcHJlYyIsInBsdXNfdXNlZCIsImhhc2hfdXNlZCIsInNwYWNlX3VzZWQiLCJpZ25fdXNlZCIsInBhZF91c2VkIiwicHJlY191c2VkIiwiZ2V0X3BsdXMiLCJnZXRfaGFzaCIsImdldF9zcGFjZSIsImdldF9pZ24iLCJnZXRfcGFkIiwiZ2V0X3ByZWMiLCJnZXRfcGFkcHJlYyIsImdldF9pbnRfcGFkIiwiaW5jb21wYXRpYmxlX2ZsYWciLCJjaGVja19ub18wIiwib3B0X29mX3BhZCIsIndpZHRoJDEiLCJnZXRfcGFkX29wdCIsImdldF9wYWRwcmVjX29wdCIsImZtdF9yZXN1bHQiLCJzdWJfZW5kIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZm10IiwiaWdub3JlZCQyIiwiY291bnRlciQwIiwiaWdub3JlZCQ2IiwiaWdub3JlZCQ3IiwiYWRkX3JhbmdlIiwiZmFpbF9zaW5nbGVfcGVyY2VudCIsInBhcnNlX2NoYXJfc2V0X2NvbnRlbnQiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyJDAiLCJwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIiwicmV2ZXJzZSIsIm5leHRfaW5kIiwiY2hhcl9zZXQkMSIsImlnbm9yZWQkOSIsImNoYXJfZm9ybWF0IiwiZm10X3Jlc3QkMjEiLCJmbXRfcmVzdCQyMiIsInBhZCQ5IiwiZm10X3Jlc3QkMjMiLCJpZ25vcmVkJDEwIiwiZm10X3Jlc3QkMjQiLCJwYWQkMTAiLCJmbXRfcmVzdCQyNSIsInN1Yl9lbmQkMCIsInN1Yl9mbXQkMCIsImZtdF9yZXN0JDI2IiwiaWdub3JlZCQxMSIsImlnbm9yZWQkMyIsInN5bWIkMCIsImlnbm9yZWQkNSIsImNvbXB1dGVfaW50X2NvbnYiLCJpZ25vcmVkJDgiLCJzcGFjZSQxIiwiaGFzaCQxIiwicGx1cyQyIiwia2luZCIsImlnbm9yZWQkNCIsImlnbm9yZWQiLCJpZ25vcmVkJDAiLCJpZ25vcmVkJDEiLCJwbHVzJDAiLCJzcGFjZSQwIiwicGx1cyQxIiwiaWduJDAiLCJwYXJzZV9hZnRlcl9wcmVjaXNpb24iLCJtaW51cyIsInBhcnNlX2NvbnYiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfbGl0ZXJhbCIsInBhcnNlX3Bvc2l0aXZlIiwibmV3X2luZCIsIm1pbnVzJDAiLCJzZXRfZmxhZyIsInN0cl9pbmQkMyIsInN0cl9pbmQkNCIsInN0cl9pbmQkNSIsImlzX29wZW5fdGFnIiwiaW5kIiwic3ViX3N0ciIsInN1Yl9mb3JtYXQkMCIsImZvcm1hdHRpbmckMCIsImZvcm1hdHRpbmciLCJzdHJfaW5kXzEiLCJwYXJzZV9pbnRlZ2VyIiwic3RyX2luZF8yIiwic3RyX2luZF8zIiwiZm9ybWF0dGluZ19saXQkMCIsInN0cl9pbmRfNCIsInN0cl9pbmRfNSIsInN1Yl9lbmQkMSIsInN1Yl9lbmQkMiIsInN0cl9pbmQkNiIsInN0cl9pbmQkNyIsIm9wdGlvbiIsInN1YmZtdCIsImZvcm1hdF9vZl9zdHJpbmdfZm10dHkiLCJmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCIsImtmcHJpbnRmIiwia2JwcmludGYiLCJpa2ZwcmludGYiLCJmcHJpbnRmIiwiYnByaW50ZiIsImlmcHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImFzc29jMyIsInkyIiwieTEiLCJzcGxpdCQwIiwibWFrZV9zeW1saXN0IiwicHJlZml4Iiwic3VmZml4IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJib29sX29mX3N0cmluZ19vcHQkMCIsImludF9vZl9zdHJpbmdfb3B0JDAiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfIiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsInByb2duYW1lIiwiZm9sbG93JDAiLCJhY3Rpb24iLCJrZXl3b3JkIiwibm9fYXJnJDAiLCJmb2xsb3ciLCJub19hcmciLCJnZXRfYXJnJDAiLCJnZXRfYXJnIiwiY29uc3VtZV9hcmckMCIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uJDAiLCJ0cmVhdF9hY3Rpb24iLCJmJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJyJDIiLCJhcmckMiIsImYkMyIsImFyZyQzIiwieCQxIiwiciQzIiwiYXJnJDQiLCJ4JDIiLCJzcGVjcyIsImYkNCIsImFyZyQ1IiwiZiQ1IiwiZiQ2IiwiYXJnJDYiLCJuZXdhcmciLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyIsInBhcnNlX2FyZ3ZfZHluYW1pYyIsImN1cnJlbnQkMCIsInBhcnNlX2FyZ3YiLCJtc2ckMCIsIm1zZyQxIiwicGFyc2VfZHluYW1pYyIsInBhcnNlX2V4cGFuZCIsInNlY29uZF93b3JkIiwibG9vcCIsIm1heF9hcmdfbGVuIiwiY3VyIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsInNlZW4iLCJhbGlnbiIsImxpbWl0IiwiY29tcGxldGVkIiwia3NkIiwiY3V0Y29sJDAiLCJzcGFjZXMkMCIsImN1dGNvbCIsImt3ZF9sZW4iLCJzcGFjZXMiLCJyZWFkX2F1eCIsInRyaW0iLCJmaWxlIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJ3cml0ZV9hcmciLCJ3cml0ZV9hcmcwIiwicHJpbnRlcnMiLCJmaWVsZCIsIm90aGVyX2ZpZWxkcyIsInVzZV9wcmludGVycyIsImNvbnYiLCJ0b19zdHJpbmdfZGVmYXVsdCIsImNoYXIkMCIsImxpbmUiLCJjaGFyJDEiLCJsaW5lJDAiLCJmaWxlJDAiLCJjaGFyJDIiLCJsaW5lJDEiLCJmaWxlJDEiLCJjb25zdHJ1Y3RvciIsInRvX3N0cmluZyQ3IiwicHJpbnQiLCJmY3QiLCJjYXRjaCQwIiwiY29udmVydF9yYXdfYmFja3RyYWNlIiwiYnQiLCJmb3JtYXRfYmFja3RyYWNlX3Nsb3QiLCJpbmZvIiwiaXNfcmFpc2UiLCJwcmludF9yYXdfYmFja3RyYWNlIiwib3V0Y2hhbiIsInJhd19iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJwcmludF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlX3RvX3N0cmluZyIsImJhY2t0cmFjZV9zbG90X2lzX3JhaXNlIiwiYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lIiwiYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24iLCJiYWNrdHJhY2Vfc2xvdHMiLCJnZXRfYmFja3RyYWNlIiwicmVnaXN0ZXJfcHJpbnRlciIsImZuIiwiZXhuX3Nsb3QiLCJleG5fc2xvdF9pZCIsImV4bl9zbG90X25hbWUiLCJ1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsInNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciIsImNvbnN0JDAiLCJmbGlwIiwibmVnYXRlIiwicHJvdGVjdCIsImZpbmFsbHkkMCIsIndvcmsiLCJmaW5hbGx5X25vX2V4biIsIndvcmtfZXhuIiwid29ya19idCIsInByaW50X3N0YXQiLCJhbGxvY2F0ZWRfYnl0ZXMiLCJtYSIsInBybyIsIm1pIiwiY3JlYXRlX2FsYXJtIiwiZGVsZXRlX2FsYXJtIiwic3RyaW5nIiwiYnl0ZXMiLCJzdWJzdHJpbmciLCJzdWJieXRlcyIsImZpbGVuYW1lIiwib3V0cHV0JDAiLCJkaWdlc3QiLCJpbnB1dCQwIiwiY2hhcl9oZXgiLCJ0b19oZXgiLCJmcm9tX2hleCIsImRpZ2l0IiwibmV3X3N0YXRlIiwiYXNzaWduIiwic3QxIiwic3QyIiwiZnVsbF9pbml0Iiwic2VlZCIsInNlZWQkMCIsIm1ha2UkMiIsIm1ha2Vfc2VsZl9pbml0IiwiY29weSQ1IiwiYml0cyIsImN1cnZhbCIsIm5ld3ZhbCIsIm5ld3ZhbDMwIiwiaW50JDAiLCJib3VuZCIsImludDMyIiwiYjEiLCJiMiIsImludDY0IiwiYjMiLCJuYXRpdmVpbnQiLCJmbG9hdCQwIiwiYm9vbCIsImJpdHMkMCIsImludCQxIiwiaW50MzIkMCIsIm5hdGl2ZWludCQwIiwiaW50NjQkMCIsImZsb2F0JDEiLCJzY2FsZSIsImJvb2wkMCIsImZ1bGxfaW5pdCQwIiwiaW5pdCQ0Iiwic2VsZl9pbml0IiwiZ2V0X3N0YXRlIiwic2V0X3N0YXRlIiwib25nb2luZ190cmF2ZXJzYWwiLCJmbGlwX29uZ29pbmdfdHJhdmVyc2FsIiwicGFyYW1zIiwicmFuZG9taXplZF9kZWZhdWx0IiwicmFuZG9taXplZCIsInJhbmRvbWl6ZSIsImlzX3JhbmRvbWl6ZWQiLCJwcm5nIiwiY3JlYXRlJDMiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjbGVhciQyIiwicmVzZXQkMCIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiY29weSQ2IiwibGVuZ3RoJDQiLCJyZXNpemUkMCIsImluZGV4ZnVuIiwib2RhdGEiLCJvc2l6ZSIsIm5zaXplIiwibmRhdGEiLCJuZGF0YV90YWlsIiwiaW5wbGFjZSIsImNlbGwkMCIsIm5pZHgiLCJtYXRjaCQwIiwiaXRlciQxMCIsImRvX2J1Y2tldCIsIm9sZF90cmF2IiwiZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCIsImZpbHRlcl9tYXBfaW5wbGFjZSIsImZvbGQkMyIsImIkMCIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsImhpc3RvIiwidG9fc2VxJDkiLCJ0YmxfZGF0YSIsImJ1Y2siLCJidWNrJDAiLCJidWNrJDEiLCJ0b19zZXFfa2V5cyIsInRvX3NlcV92YWx1ZXMiLCJrZXlfaW5kZXgiLCJidWNrZXQiLCJrMSIsIm5leHQxIiwiazIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsImZpbmRfYWxsIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwicmVwbGFjZV9zZXEiLCJjb3B5Iiwic3oiLCJoYXNoX3BhcmFtIiwic2VlZGVkX2hhc2giLCJhZGQkMCIsImZpbmQkMCIsImZpbmRfb3B0JDAiLCJmaW5kX2FsbCQwIiwibWVtJDIiLCJhZGRfc2VxJDIiLCJvZl9zZXEkNyIsIndlYWtfY3JlYXRlIiwibGVuZ3RoJDUiLCJyYWlzZV9pZl9pbnZhbGlkX29mZnNldCQwIiwic2V0IiwiZ2V0JDAiLCJnZXRfY29weSIsImNoZWNrJDAiLCJibGl0JDQiLCJmaWxsJDIiLCJhciIsImVtcHR5YnVja2V0IiwiZ2V0X2luZGV4Iiwic3okMCIsInN6JDEiLCJjb3VudF9idWNrZXQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiaW5kZXgiLCJidWNrZXQkMCIsImhhc2hlcyIsIm5ld3N6IiwibmV3YnVja2V0JDAiLCJuZXdoYXNoZXMiLCJoYnVja2V0IiwicHJldl9sZW4iLCJsaXZlIiwiaiQyIiwibmV3YnVja2V0IiwibmV3dCIsIm9iIiwib2giLCJzZXR0ZXIkMCIsIm5iIiwibmkiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsImZpbmRfc2hhZG93IiwiaWZmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJpZCQwIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwiYWR2YW5jZV9sZWZ0Iiwic2l6ZSQwIiwicGVuZGluZ19jb3VudCIsInNpemUkMSIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJpbml0aWFsaXplX3NjYW5fc3RhY2siLCJzdGFjayIsInF1ZXVlX2VsZW0iLCJzZXRfc2l6ZSIsImxlZnRfdG90YWwiLCJzY2FuX3B1c2giLCJlbGVtIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3N0YWciLCJwcF9jbG9zZV9zdGFnIiwicHBfb3Blbl90YWciLCJwcF9jbG9zZV90YWciLCJwcF9zZXRfcHJpbnRfdGFncyIsInBwX3NldF9tYXJrX3RhZ3MiLCJwcF9nZXRfcHJpbnRfdGFncyIsInBwX2dldF9tYXJrX3RhZ3MiLCJwcF9zZXRfdGFncyIsInBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBjdCIsInBvdCIsIm1jdCIsIm1vdCIsInBwX3Jpbml0IiwicHBfZmx1c2hfcXVldWUiLCJwcF9wcmludF9hc19zaXplIiwicHBfcHJpbnRfYXMiLCJpc2l6ZSIsInBwX3ByaW50X3N0cmluZyIsInBwX3ByaW50X2ludCIsInBwX3ByaW50X2Zsb2F0IiwicHBfcHJpbnRfYm9vbCIsInBwX3ByaW50X2NoYXIiLCJwcF9vcGVuX2hib3giLCJwcF9vcGVuX3Zib3giLCJwcF9vcGVuX2h2Ym94IiwicHBfb3Blbl9ob3Zib3giLCJwcF9vcGVuX2JveCIsInBwX3ByaW50X25ld2xpbmUiLCJwcF9wcmludF9mbHVzaCIsInBwX2ZvcmNlX25ld2xpbmUiLCJwcF9wcmludF9pZl9uZXdsaW5lIiwicHBfcHJpbnRfY3VzdG9tX2JyZWFrIiwicHBfcHJpbnRfYnJlYWsiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2N1dCIsInBwX29wZW5fdGJveCIsInBwX2Nsb3NlX3Rib3giLCJwcF9wcmludF90YnJlYWsiLCJwcF9wcmludF90YWIiLCJwcF9zZXRfdGFiIiwicHBfc2V0X21heF9ib3hlcyIsInBwX2dldF9tYXhfYm94ZXMiLCJwcF9vdmVyX21heF9ib3hlcyIsInBwX3NldF9lbGxpcHNpc190ZXh0IiwicHBfZ2V0X2VsbGlwc2lzX3RleHQiLCJwcF9saW1pdCIsInBwX3NldF9tYXhfaW5kZW50IiwicHBfZ2V0X21heF9pbmRlbnQiLCJwcF9zZXRfbWFyZ2luIiwibmV3X21heF9pbmRlbnQiLCJjaGVja19nZW9tZXRyeSIsImdlb21ldHJ5IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9nZW9tZXRyeSIsIm1heF9pbmRlbnQiLCJtYXJnaW4iLCJwcF9zYWZlX3NldF9nZW9tZXRyeSIsInBwX2dldF9nZW9tZXRyeSIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsInBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsImRpc3BsYXlfbmV3bGluZSIsImJsYW5rX2xpbmUiLCJkaXNwbGF5X2luZGVudCIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzY2FuX3N0YWNrIiwiZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMiLCJvdXRfZnVucyIsIm1ha2VfZm9ybWF0dGVyIiwib3V0cHV0IiwiZmx1c2giLCJwcGYiLCJmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwiLCJmb3JtYXR0ZXJfb2ZfYnVmZmVyIiwicHBfYnVmZmVyX3NpemUiLCJwcF9tYWtlX2J1ZmZlciIsInN0ZGJ1ZiIsInN0ZF9mb3JtYXR0ZXIiLCJlcnJfZm9ybWF0dGVyIiwic3RyX2Zvcm1hdHRlciIsImZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIiLCJmbHVzaF9zdHJfZm9ybWF0dGVyIiwibWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsInNvYiIsImdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIml0ZW1zIiwiYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIiwiaXRlbSIsImZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYiIsIm9wZW5faGJveCIsIm9wZW5fdmJveCIsIm9wZW5faHZib3giLCJvcGVuX2hvdmJveCIsIm9wZW5fYm94IiwiY2xvc2VfYm94Iiwib3Blbl90YWciLCJjbG9zZV90YWciLCJvcGVuX3N0YWciLCJjbG9zZV9zdGFnIiwicHJpbnRfYXMiLCJwcmludF9zdHJpbmckMCIsInByaW50X2ludCQwIiwicHJpbnRfZmxvYXQkMCIsInByaW50X2NoYXIkMCIsInByaW50X2Jvb2wiLCJwcmludF9icmVhayIsInByaW50X2N1dCIsInByaW50X3NwYWNlIiwiZm9yY2VfbmV3bGluZSIsInByaW50X2ZsdXNoIiwicHJpbnRfbmV3bGluZSQwIiwicHJpbnRfaWZfbmV3bGluZSIsIm9wZW5fdGJveCIsImNsb3NlX3Rib3giLCJwcmludF90YnJlYWsiLCJzZXRfdGFiIiwicHJpbnRfdGFiIiwic2V0X21hcmdpbiIsImdldF9tYXJnaW4iLCJzZXRfbWF4X2luZGVudCIsImdldF9tYXhfaW5kZW50Iiwic2V0X2dlb21ldHJ5Iiwic2FmZV9zZXRfZ2VvbWV0cnkiLCJnZXRfZ2VvbWV0cnkiLCJzZXRfbWF4X2JveGVzIiwiZ2V0X21heF9ib3hlcyIsIm92ZXJfbWF4X2JveGVzIiwic2V0X2VsbGlwc2lzX3RleHQiLCJnZXRfZWxsaXBzaXNfdGV4dCIsInNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsInNldF9wcmludF90YWdzIiwiZ2V0X3ByaW50X3RhZ3MiLCJzZXRfbWFya190YWdzIiwiZ2V0X21hcmtfdGFncyIsInNldF90YWdzIiwicHBfcHJpbnRfbGlzdCIsInBwX3YiLCJvcHQkMCIsInBwX3NlcCIsInZzIiwib3B0JDEiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0Iiwib3V0cHV0X2FjYyQwIiwiYnR5IiwicCQ1IiwicCQ2Iiwic3RycHV0X2FjYyQwIiwia2ZwcmludGYkMCIsImlrZnByaW50ZiQwIiwiaWZwcmludGYkMCIsImZwcmludGYkMCIsInByaW50ZiQwIiwiZXByaW50ZiQwIiwia2RwcmludGYiLCJkcHJpbnRmIiwia3ByaW50ZiIsInNwcmludGYkMCIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwiZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyIsInBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImJwcmludGYkMCIsInBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInN0cmluZ2lmeSIsInBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImZ1bnMiLCJtYXJrX29wZW5fdGFnIiwibWFya19jbG9zZV90YWciLCJwcmludF9vcGVuX3RhZyIsInByaW50X2Nsb3NlX3RhZyIsInNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwiZm5hbWUiLCJjaGFyX2NvdW50IiwicmVzZXRfdG9rZW4iLCJpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciIsInRva2VuX3N0cmluZyIsInRva2VuX2J1ZmZlciIsInNraXBfY2hhciIsImlnbm9yZV9jaGFyIiwic3RvcmVfY2hhciIsImRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUiLCJjcmVhdGUkNCIsImluYW1lIiwiZnJvbV9zdHJpbmckMSIsImZyb21fZnVuY3Rpb24kMCIsInNjYW5fY2xvc2VfYXRfZW5kIiwic2Nhbl9yYWlzZV9hdF9lbmQiLCJmcm9tX2ljIiwic2Nhbl9jbG9zZV9pYyIsImVvZiIsInN0ZGliIiwib3Blbl9pbl9maWxlIiwib3Blbl9pbiIsImZyb21fZmlsZSIsImZyb21fZmlsZV9iaW4iLCJmcm9tX2NoYW5uZWwkMCIsImNsb3NlX2luJDAiLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9pYyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwic2Nhbl9jaGFyIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3JfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIiwic2Nhbl9iYWNrc2xhc2hfY2hhciIsImMwIiwiZ2V0X2RpZ2l0IiwiZ2V0X2RpZ2l0JDAiLCJjMSQwIiwiYzIkMCIsInNjYW5fY2FtbF9jaGFyIiwiZmluZF9zdG9wIiwic2Nhbl9jYW1sX3N0cmluZyIsImZpbmRfc3RvcCQwIiwic2tpcF9zcGFjZXMiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJnZXRfY291bnRlciIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwiZm10JDIzIiwiZm10JDI0IiwiZm10JDI1IiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsInBhZF9wcmVjX3NjYW5mIiwicmVhZGVycyIsInNjYW4iLCJtYWtlX3NjYW5mIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJzY2FuJDEiLCJzY2FuJDIiLCJzY2FuJDMiLCJzY2FuJDQiLCJjb252JDAiLCJzY2FuJDUiLCJjb252JDEiLCJzY2FuJDYiLCJjb252JDIiLCJzY2FuJDciLCJzY2FuJDgiLCJmbXRpbmdfbGl0JDAiLCJzdHAkMCIsInMkMiIsInN0cl9yZXN0JDAiLCJyZXN0JDI2IiwiYXJnX3Jlc3QiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwiYnNjYW5mIiwia3NzY2FuZiIsInNzY2FuZiIsInNjYW5mIiwiYnNjYW5mX2Zvcm1hdCIsImZvcm1hdCIsInNzY2FuZl9mb3JtYXQiLCJmb3JtYXRfZnJvbV9zdHJpbmciLCJ1bmVzY2FwZWQiLCJrZnNjYW5mIiwiZnNjYW5mIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJwYXJhbXMkMCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJkdW1teV9pdGVtIiwidGFnIiwiY29tcGFyZSQxMSIsImNvbXBhcmUkMTIiLCJjb21wYXJlJDEzIiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwidG9fbGlzdCQzIiwiYXJyIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfc2xvdCIsIm5ld192YXJpYWJsZSIsInRvX2FycmF5IiwibmV3X21ldGhvZHNfdmFyaWFibGVzIiwibWV0aHMiLCJ2YWxzIiwibWV0aHMkMCIsIm5tZXRocyIsIm52YWxzIiwiZ2V0X3ZhcmlhYmxlIiwiZ2V0X3ZhcmlhYmxlcyIsImFkZF9pbml0aWFsaXplciIsImNyZWF0ZV90YWJsZSIsInB1YmxpY19tZXRob2RzIiwidGFncyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInN1cGVyJDAiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0IiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsInJ1bl9pbml0aWFsaXplcnMiLCJpbml0cyIsInJ1bl9pbml0aWFsaXplcnNfb3B0IiwiY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpIiwiZ2V0X2RhdGEkMCIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJ0YWJsZXMkMiIsInRhYmxlcyQwIiwidGFibGVzJDEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsImNsbyQwIiwibiQyIiwibiQzIiwibiQ0IiwibiQ1IiwibiQ2IiwieCQzIiwibiQ3IiwieCQ0IiwibiQ4IiwiZiQ3IiwibiQ5IiwieCQ1IiwiZiQ4IiwiZSQyIiwibiQxMCIsIngkNiIsImYkOSIsIm4kMTEiLCJ4JDciLCJuJDEyIiwieCQ4IiwibiQxMyIsIm4kMTQiLCJlJDMiLCJuJDE1IiwibSQyIiwieCQ5IiwibSQzIiwibiQxNiIsIm0kNCIsImUkNCIsIm4kMTciLCJtJDUiLCJuJDE4Iiwic3RhdHMkMCIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImtleXdvcmRfb3JfZXJyb3IiLCJlbmRfZXhwb25lbnRfcGFydCIsImV4cG9uZW50X3BhcnQiLCJudW1iZXIiLCJpZGVudDIiLCJuZWdfbnVtYmVyIiwibmV4dF90b2tlbiQwIiwiZXNjYXBlIiwibWF5YmVfY29tbWVudCIsImNvbW1lbnQiLCJuZXh0X3Rva2VuIiwiaW5wdXQiLCJoa2V5IiwiY2xlYW4iLCJpbnNlcnRfYnVja2V0IiwiY29udGFpbmVyIiwicmVtb3ZlX2J1Y2tldCIsImhrIiwicmVwbGFjZV9idWNrZXQiLCJuZXdfZCIsImJ1Y2tldF9sZW5ndGhfYWxpdmUiLCJzdGF0c19hbGl2ZSIsImNyZWF0ZSQ1IiwiZ2V0X2tleSQwIiwiZ2V0X2tleV9jb3B5JDAiLCJzZXRfa2V5JDAiLCJ1bnNldF9rZXkkMCIsImNoZWNrX2tleSQwIiwiYmxpdF9rZXkkMCIsImdldF9kYXRhJDEiLCJnZXRfZGF0YV9jb3B5Iiwic2V0X2RhdGEiLCJ1bnNldF9kYXRhIiwiY2hlY2tfZGF0YSIsImJsaXRfZGF0YSIsInNldF9rZXlfZGF0YSIsImNyZWF0ZSQ2IiwiZ2V0X2tleTEiLCJnZXRfa2V5MV9jb3B5Iiwic2V0X2tleTEiLCJ1bnNldF9rZXkxIiwiY2hlY2tfa2V5MSIsImdldF9rZXkyIiwiZ2V0X2tleTJfY29weSIsInNldF9rZXkyIiwidW5zZXRfa2V5MiIsImNoZWNrX2tleTIiLCJibGl0X2tleTEiLCJibGl0X2tleTIiLCJibGl0X2tleTEyIiwiZ2V0X2RhdGEkMiIsImdldF9kYXRhX2NvcHkkMCIsInNldF9kYXRhJDAiLCJ1bnNldF9kYXRhJDAiLCJjaGVja19kYXRhJDAiLCJibGl0X2RhdGEkMCIsImsyJDAiLCJrMSQwIiwiY3JlYXRlJDciLCJsZW5ndGgkNiIsImdldF9rZXkkMSIsImdldF9rZXlfY29weSQxIiwic2V0X2tleSQxIiwidW5zZXRfa2V5JDEiLCJjaGVja19rZXkkMSIsImJsaXRfa2V5JDEiLCJnZXRfZGF0YSQzIiwiZ2V0X2RhdGFfY29weSQxIiwic2V0X2RhdGEkMSIsInVuc2V0X2RhdGEkMSIsImNoZWNrX2RhdGEkMSIsImJsaXRfZGF0YSQxIiwia2kiLCJrMCIsImdlbmVyaWNfYmFzZW5hbWUiLCJpc19kaXJfc2VwIiwiZ2VuZXJpY19kaXJuYW1lIiwiaXNfcmVsYXRpdmUiLCJpc19pbXBsaWNpdCIsImNoZWNrX3N1ZmZpeCIsInN1ZmYiLCJjaG9wX3N1ZmZpeF9vcHQiLCJsZW5fcyIsImxlbl9mIiwicXVvdGUiLCJxdW90ZV9jb21tYW5kIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJiYXNlbmFtZSIsImRpcm5hbWUiLCJpc19kaXJfc2VwJDAiLCJpc19yZWxhdGl2ZSQwIiwiaXNfaW1wbGljaXQkMCIsImNoZWNrX3N1ZmZpeCQwIiwiY2hvcF9zdWZmaXhfb3B0JDAiLCJ0ZW1wX2Rpcl9uYW1lIiwicXVvdGUkMCIsImFkZF9icyIsImxvb3AkMCIsImxvb3BfYnMiLCJxdW90ZV9jbWRfZmlsZW5hbWUiLCJxdW90ZV9jb21tYW5kJDAiLCJkcml2ZV9hbmRfcGF0aCIsImRpcm5hbWUkMCIsInBhdGgiLCJkcml2ZSIsImRpciIsImJhc2VuYW1lJDAiLCJiYXNlbmFtZSQxIiwiZGlybmFtZSQxIiwibnVsbCQzIiwiY3VycmVudF9kaXJfbmFtZSQyIiwicGFyZW50X2Rpcl9uYW1lJDIiLCJkaXJfc2VwJDIiLCJpc19kaXJfc2VwJDEiLCJpc19yZWxhdGl2ZSQxIiwiaXNfaW1wbGljaXQkMSIsImNoZWNrX3N1ZmZpeCQxIiwiY2hvcF9zdWZmaXhfb3B0JDEiLCJ0ZW1wX2Rpcl9uYW1lJDAiLCJxdW90ZSQxIiwicXVvdGVfY29tbWFuZCQxIiwiYmFzZW5hbWUkMiIsImRpcm5hbWUkMiIsImNvbmNhdCQzIiwiY2hvcF9zdWZmaXgiLCJleHRlbnNpb25fbGVuIiwiZXh0ZW5zaW9uIiwiY2hvcF9leHRlbnNpb24iLCJyZW1vdmVfZXh0ZW5zaW9uIiwicHJuZyQwIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJ0cnlfbmFtZSIsImNvdW50ZXIkMSIsIm9wZW5fdGVtcF9maWxlIiwic3RoJDAiLCJwZXJtcyIsInN0aCQxIiwiYWRkJDEiLCJzdWIkNCIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJpbnYiLCJub3JtMiIsIm5vcm0iLCJxJDAiLCJwb2xhciIsInNxcnQiLCJ3JDAiLCJleHAiLCJsb2ciLCJwb3ciLCJlbmFibGVkIiwiaWZfc3BhY2V0aW1lX2VuYWJsZWQiLCJjcmVhdGUkOCIsImNoYW5uZWwiLCJzYXZlX2V2ZW50IiwidGltZSIsImV2ZW50X25hbWUiLCJzYXZlX2FuZF9jbG9zZSIsInRha2UkMCIsImNsb3NlZCIsInNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwcyIsImZsb2F0MzIiLCJmbG9hdDY0IiwiaW50OF9zaWduZWQiLCJpbnQ4X3Vuc2lnbmVkIiwiaW50MTZfc2lnbmVkIiwiaW50MTZfdW5zaWduZWQiLCJpbnQzMiQxIiwiaW50NjQkMSIsImludCQyIiwibmF0aXZlaW50JDEiLCJjb21wbGV4MzIiLCJjb21wbGV4NjQiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjX2xheW91dCIsImZvcnRyYW5fbGF5b3V0IiwiZGltcyIsInNpemVfaW5fYnl0ZXMiLCJjcmVhdGUkOSIsImxheW91dCIsImdldCQxIiwic2V0JDAiLCJzaXplX2luX2J5dGVzJDAiLCJvZl92YWx1ZSIsImNyZWF0ZSQxMCIsImRpbSIsInNpemVfaW5fYnl0ZXMkMSIsInNsaWNlIiwib2ZfYXJyYXkiLCJiYSIsImNyZWF0ZSQxMSIsImRpbTEiLCJkaW0yIiwic2l6ZV9pbl9ieXRlcyQyIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0Iiwib2ZfYXJyYXkkMCIsInJvdyIsImNyZWF0ZSQxMiIsImRpbTMiLCJzaXplX2luX2J5dGVzJDMiLCJzbGljZV9sZWZ0XzEiLCJzbGljZV9yaWdodF8xIiwic2xpY2VfbGVmdF8yIiwic2xpY2VfcmlnaHRfMiIsIm9mX2FycmF5JDEiLCJjb2wiLCJhcnJheTBfb2ZfZ2VuYXJyYXkiLCJhcnJheTFfb2ZfZ2VuYXJyYXkiLCJhcnJheTJfb2ZfZ2VuYXJyYXkiLCJhcnJheTNfb2ZfZ2VuYXJyYXkiLCJyZXNoYXBlXzAiLCJyZXNoYXBlXzEiLCJyZXNoYXBlXzIiLCJyZXNoYXBlXzMiLCJ0YXJpZiIsImRlc3RpbmF0YWlyZXMiLCJwaWVjZXMiLCJmb3Vybml0dXJlcyIsInNob3J0X3N0cmluZ19vZl9waWVjZSIsImxvbmdfc3RyaW5nX29mX3BpZWNlIiwiam9vX2dsb2JhbF9vYmplY3QiLCJudWxsIiwidW5kZWZpbmVkIiwiZXhuIiwiZXZlbnQiLCJzZXRfc3RyaW5nX2lucHV0X2J5X2lkIiwibm0iLCJ2IiwiaW5wIiwicmVhZF9zdHJpbmdfaW5wdXRfYnlfaWQiLCJ6ZXJvX2ludF9pbnB1dF9ieV9pZCIsInJlYWRfaW50X2lucHV0X2J5X2lkIiwic2V0X3RkX2J5X2lkIiwidGQiLCJmaWVsZF9pZF9ieV9mb3Vybml0dXJlIiwiZiIsInAiLCJmaWVsZF9pZF9hbmRfcGllY2VfYnlfZm91cm5pdHUiLCJhbGxfbmFtZXMiLCJlbWFpbF9ib2R5IiwiYiIsInNob3J0JDAiLCJmaWVsZF9pZCIsImRldGFpbCIsInMiLCJxIiwiZGVzY3IiLCJ0b3RhbCIsInVwZGF0ZV9tc2ciLCJhIiwiY29tcHV0ZSIsInF0ZSIsInJlc2V0X2Zvcm0iLCJkb2l0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vK2ludDY0LmpzIiwiL2J1aWx0aW4vK21sQnl0ZXMuanMiLCIvYnVpbHRpbi8rZmFpbC5qcyIsIi9idWlsdGluLytzdGRsaWIuanMiLCIvYnVpbHRpbi8rZm9ybWF0LmpzIiwiL2J1aWx0aW4vK2llZWVfNzU0LmpzIiwiL2J1aWx0aW4vK2ZzLmpzIiwiL2J1aWx0aW4vK3N5cy5qcyIsIi9idWlsdGluLytmc19mYWtlLmpzIiwiL2J1aWx0aW4vK2ZzX25vZGUuanMiLCIvYnVpbHRpbi8rbmF0LmpzIiwiL2J1aWx0aW4vK2dyYXBoaWNzLmpzIiwiL2J1aWx0aW4vK21hcnNoYWwuanMiLCIvYnVpbHRpbi8raW8uanMiLCIvYnVpbHRpbi8rZ2MuanMiLCIvYnVpbHRpbi8rYmlnYXJyYXkuanMiLCIvYnVpbHRpbi8ranNsaWIuanMiLCIvYnVpbHRpbi8rcGFyc2luZy5qcyIsIi9idWlsdGluLytqc2xpYl9qc19vZl9vY2FtbC5qcyIsIi9idWlsdGluLyt1bml4LmpzIiwiL2J1aWx0aW4vK2ludHMuanMiLCIvYnVpbHRpbi8raGFzaC5qcyIsIi9idWlsdGluLytjb21wYXJlLmpzIiwiL2J1aWx0aW4vK2ludGVybmFsTW9kLmpzIiwiL2J1aWx0aW4vK29iai5qcyIsIi9idWlsdGluLytiaWdzdHJpbmcuanMiLCIvYnVpbHRpbi8rYmFja3RyYWNlLmpzIiwiL2J1aWx0aW4vK2xleGluZy5qcyIsIi9idWlsdGluLythcnJheS5qcyIsIi9idWlsdGluLyt3ZWFrLmpzIiwiL2J1aWx0aW4vK21kNS5qcyIsIi9idWlsdGluLytzdHIuanMiLCIvYnVpbHRpbi8rYmlnc3RyaW5nLWNzdHJ1Y3QuanMiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2ludDY0Lm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvbGV4aW5nLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0Lm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvcHJpbnRleGMubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9maWxlbmFtZS5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2NvbXBsZXgubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9zdGRsaWIubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2xpc3QubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9zZXEubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9vcHRpb24ubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9yZXN1bHQubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9ib29sLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvY2hhci5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2J5dGVzLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvdW5pdC5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL21hcnNoYWwubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9vYmoubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2ludC5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2ludDMyLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvcGFyc2luZy5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL3NldC5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL21hcC5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL3N0YWNrLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvcXVldWUubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxMYXp5Lm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvbGF6eS5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL3N0cmVhbS5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2J1ZmZlci5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL3ByaW50Zi5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2FyZy5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2Z1bi5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2djLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvZGlnZXN0Lm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvaGFzaHRibC5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL3dlYWsubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9zY2FuZi5tbCIsIi9ob21lL21hdHQvLm9wYW0vNC4xMC4wK2ZsYW1iZGEvbGliL29jYW1sL2NhbGxiYWNrLm1sIiwiL2hvbWUvbWF0dC8ub3BhbS80LjEwLjArZmxhbWJkYS9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9nZW5sZXgubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9lcGhlbWVyb24ubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9zcGFjZXRpbWUubWwiLCIvaG9tZS9tYXR0Ly5vcGFtLzQuMTAuMCtmbGFtYmRhL2xpYi9vY2FtbC9iaWdhcnJheS5tbCIsIi9ob21lL21hdHQvcHJvamV0cy9sb2NhdGlvbl9kdWJ1dmFsL19idWlsZC9kZWZhdWx0L2ludmVudGFpcmVfbGluZ2UvaW52ZW50YWlyZV9saW5nZS5tbCIsIiIsIi9ob21lL21hdHQvcHJvamV0cy9sb2NhdGlvbl9kdWJ1dmFsL19idWlsZC9kZWZhdWx0L21lY2hhbmljL21lY2hhbmljLm1sIl0sIm1hcHBpbmdzIjoiOzs7O0lBME9BLFNBQVNBLG1CQUFtQkMsR0FBSyxTQUFRLFVBQVk7SUN6THJELFNBQVNDLGdCQUFnQkMsRUFBR0M7TUFDMUIsR0FBR0QsT0FBUTtNQUNYLEdBQUlDLFNBQVUsT0FBUSxTQUFTRDtNQUMvQixJQUFNLEtBQVE7TUFDZDtPQUFRLENBQ04sR0FBSUEsTUFBT0UsS0FBS0Q7UUFDaEJEO1FBQ0EsR0FBSUEsT0FBUSxPQUFPRTtRQUNuQkQsS0FBS0E7UUFDTEU7UUFDQSxHQUFJQSxPQUFRLGFBTWhCO0lEN0NBLElBQUlDLGtCQUFvQjtJRUF4QixTQUFTRSxvQkFBcUJDLEtBQU8sTUFBTUEsR0FBSztJQzJDaEQsSUFBSUM7SURSSixTQUFTQztNQUNQLG9CQUFvQkQsa0NBQ3RCO0lGakNBLFNBQVNFLFFBQVNDLEdBQUdDLEdBQUdDO01BQ3RCQyxVQUFVSCxjQUNWRyxVQUFVRixjQUNWRSxVQUFVRCxXQUNaO0lBQ0FIO0lBQ0FBOztlQUNFLFdBQVdBLFFBQVFJLFFBQVFBLFFBQVFBLFFBRFo7SUFJekJKOzthQUF1Q1o7TUFD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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2tCSzRoQztLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3dCQUM7S0FDQUM7S0FDQUM7S0FJQUM7S0FDQUM7Ozs7S0N6QkFDO0tBb0hBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NtOUVNQztLQVFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2xsRmRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDc0VFQztLQUNBQztLQUNBQztLQUNBQzs7O0tBL0VZQztLQXFIWkM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQW1JQUM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQzFQRkM7S0FDQUM7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQ0NDRzs7S0RERCxXQ0NDQztLRERELElDQ0NDO0lEREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQ0NZQyxLQUFPLE1BQU1BLEdBQXZCO0lEREY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQ0NDQyxNREREOzs7Ozs7Ozs7O3lCQ0NDQSxNREREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QW9DYTtJQXhDSCxTQTBDWlE7TUFFQTs7Ozs7UUFLRTs7U0FHb0Q7U0FBOUM7U0FEWTtRQUNpRCxPQUpoRUM7O2VBSWdFLHdCQUQvRDtNQUpFLFFBSzZEO0lBcER6RCxTQXVEWkM7TUFDRjttQkFDT2Y7UUFDSCwrQkFER0EsR0FDSDtxQkFDdUJTLEVBQUVGO1VBQWdCLE9BQWxCRSxJQUFrQixxQkFBaEJGLGFBQTZDO1FBRHRFOztTQUd3QiwwQkFBeEIsU0FET1MsSUFISmhCO1NBSW9CO1FBQXZCLGFBSkdBO1FBQ0gsUUFJQSxzQkFGT2dCO1FBRTJCLDBDQUwvQmhCLGtCQUttRDtNQU4xRDs7bUJBU09ZLE1BQU1aO1FBQ1QsK0JBRFNBLEdBQ1Q7cUJBQ3VCUyxFQUFFRjtVQUFnQixPQUFsQkUsSUFBa0IscUJBQWhCRixhQUE2QztRQUR0RTtlQURHSyxRQUNILFNBRFNaLGFBR3FCO01BSmxDOzs7OzBCQU9hO0lBdkVDLFNBeUVaaUI7TUFFQTtPQURFQztRQUNGO1VBQ0U7OztNQURGLE9BREVBO2dCQU1GO2dCQUNBO2dCQUNBO2dCQUNBLDJCQXRIQXZCLHFCQW1DQVE7Z0JBbUZBO2VBVEVlLElBVVU7SUFHZCwwQ0FoQ0VIO0lBaUNGLDZDQWZFRTtJQWVGOzs7T0EzSUUzQjtPQVFBSTtPQVFBQztPQVFBQztPQVFBQztPQVFBRTtPQUtBRztPQU1BQztPQUdBQztPQXVDQVM7T0FhQUU7T0FrQkFFO0lBZUY7VUQ5SUgiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZmZzZXRcbnZhciBjYW1sX2ludDY0X29mZnNldCA9IE1hdGgucG93KDIsIC0yNCk7XG5cbi8vUHJvdmlkZXM6IE1sSW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBNbEludDY0IChsbyxtaSxoaSkge1xuICB0aGlzLmxvID0gbG8gJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9IG1pICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSBoaSAmIDB4ZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfalwiXG5NbEludDY0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyx0aGlzLm1pLHRoaXMuaGkpO1xufVxuXG5NbEludDY0LnByb3RvdHlwZS51Y29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIGlmICh0aGlzLmhpID4geC5oaSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmhpIDwgeC5oaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBoaSA9IHRoaXMuaGkgPDwgMTY7XG4gIHZhciB4aGkgPSB4LmhpIDw8IDE2O1xuICBpZiAoaGkgPiB4aGkpIHJldHVybiAxO1xuICBpZiAoaGkgPCB4aGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvID0gLSB0aGlzLmxvO1xuICB2YXIgbWkgPSAtIHRoaXMubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSAtIHRoaXMuaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICsgeC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSArIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpICsgeC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gLSB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pIC0geC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgLSB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAqIHgubG87XG4gIHZhciBtaSA9ICgobG8gKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMubWkgKiB4LmxvICsgdGhpcy5sbyAqIHgubWk7XG4gIHZhciBoaSA9ICgobWkgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHRoaXMuaGkgKiB4LmxvICsgdGhpcy5taSAqIHgubWkgKyB0aGlzLmxvICogeC5oaTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubG98dGhpcy5taXx0aGlzLmhpKSA9PSAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5oaSA8PCAxNikgPCAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8gJiB4LmxvLCB0aGlzLm1pICYgeC5taSwgdGhpcy5oaSAmIHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb3x4LmxvLCB0aGlzLm1pfHgubWksIHRoaXMuaGl8eC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sb154LmxvLCB0aGlzLm1pXngubWksIHRoaXMuaGleeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9sZWZ0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpIHtcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMubG8gPDwgcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IHMpIHwgKHRoaXMubG8gPj4gKDI0IC0gcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaGkgPDwgcykgfCAodGhpcy5taSA+PiAoMjQgLSBzKSkpO1xuICB9XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICgwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sbyA8PCAocyAtIDI0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLm1pIDw8IChzIC0gMjQpKSB8ICh0aGlzLmxvID4+ICg0OCAtIHMpKSk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCgwLCAwLCB0aGlzLmxvIDw8IChzIC0gNDgpKVxufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHRfdW5zaWduZWQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8ICh0aGlzLmhpIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IHMpKTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gKHMgLSAyNCkpLFxuICAgICAgMCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5oaSA+PiAocyAtIDQ4KSwgMCwgMCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICB2YXIgaCA9ICh0aGlzLmhpIDw8IDE2KSA+PiAxNjtcbiAgaWYgKHMgPCAyNClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubG8gPj4gcykgfCAodGhpcy5taSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5taSA+PiBzKSB8IChoIDw8ICgyNCAtIHMpKSxcbiAgICAgICgodGhpcy5oaSA8PCAxNikgPj4gcykgPj4+IDE2KTtcbiAgdmFyIHNpZ24gPSAodGhpcy5oaSA8PCAxNikgPj4gMzE7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDI0KSA+PiAxNixcbiAgICAgIHNpZ24gJiAweGZmZmYpO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKCh0aGlzLmhpIDw8IDE2KSA+PiAocyAtIDMyKSwgc2lnbiwgc2lnbik7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc2wxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhpID0gKHRoaXMuaGkgPDwgMSkgfCAodGhpcy5taSA+PiAyMyk7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPDwgMSkgfCAodGhpcy5sbyA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNyMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSkgfCAodGhpcy5taSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSAoKHRoaXMubWkgPj4+IDEpIHwgKHRoaXMuaGkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gdGhpcy5oaSA+Pj4gMTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnVkaXZtb2QgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIG1vZHVsdXMgPSB0aGlzLmNvcHkoKTtcbiAgdmFyIGRpdmlzb3IgPSB4LmNvcHkoKTtcbiAgdmFyIHF1b3RpZW50ID0gbmV3IE1sSW50NjQoMCwwLDApO1xuICB3aGlsZSAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBkaXZpc29yLmxzbDEoKTtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID49IDApIHtcbiAgICBvZmZzZXQgLS07XG4gICAgcXVvdGllbnQubHNsMSgpO1xuICAgIGlmIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID49IDApIHtcbiAgICAgIHF1b3RpZW50LmxvICsrO1xuICAgICAgbW9kdWx1cyA9IG1vZHVsdXMuc3ViKGRpdmlzb3IpO1xuICAgIH1cbiAgICBkaXZpc29yLmxzcjEoKTtcbiAgfVxuICByZXR1cm4geyBxdW90aWVudCA6IHF1b3RpZW50LCBtb2R1bHVzIDogbW9kdWx1cyB9O1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaSBeIHkuaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgcSA9IHgudWRpdm1vZCh5KS5xdW90aWVudDtcbiAgaWYgKHNpZ24gJiAweDgwMDApIHEgPSBxLm5lZygpO1xuICByZXR1cm4gcTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGk7XG4gIGlmICh4LmhpICYgMHg4MDAwKSB4ID0geC5uZWcoKTtcbiAgaWYgKHkuaGkgJiAweDgwMDApIHkgPSB5Lm5lZygpO1xuICB2YXIgciA9IHgudWRpdm1vZCh5KS5tb2R1bHVzO1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgciA9IHIubmVnKCk7XG4gIHJldHVybiByO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKHRoaXMubWkgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5oaSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB0aGlzLm1pICogTWF0aC5wb3coMiwgMjQpKSArIHRoaXMubG87XG59XG5NbEludDY0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3RoaXMuaGkgPj4gOCxcbiAgICAgICAgICB0aGlzLmhpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pID4+IDE2LFxuICAgICAgICAgICh0aGlzLm1pID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLm1pICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvID4+IDE2LFxuICAgICAgICAgICh0aGlzLmxvID4+IDgpICYgMHhmZixcbiAgICAgICAgICB0aGlzLmxvICYgMHhmZl07XG59XG5NbEludDY0LnByb3RvdHlwZS5sbzMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICgodGhpcy5taSAmIDB4ZmYpIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmhpMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMubWkgPj4+IDgpICYgMHhmZmZmKSB8ICh0aGlzLmhpIDw8IDE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdWx0KHgseSkgeyByZXR1cm4geC51Y29tcGFyZSh5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5LCB0b3RhbCkgeyByZXR1cm4geC5jb21wYXJlKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7IHJldHVybiB4Lm5lZygpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7IHJldHVybiB4LmFkZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc3ViIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3N1YiAoeCwgeSkgeyByZXR1cm4geC5zdWIoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X211bCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbXVsKHgseSkgeyByZXR1cm4geC5tdWwoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX3plcm8gY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfemVybyh4KSB7IHJldHVybiAreC5pc1plcm8oKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHsgcmV0dXJuICt4LmlzTmVnKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7IHJldHVybiB4LmFuZCh5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29yICh4LCB5KSB7IHJldHVybiB4Lm9yKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkgeyByZXR1cm4geC54b3IoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfbGVmdCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9sZWZ0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodF91bnNpZ25lZChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2RpdiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9kaXYgKHgsIHkpIHsgcmV0dXJuIHguZGl2KHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tb2QgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbW9kICh4LCB5KSB7IHJldHVybiB4Lm1vZCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfaW50MzIgKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHggJiAweGZmZmZmZiwgKHggPj4gMjQpICYgMHhmZmZmZmYsICh4ID4+IDMxKSAmIDB4ZmZmZilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19pbnQzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19pbnQzMiAoeCkgeyByZXR1cm4geC50b0ludCgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19mbG9hdCAoeCkgeyByZXR1cm4geC50b0Zsb2F0ICgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKHggPCAwKSB4ID0gTWF0aC5jZWlsKHgpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoXG4gICAgeCAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF90b19pbnQzMlxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZm9ybWF0IChmbXQsIHgpIHtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoZi5zaWduZWRjb252ICYmIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkpIHtcbiAgICBmLnNpZ24gPSAtMTsgeCA9IGNhbWxfaW50NjRfbmVnKHgpO1xuICB9XG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICB2YXIgd2Jhc2UgPSBjYW1sX2ludDY0X29mX2ludDMyKGYuYmFzZSk7XG4gIHZhciBjdnRibCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICBkbyB7XG4gICAgdmFyIHAgPSB4LnVkaXZtb2Qod2Jhc2UpO1xuICAgIHggPSBwLnF1b3RpZW50O1xuICAgIGJ1ZmZlciA9IGN2dGJsLmNoYXJBdChjYW1sX2ludDY0X3RvX2ludDMyKHAubW9kdWx1cykpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VsdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfbXVsLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGJhc2U2NCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoYmFzZSk7XG4gIHZhciB0aHJlc2hvbGQgPVxuICAgICAgbmV3IE1sSW50NjQoMHhmZmZmZmYsIDB4ZmZmZmZmZiwgMHhmZmZmKS51ZGl2bW9kKGJhc2U2NCkucXVvdGllbnQ7XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoYmFzZSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChuZXcgTWxJbnQ2NCgwLCAwLCAweDgwMDApLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShsbywgbWksIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobG8sIGhpKXtcbiAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICBsbyAmIDB4ZmZmZmZmLFxuICAgICgobG8gPj4+IDI0KSAmIDB4ZmYpIHwgKChoaSAmIDB4ZmZmZikgPDwgOCksXG4gICAgKGhpID4+PiAxNikgJiAweGZmZmYpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9sbzMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2xvMzIodil7IHJldHVybiB2LmxvMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGkzMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oaTMyKHYpeyByZXR1cm4gdi5oaTMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2J5dGVzKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGFbN10gPDwgMCB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVs0XSA8PCAwIHwgKGFbM10gPDwgOCkgfCAoYVsyXSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzFdIDw8IDAgfCAoYVswXSA8PCA4KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2J5dGVzKHgpIHsgcmV0dXJuIHgudG9BcnJheSgpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oYXNoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hhc2godil7XG4gIHJldHVybiAodi5sbzMyKCkpIF4gKHYuaGkzMigpKVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZihuID09IDApIHJldHVybiBcIlwiO1xuICBpZiAocy5yZXBlYXQpIHtyZXR1cm4gcy5yZXBlYXQobik7fSAvLyBFQ01Bc2NyaXB0IDYgYW5kIEZpcmVmb3ggMjQrXG4gIHZhciByID0gXCJcIiwgbCA9IDA7XG4gIGZvcig7Oykge1xuICAgIGlmIChuICYgMSkgciArPSBzO1xuICAgIG4gPj49IDE7XG4gICAgaWYgKG4gPT0gMCkgcmV0dXJuIHI7XG4gICAgcyArPSBzO1xuICAgIGwrKztcbiAgICBpZiAobCA9PSA5KSB7XG4gICAgICBzLnNsaWNlKDAsMSk7IC8vIGZsYXR0ZW4gdGhlIHN0cmluZ1xuICAgICAgLy8gdGhlbiwgdGhlIGZsYXR0ZW5pbmcgb2YgdGhlIHdob2xlIHN0cmluZyB3aWxsIGJlIGZhc3RlcixcbiAgICAgIC8vIGFzIGl0IHdpbGwgYmUgY29tcG9zZWQgb2YgbGFyZ2VyIHBpZWNlc1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbi8vV2Vha2RlZlxuLy8gUHJlIEVDTUFTY3JpcHQgNSwgW2FwcGx5XSB3b3VsZCBub3Qgc3VwcG9ydCBhcnJheS1saWtlIG9iamVjdC5cbi8vIEluIHN1Y2ggc2V0dXAsIFR5cGVkX2FycmF5IHdvdWxkIGJlIGltcGxlbWVudGVkIGFzIHBvbHlmaWxsLCBhbmQgW2YuYXBwbHldIHdvdWxkXG4vLyBmYWlsIGhlcmUuIE1hcmsgdGhlIHByaW1pdGl2ZSBhcyBXZWFrZGVmLCBzbyB0aGF0IHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQgZWFzaWx5LlxuZnVuY3Rpb24gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChhLCBpLCBsZW4pIHtcbiAgdmFyIGYgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBpZiAoaSA9PSAwICYmIGxlbiA8PSA0MDk2ICYmIGxlbiA9PSBhLmxlbmd0aCkgcmV0dXJuIGYuYXBwbHkgKG51bGwsIGEpO1xuICB2YXIgcyA9IFwiXCI7XG4gIGZvciAoOyAwIDwgbGVuOyBpICs9IDEwMjQsbGVuLT0xMDI0KVxuICAgIHMgKz0gZi5hcHBseSAobnVsbCwgYS5zbGljZShpLGkgKyBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gMztcbiAgICAgICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpICYmXG4gICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgdiA9IGMyIC0gMHgzYzgyMDgwICsgKGMgPDwgNik7XG4gICAgICAgICAgICAgIGlmICh2IDwgMHgxMDAwMCB8fCB2ID4gMHgxMGZmZmYpIHYgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBqc29vX2lzX2FzY2lpXG5mdW5jdGlvbiBqc29vX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIC8vIFRoZSBPQ2FtbCBjb21waWxlciB1c2VzIENoYXIudW5zYWZlX2NociBvbiBpbnRlZ2VycyBsYXJnZXIgdGhhbiAyNTUhXG4gIGMgJj0gMHhmZjtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSB7XG4gICAgaWYgKGkgPT0gcy5jLmxlbmd0aCkge1xuICAgICAgcy5jICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgaWYgKGkgKyAxID09IHMubCkgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKTtcbiAgfVxuICBzLmNbaV0gPSBjO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIyID0gMHhGRiAmIGkxNiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTE2O1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDE2XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQxNlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MTYocyxpLGkxNil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMil7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGI0ID0gMHhGRiAmIGkzMiA+PiAyNCxcbiAgICAgIGIzID0gMHhGRiAmIGkzMiA+PiAxNixcbiAgICAgIGIyID0gMHhGRiAmIGkzMiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTMyO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAwLCBiMSk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMiwgYjMpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAzLCBiNCk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQzMlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDMyKHMsaSxpMzIpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSA3KSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gY2FtbF9pbnQ2NF90b19ieXRlcyhpNjQpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgNyAtIGosIGFbal0pO1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQ2NFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcgKHMpIHtcbiAgdmFyIHRhZyA9IDkgLyogQllURVMgfCBBU0NJSSAqLztcbiAgaWYgKCFqc29vX2lzX2FzY2lpKHMpKVxuICAgIHRhZyA9IDggLyogQllURVMgfCBOT1RfQVNDSUkgKi8sIHMgPSBjYW1sX3V0Zjhfb2ZfdXRmMTYocyk7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0YWcsIHMsIHMubGVuZ3RoKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHN3aXRjaCAodGhpcy50KSB7XG4gIGNhc2UgOTogLypCWVRFUyB8IEFTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXModGhpcyk7XG4gIGNhc2UgMDogLypCWVRFUyB8IFVOS09XTiovXG4gICAgaWYgKGpzb29faXNfYXNjaWkodGhpcy5jKSkge1xuICAgICAgdGhpcy50ID0gOTsgLypCWVRFUyB8IEFTQ0lJKi9cbiAgICAgIHJldHVybiB0aGlzLmM7XG4gICAgfVxuICAgIHRoaXMudCA9IDg7IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICBjYXNlIDg6IC8qQllURVMgfCBOT1RfQVNDSUkqL1xuICAgIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0ZjgodGhpcy5jKTtcbiAgfVxufTtcbk1sQnl0ZXMucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKCl7XG4gIHZhciBjb250ZW50ID0gdGhpcy50ID09IDQgPyB0aGlzLmMuc2xpY2UoKSA6IHRoaXMuYztcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRoaXMudCxjb250ZW50LHRoaXMubCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzIChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEJZVEVTICovXG4gIGlmIChzLnQgPT0gMiAvKiBQQVJUSUFMICovKVxuICAgIHMuYyArPSBjYW1sX3N0cl9yZXBlYXQocy5sIC0gcy5jLmxlbmd0aCwgJ1xcMCcpXG4gIGVsc2VcbiAgICBzLmMgPSBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocykge1xuICAvKiBBc3N1bWVzIG5vdCBBUlJBWSAqL1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSB7XG4gICAgdmFyIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShzLmwpO1xuICB9IGVsc2Uge1xuICAgIHZhciBhID0gbmV3IEFycmF5KHMubCk7XG4gIH1cbiAgdmFyIGIgPSBzLmMsIGwgPSBiLmxlbmd0aCwgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICBmb3IgKGwgPSBzLmw7IGkgPCBsOyBpKyspIGFbaV0gPSAwO1xuICBzLmMgPSBhO1xuICBzLnQgPSA0OyAvKiBBUlJBWSAqL1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2ZfYnl0ZXMgKHMpIHtcbiAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2Zfc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX3N0cmluZyAocykge1xuICB2YXIgbCA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSk7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBpZihsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJ5dGVzLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoYSwwLGEubGVuZ3RoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKDQsYSxhLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfY29tcGFyZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPy0xOihzMS5jID4gczIuYyk/MTowO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jID09IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzdGhhbihzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLHMxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMixzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2ZpbGxfYnl0ZXMocywgaSwgbCwgYykge1xuICBpZiAobCA+IDApIHtcbiAgICBpZiAoaSA9PSAwICYmIChsID49IHMubCB8fCAocy50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsID49IHMuYy5sZW5ndGgpKSkge1xuICAgICAgaWYgKGMgPT0gMCkge1xuICAgICAgICBzLmMgPSBcIlwiO1xuICAgICAgICBzLnQgPSAyOyAvKiBQQVJUSUFMICovXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLmMgPSBjYW1sX3N0cl9yZXBlYXQgKGwsIFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICBzLnQgPSAobCA9PSBzLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkocyk7XG4gICAgICBmb3IgKGwgKz0gaTsgaSA8IGw7IGkrKykgcy5jW2ldID0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZmlsbF9ieXRlc1xudmFyIGNhbWxfZmlsbF9zdHJpbmcgPSBjYW1sX2ZpbGxfYnl0ZXNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9ibGl0X2J5dGVzKHMxLCBpMSwgczIsIGkyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgaWYgKChpMiA9PSAwKSAmJlxuICAgICAgKGxlbiA+PSBzMi5sIHx8IChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBsZW4gPj0gczIuYy5sZW5ndGgpKSkge1xuICAgIHMyLmMgPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSB7XG4gICAgaWYgKHMyLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMyKTtcbiAgICB2YXIgYzEgPSBzMS5jLCBjMiA9IHMyLmM7XG4gICAgaWYgKHMxLnQgPT0gNCAvKiBBUlJBWSAqLykge1xuICAgICAgaWYgKGkyIDw9IGkxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsID0gTWF0aC5taW4gKGxlbiwgYzEubGVuZ3RoIC0gaTEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIGMyIFtpMiArIGldID0gYzEuY2hhckNvZGVBdChpMSArIGkpO1xuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ibGl0X3N0cmluZyhhLGIsYyxkLGUpIHtcbiAgICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9zdHJpbmcoYSksYixjLGQsZSk7XG4gICAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpIHsgcmV0dXJuIHMubCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gcy5jaGFyQ29kZUF0KGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfdW5zYWZlX3NldFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBzLmxlbmd0aFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/LTE6KHMxID4gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWwgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDw9IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykge1xuICAgIChzLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzLmMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0Zjhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykge1xuICBpZihqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBzO1xuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgaWYgKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocylcbiAgZWxzZSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjYW1sX3V0Zjhfb2ZfdXRmMTYocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKSB7IHJldHVybiBuZXcgTWxCeXRlcygwLHMscy5sZW5ndGgpOyB9XG5cblxuLy8gVGhlIHNlY3Rpb24gYmVsb3cgc2hvdWxkIGJlIHVzZWQgd2hlbiB1c2UtanMtc3RyaW5nPWZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsaSxjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfY29tcGFyZShzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19lcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgeyByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNieXRlc19vZl9zdHJpbmcocykge1xuICBpZiAoKHMudCAmIDYpICE9IDAgLyogQllURVMgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpe1xuICByZXR1cm4gcy50b1N0cmluZygpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9pc19tbF9ieXRlcyhzKSB7XG4gIHJldHVybiAocyBpbnN0YW5jZW9mIE1sQnl0ZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50ICh0YWcpIHsgdGhyb3cgdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKHRhZykgeyByZXR1cm4gdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IFswLCB0YWcsIGFyZ107IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZyAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX3N0cmluZyAodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhaWx3aXRoIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZmFpbHdpdGggKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgbXNnKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkludmFsaWRfYXJndW1lbnQsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRW5kX29mX2ZpbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkRpdmlzaW9uX2J5X3plcm8pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfZm91bmQgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuTm90X2ZvdW5kKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICBpZihmLmZ1bilcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgYXJncyk7XG4gIC8vRklYTUUsIGNhbiBoYXBwZW4gd2l0aCB0b28gbWFueSBhcmd1bWVudHNcbiAgaWYodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGY7XG4gIHZhciBuID0gZi5sZW5ndGggfCAwO1xuICBpZihuID09PSAwKSByZXR1cm4gZi5hcHBseShudWxsLGFyZ3MpO1xuICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoIHwgMDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbiB8IDA7XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5hcHBseShudWxsLGFyZ3Muc2xpY2UoMCxuKSksYXJncy5zbGljZShuKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpe1xuICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgrZXh0cmFfYXJncyk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSBuYXJnc1thcmdzLmxlbmd0aCtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIG5hcmdzKVxuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlc1xudmFyIGNhbWxfbmFtZWRfdmFsdWVzID0ge307XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUgKGNvbnN0LGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUobm0sdikge1xuICBjYW1sX25hbWVkX3ZhbHVlc1tjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5tKV0gPSB2O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXNcbmZ1bmN0aW9uIGNhbWxfbmFtZWRfdmFsdWUobm0pIHtcbiAgcmV0dXJuIGNhbWxfbmFtZWRfdmFsdWVzW25tXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dsb2JhbF9kYXRhXG52YXIgY2FtbF9nbG9iYWxfZGF0YSA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKGNvbnN0LCBzaGFsbG93LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChuLCB2LCBuYW1lX29wdCkge1xuICBpZihuYW1lX29wdCAmJiBqb29fZ2xvYmFsX29iamVjdC50b3BsZXZlbFJlbG9jKVxuICAgIG4gPSBqb29fZ2xvYmFsX29iamVjdC50b3BsZXZlbFJlbG9jKG5hbWVfb3B0KTtcbiAgY2FtbF9nbG9iYWxfZGF0YVtuICsgMV0gPSB2O1xuICBpZihuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YSAoKSB7IHJldHVybiBjYW1sX2dsb2JhbF9kYXRhOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHsgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IFwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IHkgLSAxO1xuICByZXR1cm4gKE1hdGguYWJzKHgpPjE/ejooej09MD94Ongqei9NYXRoLmxvZyh5KSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gMSArIHgsIHogPSB5IC0gMTtcbiAgcmV0dXJuICh6PT0wP3g6eCpNYXRoLmxvZyh5KS96KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkge1xuICB2YXIgeCA9IE1hdGguYWJzKHgpLCB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSksIGIgPSBNYXRoLm1pbih4LHkpIC8gKGE/YToxKTtcbiAgcmV0dXJuIChhICogTWF0aC5zcXJ0KDEgKyBiKmIpKTtcbn1cblxuLy8gRklYOiB0aGVzZSBmaXZlIGZ1bmN0aW9ucyBvbmx5IGdpdmUgYXBwcm94aW1hdGUgcmVzdWx0cy5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguTE9HMTBFICogTWF0aC5sb2coeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0gTWF0aC5leHAoLXgpO1xuICByZXR1cm4gKHkgLSB6KSAvICh5ICsgeik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKVxuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKXAoWystXT9bMC05XSspL2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA0XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzRdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuaWYoam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAmJiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywnLycpO1xuZWxzZVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9ICBcIi9zdGF0aWNcIjtcbmlmKGNhbWxfY3VycmVudF9kaXIuc2xpY2UoLTEpICE9PSBcIi9cIikgY2FtbF9jdXJyZW50X2RpciArPSBcIi9cIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbnZhciBjYW1sX3Jvb3QgPSBjYW1sX2N1cnJlbnRfZGlyLm1hdGNoKC9bXlxcL10qXFwvLylbMF07XG5cblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKXsgIH1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aCAobmFtZSkge1xuICBuYW1lPWNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZihuYW1lLmNoYXJDb2RlQXQoMCkgIT0gNDcpXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBjYXNlIFwiXCI6IGlmKG5jb21wLmxlbmd0aCA9PSAwKSBuY29tcC5wdXNoKFwiXCIpOyBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW11cbmlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2UoY2FtbF9yb290KX0pO1xufSBlbHNlIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QpfSk7XG59XG5qc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290K1wic3RhdGljL1wiLCBkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QrXCJzdGF0aWMvXCIpfSk7XG5cbi8vUHJvdmlkZXM6Y2FtbF9saXN0X21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xpc3RfbW91bnRfcG9pbnQoKXtcbiAgdmFyIHByZXYgPSAwXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKXtcbiAgICB2YXIgb2xkID0gcHJldjtcbiAgICBwcmV2ID0gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuXG4vL1Byb3ZpZGVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gbmFtZSArIFwiL1wiO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb3VudF9hdXRvbG9hZFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludFxuZnVuY3Rpb24gY2FtbF9tb3VudF9hdXRvbG9hZChuYW1lLGYpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoICsgcm9vdC5yZXN0ICsgXCIvXCI7XG4gICAgZWxzZSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGRpcik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKXtcbiAgbmFtZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSk7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIG5hbWUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGUodmZkLCBraW5kLCBsYXlvdXQsIHNoYXJlZCwgZGltcywgcG9zKSB7XG4gIC8vIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsYXJnbil7XG4gIHJldHVybiBjYW1sX2JhX21hcF9maWxlKGFyZ3ZbMF0sYXJndlsxXSxhcmd2WzJdLGFyZ3ZbM10sYXJndls0XSxhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsY29udGVudCl7XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUpXG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZigham9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXApIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wID0gW107XG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1qb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcFxuICBpZih0bXApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspe1xuICAgICAgY2FtbF9jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSx0bXBbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUgPSBjYW1sX2NyZWF0ZV9maWxlO1xuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKCEgcm9vdC5kZXZpY2UucmVnaXN0ZXIpIGNhbWxfZmFpbHdpdGgoXCJjYW5ub3QgcmVnaXN0ZXIgZmlsZVwiKTtcbiAgcm9vdC5kZXZpY2UucmVnaXN0ZXIocm9vdC5yZXN0LGNvbnRlbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWFkX2ZpbGVfY29udGVudFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LHtyZG9ubHk6MX0pO1xuICAgIHZhciBsZW4gID0gZmlsZS5sZW5ndGgoKTtcbiAgICB2YXIgYnVmICA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgZmlsZS5yZWFkKDAsYnVmLDAsbGVuKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKVxuICB9XG4gIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYoZy5xdWl0KSBnLnF1aXQoY29kZSk7XG4gIC8vbm9kZWpzXG4gIGlmKGcucHJvY2VzcyAmJiBnLnByb2Nlc3MuZXhpdClcbiAgICBnLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZigham9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52KVxuICAgIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbiA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICAvL25vZGVqcyBlbnZcbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5lbnZcbiAgICAgJiYgZy5wcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGcucHJvY2Vzcy5lbnZbbl0pO1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZbbl0pXG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICB2YXIgeCA9IG5vd14weGZmZmZmZmZmKk1hdGgucmFuZG9tKCk7XG4gIHJldHVybiBbMCx4XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2ludF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIGNvbnN0XG4vLyBtYXhfaW50IC8gNCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgb3ZlcmZsb3dcbi8vbGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxOztcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgKCkgeyByZXR1cm4gKDB4N0ZGRkZGRkYvNCkgfCAwO31cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4ICgpIHsgcmV0dXJuIDE7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlVuaXhcIiksIDMyLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3N5c19pc2F0dHkoX2NoYW4pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV92YXJpYW50XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfdmFyaWFudChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyhfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKXtyZXR1cm4gMH1cblxuLy9Qcm92aWRlczogdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG5mdW5jdGlvbiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgKCkge3JldHVybiAwO31cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZShfY2hhbm5lbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiU3BhY2V0aW1lIHByb2ZpbGluZyBvbmx5IHdvcmtzIGZvciBuYXRpdmUgY29kZVwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IE1sRmFrZURldmljZVxuLy9SZXF1aXJlczogTWxGYWtlRmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfYXJyYXksIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2J5dGVzX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBNbEZha2VEZXZpY2UgKHJvb3QsIGYpIHtcbiAgdGhpcy5jb250ZW50PXt9O1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLmxvb2t1cEZ1biA9IGY7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCF0aGlzLmNvbnRlbnRbbmFtZV0gJiYgdGhpcy5sb29rdXBGdW4pIHtcbiAgICB2YXIgcmVzID0gdGhpcy5sb29rdXBGdW4oY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnJvb3QpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpKTtcbiAgICBpZihyZXMgIT09IDApIHRoaXMuY29udGVudFtuYW1lXT1uZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhyZXNbMV0pKTtcbiAgfVxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFRoZSByb290IG9mIHRoZSBkZXZpY2UgZXhpc3RzXG4gIGlmKG5hbWUgPT0gXCJcIikgcmV0dXJuIDE7XG4gIC8vIENoZWNrIGlmIGEgZGlyZWN0b3J5IGV4aXN0c1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoKTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIGlmIChuLm1hdGNoKHIpKSByZXR1cm4gMVxuICB9XG4gIC8vIENoZWNrIGlmIGEgZmlsZSBleGlzdHNcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV0/MTowO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBzZWVuID0ge31cbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtICYmICFzZWVuW21bMV1dKSB7c2VlblttWzFdXSA9IHRydWU7IGEucHVzaChtWzFdKX1cbiAgfVxuICByZXR1cm4gYTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgbmFtZV9zbGFzaCA9IChuYW1lID09IFwiXCIpP1wiXCI6KG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2ggKyBcIihbXi9dKilcIik7XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSkgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBvayA9IHRoaXMuY29udGVudFtuYW1lXT90cnVlOmZhbHNlO1xuICBkZWxldGUgdGhpcy5jb250ZW50W25hbWVdO1xuICByZXR1cm4gb2s7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdGhpcy5sb29rdXAobmFtZSk7XG4gIGlmICh0aGlzLmNvbnRlbnRbbmFtZV0pIHtcbiAgICBpZiAodGhpcy5pc19kaXIobmFtZSkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGlzIGEgZGlyZWN0b3J5XCIpO1xuICAgIGlmIChmLmNyZWF0ZSAmJiBmLmV4Y2wpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gICAgaWYoZi50cnVuY2F0ZSkgZmlsZS50cnVuY2F0ZSgpO1xuICAgIHJldHVybiBmaWxlO1xuICB9IGVsc2UgaWYgKGYuY3JlYXRlKSB7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIH0gZWxzZSB7XG4gICAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUgKHRoaXMubm0obmFtZSkpO1xuICB9XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVnaXN0ZXI9IGZ1bmN0aW9uIChuYW1lLGNvbnRlbnQpe1xuICBpZih0aGlzLmNvbnRlbnRbbmFtZV0pIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZpbGUgYWxyZWFkeSBleGlzdHNcIik7XG4gIGlmKGNhbWxfaXNfbWxfYnl0ZXMoY29udGVudCkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY29udGVudCk7XG4gIGlmKGNhbWxfaXNfbWxfc3RyaW5nKGNvbnRlbnQpKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9hcnJheShjb250ZW50KSk7XG4gIGVsc2UgaWYodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNvbnRlbnQpKTtcbiAgZWxzZSBpZihjb250ZW50LnRvU3RyaW5nKSB7XG4gICAgdmFyIGJ5dGVzID0gY2FtbF9ieXRlc19vZl9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoY29udGVudC50b1N0cmluZygpKSk7XG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoYnl0ZXMpO1xuICB9XG4gIGVsc2UgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogcmVnaXN0ZXJpbmcgZmlsZSB3aXRoIGludmFsaWQgY29udGVudCB0eXBlXCIpO1xufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0XG5mdW5jdGlvbiBNbEZha2VGaWxlKGNvbnRlbnQpe1xuICB0aGlzLmRhdGEgPSBjb250ZW50O1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9zdHJpbmcoYnVmLCBwb3MsIHRoaXMuZGF0YSwgb2Zmc2V0LCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHRoaXMuZGF0YSwgb2Zmc2V0LCBidWYsIHBvcywgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZ2V0KHRoaXMuZGF0YSwgb2Zmc2V0KTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcblxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VGaWxlXG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gZnNfbm9kZV9zdXBwb3J0ZWQgKCkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5wbGF0Zm9ybSAhPT0gXCJicm93c2VyXCIpXG59XG5cblxuLy9Qcm92aWRlczogTWxOb2RlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbE5vZGVGaWxlLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRGV2aWNlKHJvb3QpIHtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm5tID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gKHRoaXMucm9vdCArIG5hbWUpO1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnJlYWRkaXJTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuaXNfZGlyID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLnN0YXRTeW5jKHRoaXMubm0obmFtZSkpLmlzRGlyZWN0b3J5KCk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHZhciBiID0gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gYlxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICB2YXIgY29uc3RzID0gcmVxdWlyZSgnY29uc3RhbnRzJyk7XG4gIHZhciByZXMgPSAwO1xuICBmb3IodmFyIGtleSBpbiBmKXtcbiAgICBzd2l0Y2goa2V5KXtcbiAgICBjYXNlIFwicmRvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1JET05MWTsgYnJlYWs7XG4gICAgY2FzZSBcIndyb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19XUk9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJhcHBlbmRcIiAgOlxuICAgICAgcmVzIHw9IGNvbnN0cy5PX1dST05MWSB8IGNvbnN0cy5PX0FQUEVORDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjcmVhdGVcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0NSRUFUOyAgICBicmVhaztcbiAgICBjYXNlIFwidHJ1bmNhdGVcIiA6IHJlcyB8PSBjb25zdHMuT19UUlVOQzsgICAgYnJlYWs7XG4gICAgY2FzZSBcImV4Y2xcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fRVhDTDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiaW5hcnlcIiAgIDogcmVzIHw9IGNvbnN0cy5PX0JJTkFSWTsgICBicmVhaztcbiAgICBjYXNlIFwidGV4dFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19URVhUOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vbmJsb2NrXCIgOiByZXMgfD0gY29uc3RzLk9fTk9OQkxPQ0s7IGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgICByZXR1cm4gbmV3IE1sTm9kZUZpbGUoZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLG4pIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlbmFtZVN5bmModGhpcy5ubShvKSwgdGhpcy5ubShuKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2ZfYnl0ZXMsIGNhbWxfYnl0ZXNfc2V0LCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gTWxOb2RlRmlsZShmZCl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmZ0cnVuY2F0ZVN5bmModGhpcy5mZCxsZW58MClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuZnN0YXRTeW5jKHRoaXMuZmQpLnNpemU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy53cml0ZVN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX2J5dGVzKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBjYW1sX2J5dGVzX3NldChidWYsYnVmX29mZnNldCArIGksYnVmZmVyW2J1Zl9vZmZzZXQraV0pO1xuICB9XG4gIHJldHVybiAwXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgMCwgMSwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBidWZmZXJbMF07XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZUZpbGU7XG4iLCIvL1Byb3ZpZGVzOiBpbml0aWFsaXplX25hdFxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBzZXJpYWxpemVfbmF0LCBkZXNlcmlhbGl6ZV9uYXQsIGNhbWxfaGFzaF9uYXRcbmZ1bmN0aW9uIGluaXRpYWxpemVfbmF0KCkge1xuICBjYW1sX2N1c3RvbV9vcHNbXCJfbmF0XCJdID1cbiAgICB7IGRlc2VyaWFsaXplIDogZGVzZXJpYWxpemVfbmF0LFxuICAgICAgc2VyaWFsaXplIDogc2VyaWFsaXplX25hdCxcbiAgICAgIGhhc2ggOiBjYW1sX2hhc2hfbmF0XG4gICAgfVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5hdFxuZnVuY3Rpb24gTWxOYXQoeCl7XG4gIHRoaXMuZGF0YSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KHgpO1xuICAvLyBsZW5ndGhfbmF0IGlzbid0IGV4dGVybmFsLCBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhlIE9iai5zaXplXG4gIC8vIHdvcmsgb3V0IHJpZ2h0LiBUaGUgKzIgdG8gYXJyYXkgbGVuZ3RoIHNlZW1zIHRvIHdvcmsuXG4gIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCArIDJcbn1cblxuTWxOYXQucHJvdG90eXBlLmNhbWxfY3VzdG9tID0gXCJfbmF0XCI7XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY2FtbF9oYXNoX25hdCh4KSB7XG4gIHZhciBsZW4gPSBudW1fZGlnaXRzX25hdCh4LCAwLCB4LmRhdGEubGVuZ3RoKTtcbiAgdmFyIGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHguZGF0YVtpXSk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5cblxuLy9Qcm92aWRlczogbmF0X29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gbmF0X29mX2FycmF5KGwpe1xuICByZXR1cm4gbmV3IE1sTmF0KGwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjcmVhdGVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gY3JlYXRlX25hdChzaXplKSB7XG4gIHZhciBhcnIgPSBuZXcgTWxOYXQoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBhcnIuZGF0YVtpXSA9IC0xO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vUHJvdmlkZXM6IHNldF90b196ZXJvX25hdFxuZnVuY3Rpb24gc2V0X3RvX3plcm9fbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmxpdF9uYXRcbmZ1bmN0aW9uIGJsaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IG5hdDIuZGF0YVtvZnMyK2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0XG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0KG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0XG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0KG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBudGhfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIG51bV9kaWdpdHNfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZihuYXQuZGF0YVtvZnMraV0gIT0gMCkgcmV0dXJuIGkrMTtcbiAgfVxuICByZXR1cm4gMTsgLy8gMCBjb3VudHMgYXMgMSBkaWdpdFxufVxuXG4vL1Byb3ZpZGVzOiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXRcbmZ1bmN0aW9uIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQsIG9mcykge1xuICB2YXIgYSA9IG5hdC5kYXRhW29mc107XG4gIHZhciBiID0gMDtcbiAgaWYoYSAmIDB4RkZGRjAwMDApIHsgYiArPTE2OyBhID4+Pj0xNjsgfVxuICBpZihhICYgMHhGRjAwKSAgICAgeyBiICs9IDg7IGEgPj4+PSA4OyB9XG4gIGlmKGEgJiAweEYwKSAgICAgICB7IGIgKz0gNDsgYSA+Pj49IDQ7IH1cbiAgaWYoYSAmIDEyKSAgICAgICAgIHsgYiArPSAyOyBhID4+Pj0gMjsgfVxuICBpZihhICYgMikgICAgICAgICAgeyBiICs9IDE7IGEgPj4+PSAxOyB9XG4gIGlmKGEgJiAxKSAgICAgICAgICB7IGIgKz0gMTsgfVxuICByZXR1cm4gMzIgLSBiO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9pbnRcbmZ1bmN0aW9uIGlzX2RpZ2l0X2ludChuYXQsIG9mcykge1xuICBpZiAobmF0LmRhdGFbb2ZzXSA+PSAwKSByZXR1cm4gMVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfemVyb1xuZnVuY3Rpb24gaXNfZGlnaXRfemVybyhuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdID09IDApIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfb2RkXG5mdW5jdGlvbiBpc19kaWdpdF9vZGQobmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSAmIDEpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGluY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKHggfCAwKTtcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IGFkZF9uYXRcbi8vUmVxdWlyZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBjYXJyeSA9IGNhcnJ5X2luO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geFxuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhcnJ5ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBjYXJyeSk7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBsZW1lbnRfbmF0XG5mdW5jdGlvbiBjb21wbGVtZW50X25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICgtMSA+Pj4gMCkgLSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKTtcbiAgfVxufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy9Qcm92aWRlczogZGVjcl9uYXRcbmZ1bmN0aW9uIGRlY3JfbmF0KG5hdCwgb2ZzLCBsZW4sIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PjApIC0gYm9ycm93O1xuICAgIG5hdC5kYXRhW29mcytpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGJvcnJvdyA9PSAxKSA/IDAgOiAxO1xufVxuXG4vLyBvY2FtbCBmbGlwcyBjYXJyeV9pblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBzdWJfbmF0XG4vL1JlcXVpcmVzOiBkZWNyX25hdFxuZnVuY3Rpb24gc3ViX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgLSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApIC0gYm9ycm93O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3Jyb3cgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIChib3Jyb3c9PTEpPzA6MSk7XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNbb2ZzM11cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogbXVsdF9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGFkZF9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMykge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgYSA9IChuYXQzLmRhdGFbb2ZzM10gPj4+IDApO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHgxID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSAmIDB4MDAwMEZGRkYpICsgY2Fycnk7XG4gICAgdmFyIHgyID0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhID4+PiAxNik7XG4gICAgY2FycnkgPSBNYXRoLmZsb29yKHgyLzY1NTM2KTtcbiAgICB2YXIgeDMgPSB4MSArICh4MiAlIDY1NTM2KSAqIDY1NTM2O1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0geDM7XG4gICAgY2FycnkgKz0gTWF0aC5mbG9vcih4My80Mjk0OTY3Mjk2KTtcbiAgfVxuXG4gIGlmKGxlbjIgPCBsZW4xICYmIGNhcnJ5KSB7XG4gICAgcmV0dXJuIGFkZF9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIG5hdF9vZl9hcnJheShbY2FycnldKSwgMCwgMSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNhcnJ5O1xuICB9XG59XG5cbi8vIG5hdDEgKz0gbmF0MiAqIG5hdDNcbi8vIGxlbjEgPj0gbGVuMiArIGxlbjMuXG4vL1Byb3ZpZGVzOiBtdWx0X25hdFxuLy9SZXF1aXJlczogbXVsdF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMsIGxlbjMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjM7IGkrKykge1xuICAgIGNhcnJ5ICs9IG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEraSwgbGVuMS1pLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzK2kpO1xuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbmF0MSA9IDIgKiBuYXQxICsgbmF0MiAqIG5hdDJcbi8vIGxlbjEgPj0gMiAqIGxlbjJcbi8vUHJvdmlkZXM6IHNxdWFyZV9uYXRcbi8vUmVxdWlyZXM6IG11bHRfbmF0LCBhZGRfbmF0XG5mdW5jdGlvbiBzcXVhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgY2FycnkgKz0gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQxLCBvZnMxLCBsZW4xLCAwKTtcbiAgY2FycnkgKz0gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMik7XG4gIHJldHVybiBjYXJyeTtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X2xlZnRfbmF0XG5mdW5jdGlvbiBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICB2YXIgYSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA8PCBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhID4+PiAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIEFzc3VtaW5nIGMgPiBhLCByZXR1cm5zIFtxdW90aWVudCwgcmVtYWluZGVyXSBvZiAoYTw8MzIgKyBiKS9jXG4vL1Byb3ZpZGVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfaGVscGVyKGEsIGIsIGMpIHtcbiAgdmFyIHggPSBhICogNjU1MzYgKyAoYj4+PjE2KTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHgvYykgKiA2NTUzNjtcbiAgdmFyIHogPSAoeCAlIGMpICogNjU1MzY7XG4gIHZhciB3ID0geiArIChiICYgMHgwMDAwRkZGRik7XG4gIHJldHVybiBbeSArIE1hdGguZmxvb3Iody9jKSwgdyAlIGNdO1xufVxuXG4vLyBuYXQxW29mczErbGVuXSA8IG5hdDJbb2ZzMl1cbi8vUHJvdmlkZXM6IGRpdl9kaWdpdF9uYXRcbi8vUmVxdWlyZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9kaWdpdF9uYXQobmF0cSwgb2ZzcSwgbmF0ciwgb2ZzciwgbmF0MSwgb2ZzMSwgbGVuLCBuYXQyLCBvZnMyKSB7XG4gIHZhciByZW0gPSAobmF0MS5kYXRhW29mczErbGVuLTFdID4+PjApO1xuICAvLyBuYXRxW29mc3ErbGVuLTFdIGlzIGd1YXJhbnRlZWQgdG8gYmUgemVybyAoZHVlIHRvIHRoZSBNU0QgcmVxdWlyZW1lbnQpLFxuICAvLyBhbmQgc2hvdWxkIG5vdCBiZSB3cml0dGVuIHRvLlxuICBmb3IodmFyIGkgPSBsZW4tMjsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgeCA9IGRpdl9oZWxwZXIocmVtLCAobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0Mi5kYXRhW29mczJdID4+PiAwKSk7XG4gICAgbmF0cS5kYXRhW29mc3EraV0gPSB4WzBdO1xuICAgIHJlbSA9IHhbMV07XG4gIH1cbiAgbmF0ci5kYXRhW29mc3JdID0gcmVtO1xuICByZXR1cm4gMDtcbn1cblxuLy8gbmF0MVtuYXQyOl0gOj0gbmF0MSAvIG5hdDJcbi8vIG5hdDFbOm5hdDJdIDo9IG5hdDEgJSBuYXQyXG4vLyBsZW4xID4gbGVuMiwgbmF0MltvZnMyK2xlbjItMV0gPiBuYXQxW29mczErbGVuMS0xXVxuLy9Qcm92aWRlczogZGl2X25hdFxuLy9SZXF1aXJlczogZGl2X2RpZ2l0X25hdCwgZGl2X2hlbHBlciwgbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0LCBzaGlmdF9sZWZ0X25hdCwgc2hpZnRfcmlnaHRfbmF0LCBjcmVhdGVfbmF0LCBzZXRfdG9femVyb19uYXQsIG11bHRfZGlnaXRfbmF0LCBzdWJfbmF0LCBjb21wYXJlX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBkaXZfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgaWYobGVuMiA9PSAxKSB7XG4gICAgZGl2X2RpZ2l0X25hdChuYXQxLCBvZnMxKzEsIG5hdDEsIG9mczEsIG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIpO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHMgPSBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0Miwgb2ZzMitsZW4yLTEpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcblxuICB2YXIgZCA9IChuYXQyLmRhdGFbb2ZzMitsZW4yLTFdID4+PiAwKSArIDE7XG4gIHZhciBhID0gY3JlYXRlX25hdChsZW4yKzEpO1xuICBmb3IgKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gbGVuMjsgaS0tKSB7XG4gICAgLy8gRGVjZW50IGxvd2VyIGJvdW5kIG9uIHF1b1xuICAgIHZhciBxdW8gPSBkID09IDQyOTQ5NjcyOTYgPyAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDogZGl2X2hlbHBlcigobmF0MS5kYXRhW29mczEraV0gPj4+IDApLCAobmF0MS5kYXRhW29mczEraS0xXSA+Pj4wKSwgZClbMF07XG4gICAgc2V0X3RvX3plcm9fbmF0KGEsIDAsIGxlbjIrMSk7XG4gICAgbXVsdF9kaWdpdF9uYXQoYSwgMCwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoW3F1b10pLCAwKTtcbiAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIGEsIDAsIGxlbjIrMSwgMSk7XG5cbiAgICB3aGlsZSAobmF0MS5kYXRhW29mczEraV0gIT0gMCB8fCBjb21wYXJlX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMiwgbmF0Miwgb2ZzMiwgbGVuMikgPj0gMCkge1xuICAgICAgcXVvID0gcXVvICsgMTtcbiAgICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgMSk7XG4gICAgfVxuXG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBxdW87XG4gIH1cblxuICBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyBzaGlmdCByZW1haW5kZXJcbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gcmVzdG9yZVxuICByZXR1cm4gMDtcbn1cblxuXG4vLyAwIDw9IHNoaWZ0IDwgMzJcbi8vUHJvdmlkZXM6IHNoaWZ0X3JpZ2h0X25hdFxuZnVuY3Rpb24gc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gbGVuMS0xOyBpID49IDA7IGktLSkge1xuICAgIHZhciBhID0gbmF0MS5kYXRhW29mczEraV0gPj4+IDA7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSAoYSA+Pj4gbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA8PCAoMzIgLSBuYml0cyk7XG4gIH1cbiAgbmF0Mi5kYXRhW29mczJdID0gd3JhcDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgaWYobmF0MS5kYXRhW29mczFdID4gbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gMTtcbiAgaWYobmF0MS5kYXRhW29mczFdIDwgbmF0Mi5kYXRhW29mczJdKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdFxuLy9SZXF1aXJlczogbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIpIHtcbiAgdmFyIGEgPSBudW1fZGlnaXRzX25hdChuYXQxLCBvZnMxLCBsZW4xKTtcbiAgdmFyIGIgPSBudW1fZGlnaXRzX25hdChuYXQyLCBvZnMyLCBsZW4yKTtcbiAgaWYoYSA+IGIpIHJldHVybiAxO1xuICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICBmb3IodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA+IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAxO1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApIDwgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIC0xO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX25hdF9yZWFsXG4vL1JlcXVpcmVzOiBjb21wYXJlX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXRfcmVhbChuYXQxLG5hdDIpe1xuICByZXR1cm4gY29tcGFyZV9uYXQobmF0MSwwLG5hdDEuZGF0YS5sZW5ndGgsbmF0MiwwLG5hdDIuZGF0YS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBsYW5kX2RpZ2l0X25hdFxuZnVuY3Rpb24gbGFuZF9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gJj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSB8PSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBseG9yX2RpZ2l0X25hdFxuZnVuY3Rpb24gbHhvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gXj0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBzZXJpYWxpemVfbmF0XG5mdW5jdGlvbiBzZXJpYWxpemVfbmF0KHdyaXRlciwgbmF0LCBzeil7XG4gIHZhciBsZW4gPSBuYXQuZGF0YS5sZW5ndGg7XG4gIHdyaXRlci53cml0ZSgzMiwgbGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICB3cml0ZXIud3JpdGUoMzIsIG5hdC5kYXRhW2ldKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHN6WzFdID0gbGVuICogODtcbn1cblxuLy9Qcm92aWRlczogZGVzZXJpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBNbE5hdFxuZnVuY3Rpb24gZGVzZXJpYWxpemVfbmF0KHJlYWRlciwgc3ope1xuICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIG5hdCA9IG5ldyBNbE5hdChsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIG5hdC5kYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgfVxuICBzelswXSA9IGxlbiAqIDQ7XG4gIHJldHVybiBuYXQ7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlXG52YXIgY2FtbF9ncl9zdGF0ZTtcblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWUsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfZ2V0KCkge1xuICBpZihjYW1sX2dyX3N0YXRlKSB7XG4gICAgcmV0dXJuIGNhbWxfZ3Jfc3RhdGU7XG4gIH1cbiAgdGhyb3cgWzAsY2FtbF9uYW1lZF92YWx1ZShcIkdyYXBoaWNzLkdyYXBoaWNfZmFpbHVyZVwiKSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIk5vdCBpbml0aWFsaXplZFwiKV1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlLGNhbWxfZ3Jfc3RhdGVfaW5pdFxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KSB7XG4gIGNhbWxfZ3Jfc3RhdGU9Y3R4O1xuICBjYW1sX2dyX3N0YXRlX2luaXQoKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fZ3JhcGgoaW5mbyl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBpbmZvID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoaW5mbyk7XG4gIGZ1bmN0aW9uIGdldChuYW1lKXtcbiAgICB2YXIgcmVzID0gaW5mby5tYXRjaChcIihefCwpICpcIituYW1lK1wiICo9ICooW2EtekEtWjAtOV9dKykgKigsfCQpXCIpO1xuICAgIGlmKHJlcykgcmV0dXJuIHJlc1syXTtcbiAgfVxuICB2YXIgc3BlY3MgPSBbXTtcbiAgaWYoIShpbmZvPT1cIlwiKSkgc3BlY3MucHVzaChpbmZvKTtcbiAgdmFyIHRhcmdldCA9IGdldChcInRhcmdldFwiKTtcbiAgaWYoIXRhcmdldCkgdGFyZ2V0PVwiXCI7XG4gIHZhciBzdGF0dXMgPSBnZXQoXCJzdGF0dXNcIik7XG4gIGlmKCFzdGF0dXMpIHNwZWNzLnB1c2goXCJzdGF0dXM9MVwiKVxuXG4gIHZhciB3ID0gZ2V0KFwid2lkdGhcIik7XG4gIHcgPSB3P3BhcnNlSW50KHcpOjIwMDtcbiAgc3BlY3MucHVzaChcIndpZHRoPVwiK3cpO1xuXG4gIHZhciBoID0gZ2V0KFwiaGVpZ2h0XCIpO1xuICBoID0gaD9wYXJzZUludChoKToyMDA7XG4gIHNwZWNzLnB1c2goXCJoZWlnaHQ9XCIraCk7XG5cbiAgdmFyIHdpbiA9IGcub3BlbihcImFib3V0OmJsYW5rXCIsdGFyZ2V0LHNwZWNzLmpvaW4oXCIsXCIpKTtcbiAgaWYoIXdpbikge2NhbWxfZmFpbHdpdGgoXCJHcmFwaGljcy5vcGVuX2dyYXBoOiBjYW5ub3Qgb3BlbiB0aGUgd2luZG93XCIpfVxuICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICB2YXIgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNhbnZhcy53aWR0aCA9IHc7XG4gIGNhbnZhcy5oZWlnaHQgPSBoO1xuICB2YXIgY3R4ID0gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCk7XG4gIGN0eC5zZXRfdGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2MudGl0bGUgPSB0aXRsZTtcbiAgfTtcbiAgY2FtbF9ncl9zdGF0ZV9zZXQoY3R4KTtcbiAgdmFyIGJvZHkgPSBkb2MuYm9keTtcbiAgYm9keS5zdHlsZS5tYXJnaW4gPSBcIjBweFwiO1xuICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yLGNhbWxfZ3JfbW92ZXRvLGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aCxjYW1sX2dyX3NldF90ZXh0X3NpemUsY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2luaXQoKXtcbiAgY2FtbF9ncl9tb3ZldG8oY2FtbF9ncl9zdGF0ZS54LGNhbWxfZ3Jfc3RhdGUueSk7XG4gIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyhjYW1sX2dyX3N0YXRlLndpZHRoLGNhbWxfZ3Jfc3RhdGUuaGVpZ2h0KTtcbiAgY2FtbF9ncl9zZXRfbGluZV93aWR0aChjYW1sX2dyX3N0YXRlLmxpbmVfd2lkdGgpO1xuICBjYW1sX2dyX3NldF90ZXh0X3NpemUoY2FtbF9ncl9zdGF0ZS50ZXh0X3NpemUpO1xuICBjYW1sX2dyX3NldF9mb250KGNhbWxfZ3Jfc3RhdGUuZm9udCk7XG4gIGNhbWxfZ3Jfc2V0X2NvbG9yKGNhbWxfZ3Jfc3RhdGUuY29sb3IpO1xuICBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUoY2FtbF9ncl9zdGF0ZS50aXRsZSk7XG4gIC8vY2FtbF9ncl9yZXNpemVfd2luZG93IG1pZ2h0IHJlc2V0IHNvbWUgY2FudmFzJyBwcm9wZXJ0aWVzXG4gIGNhbWxfZ3Jfc3RhdGUuY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpe1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHJldHVybiB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBjYW52YXMgOiBjYW52YXMsXG4gICAgeCA6IDAsXG4gICAgeSA6IDAsXG4gICAgd2lkdGggOiB3LFxuICAgIGhlaWdodCA6IGgsXG4gICAgbGluZV93aWR0aCA6IDEsXG4gICAgZm9udCA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJmaXhlZFwiKSxcbiAgICB0ZXh0X3NpemUgOiAyNixcbiAgICBjb2xvciA6IDB4MDAwMDAwLFxuICAgIHRpdGxlIDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKVxuICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RvY19vZl9zdGF0ZVxuZnVuY3Rpb24gY2FtbF9ncl9kb2Nfb2Zfc3RhdGUoc3RhdGUpIHtcbiAgaWYoc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gMDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGUobmFtZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50aXRsZSA9IG5hbWU7XG4gIHZhciBqc25hbWUgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYocy5zZXRfdGl0bGUpIHMuc2V0X3RpdGxlKGpzbmFtZSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Jlc2l6ZV93aW5kb3codyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpXG4gIHMud2lkdGggPSB3O1xuICBzLmhlaWdodCA9IGg7XG4gIHMuY2FudmFzLndpZHRoID0gdztcbiAgcy5jYW52YXMuaGVpZ2h0ID0gaDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xlYXJfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NsZWFyX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSBzLndpZHRoO1xuICBzLmNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgLy8gIHMuY29udGV4dC5zdHJva2VSZWN0ICgwLiwgMC4sIHMud2lkdGgsIHMuaGVpZ2h0KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy53aWR0aDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2l6ZV95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zaXplX3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5oZWlnaHQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9jb2xvcihjb2xvcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgZnVuY3Rpb24gY29udmVydChudW1iZXIpIHtcbiAgICB2YXIgc3RyID0gJycgKyBudW1iZXIudG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgMikgc3RyID0gJzAnICsgc3RyO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgdmFyXG4gIHIgPSAoY29sb3IgPj4gMTYpICYgMHhmZixcbiAgZyA9IChjb2xvciA+PiA4KSAgJiAweGZmLFxuICBiID0gKGNvbG9yID4+IDApICAmIDB4ZmY7XG4gIHMuY29sb3I9Y29sb3I7XG4gIHZhciBjX3N0ciA9ICcjJyArIGNvbnZlcnQocikgKyBjb252ZXJ0KGcpICsgY29udmVydChiKTtcbiAgcy5jb250ZXh0LmZpbGxTdHlsZSA9ICAgY19zdHI7XG4gIHMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNfc3RyO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcGxvdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcGxvdCh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgdmFyIGNvbG9yID0gcy5jb2xvcjtcbiAgZFswXSA9IChjb2xvciA+PiAxNikgJiAweGZmOyAvL3JcbiAgZFsxXSA9IChjb2xvciA+PiA4KSAgJiAweGZmLCAvL2dcbiAgZFsyXSA9IChjb2xvciA+PiAwKSAgJiAweGZmOyAvL2JcbiAgZFszXSA9IDB4RkY7IC8vYVxuICBzLng9eDtcbiAgcy55PXk7XG4gIHMuY29udGV4dC5wdXRJbWFnZURhdGEoaW0seCxzLmhlaWdodCAtIHkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9wb2ludF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcG9pbnRfY29sb3IoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0geSwxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHJldHVybiAoZFswXSA8PCAxNikgKyAoZFsxXSA8PCA4KSArIGRbMl07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21vdmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbW92ZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnhcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF95XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3koKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy55XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2xpbmV0b1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbGluZXRvKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMuY29udGV4dC5saW5lVG8oeCxzLmhlaWdodCAtIHkpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5zdHJva2VSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2FyY19hdXgoY3R4LGN4LGN5LHJ5LHJ4LGExLGEyKXtcbiAgd2hpbGUoYTE+YTIpIGEyKz0zNjA7XG4gIGExIC89IDE4MDtcbiAgYTIgLz0gMTgwO1xuICB2YXIgcm90ID0gMCx4UG9zLHlQb3MseFBvc19wcmV2LHlQb3NfcHJldjtcbiAgdmFyIHNwYWNlID0gMjtcbiAgdmFyIG51bSA9ICgoKGEyIC0gYTEpICogTWF0aC5QSSAqICgocngrcnkpLzIpKSAvIHNwYWNlKSB8IDA7XG4gIHZhciBkZWx0YSA9IChhMiAtIGExKSAqIE1hdGguUEkgLyBudW07XG4gIHZhciBpID0gYTEgKiBNYXRoLlBJO1xuICBmb3IgKHZhciBqPTA7ajw9bnVtO2orKyl7XG4gICAgeFBvcyA9IGN4IC0gKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB4UG9zID0geFBvcy50b0ZpeGVkKDIpO1xuICAgIHlQb3MgPSBjeSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ4ICogTWF0aC5zaW4oaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeVBvcyA9IHlQb3MudG9GaXhlZCgyKTtcbiAgICBpZiAoaj09MCkge1xuICAgICAgY3R4Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9IGVsc2UgaWYgKHhQb3NfcHJldiE9eFBvcyB8fCB5UG9zX3ByZXYhPXlQb3Mpe1xuICAgICAgY3R4LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICB9XG4gICAgeFBvc19wcmV2PXhQb3M7XG4gICAgeVBvc19wcmV2PXlQb3M7XG4gICAgaS09IGRlbHRhOy8vY2N3XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NldF9saW5lX3dpZHRoKHcpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMubGluZV93aWR0aCA9IHc7XG4gIHMuY29udGV4dC5saW5lV2lkdGggPSB3XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcmVjdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9yZWN0KHgseSx3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5maWxsUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfcG9seVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9wb2x5KGFyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCBhci5sZW5ndGg7IGkrKylcbiAgICBzLmNvbnRleHQubGluZVRvKGFyW2ldWzFdLHMuaGVpZ2h0IC0gYXJbaV1bMl0pO1xuICBzLmNvbnRleHQubGluZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX2FyY1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXQsIGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX2FyYyh4LHkscngscnksYTEsYTIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY2FtbF9ncl9hcmNfYXV4KHMuY29udGV4dCx4LHMuaGVpZ2h0IC0geSxyeCxyeSxhMSxhMik7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cihzdHIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBtID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHN0cik7XG4gIHZhciBkeCA9IG0ud2lkdGg7XG4gIHMuY29udGV4dC5maWxsVGV4dChzdHIscy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy54ICs9IGR4IHwgMDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfY2hhcihjKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyaW5nKHN0cil7XG4gIGNhbWxfZ3JfZHJhd19zdHIoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoc3RyKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2ZvbnQoZil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5mb250ID0gZjtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShzaXplKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRleHRfc2l6ZSA9IHNpemU7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfdGV4dF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfdGV4dF9zaXplKHR4dCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIHcgPSBzLmNvbnRleHQubWVhc3VyZVRleHQoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcodHh0KSkud2lkdGg7XG4gIHJldHVybiBbMCx3LHMudGV4dF9zaXplXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX21ha2VfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21ha2VfaW1hZ2UoYXJyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaCA9IGFyci5sZW5ndGggLSAxIDtcbiAgdmFyIHcgPSBhcnJbMV0ubGVuZ3RoIC0gMTtcbiAgdmFyIGltID0gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xuICBmb3IodmFyIGk9MDtpPGg7aSsrKXtcbiAgICBmb3IodmFyIGo9MDtqPHc7aisrKXtcbiAgICAgIHZhciBjID0gYXJyW2krMV1baisxXTtcbiAgICAgIHZhciBvID0gaSoodyo0KSArIChqICogNCk7XG4gICAgICBpZihjID09IC0xKSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltLmRhdGFbbyArIDBdID0gYyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gYyA+PiAgOCAmIDB4ZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gYyA+PiAgMCAmIDBYZmY7XG4gICAgICAgIGltLmRhdGFbbyArIDNdID0gMHhmZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGltXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2R1bXBfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2R1bXBfaW1hZ2UoaW0pe1xuICB2YXIgZGF0YSA9IFswXVxuICBmb3IodmFyIGk9MDsgaTxpbS5oZWlnaHQ7aSsrKXtcbiAgICBkYXRhW2krMV0gPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxpbS53aWR0aDtqKyspe1xuICAgICAgdmFyIG8gPSBpKihpbS53aWR0aCo0KSArIChqICogNCksXG4gICAgICAgICAgciA9IGltLmRhdGFbbyswXSxcbiAgICAgICAgICBnID0gaW0uZGF0YVtvKzFdLFxuICAgICAgICAgIGIgPSBpbS5kYXRhW28rMl07XG4gICAgICBkYXRhW2krMV1baisxXSA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgYlxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgaWYoIWltLmltYWdlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5wdXRJbWFnZURhdGEoaW0sMCwwKTtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgICAgIGltLmltYWdlID0gaW1hZ2U7XG4gICAgfVxuICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gIH0gZWxzZSB7XG4gICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbS5pbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NyZWF0ZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3JlYXRlX2ltYWdlKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoeCx5KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYmxpdF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfYmxpdF9pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbTIgPSBzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5LGltLndpZHRoLGltLmhlaWdodCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW0yLmRhdGEubGVuZ3RoOyBpKz00KXtcbiAgICBpbS5kYXRhW2ldID0gaW0yLmRhdGFbaV07XG4gICAgaW0uZGF0YVtpKzFdID0gaW0yLmRhdGFbaSsxXTtcbiAgICBpbS5kYXRhW2krMl0gPSBpbTIuZGF0YVtpKzJdO1xuICAgIGltLmRhdGFbaSszXSA9IGltMi5kYXRhW2krM107XG4gIH1cbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXJcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9faGFuZGxlcigpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19zaWduYWxcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2lnaW9fc2lnbmFsKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dhaXRfZXZlbnRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2FpdF9ldmVudChfZXZsKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2FpdF9ldmVudCBub3QgSW1wbGVtZW50ZWQ6IHVzZSBHcmFwaGljc19qcyBpbnN0ZWFkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N5bmNocm9uaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3N5bmNocm9uaXplICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfc3luY2hyb25pemUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9yZW1lbWJlcl9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3JlbWVtYmVyX21vZGUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZGlzcGxheV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Rpc3BsYXlfbW9kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfZGlzcGxheV9tb2RlIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl93aW5kb3dfaWRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfd2luZG93X2lkKGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfd2luZG93X2lkIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9vcGVuX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX3N1YndpbmRvdyhhLGIsYyxkKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX29wZW5fc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93KGEpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93IG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyLFxuICBDT0RFX0NVU1RPTV9MRU46ICAgICAgICAgICAgMHgxOCxcbiAgQ09ERV9DVVNUT01fRklYRUQ6ICAgICAgICAgIDB4MTlcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbFN0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gTWxTdHJpbmdSZWFkZXIgKHMsIGkpIHsgdGhpcy5zID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTsgdGhpcy5pID0gaTsgfVxuTWxTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucy5zdWJzdHJpbmcoaSwgaSArIGxlbikpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IEJpZ1N0cmluZ1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfYmFfZ2V0XzFcbmZ1bmN0aW9uIEJpZ1N0cmluZ1JlYWRlciAoYnMsIGkpIHsgdGhpcy5zID0gYnM7IHRoaXMuaSA9IGk7IH1cbkJpZ1N0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiBjYW1sX2JhX2dldF8xKHRoaXMucyx0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDgpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCAyNCA+PiAxNikgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKSAgICAgICAgICkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBsZW47IGorKyl7XG4gICAgICBhcnJbal0gPSBjYW1sX2JhX2dldF8xKHRoaXMucywgaStqKTtcbiAgICB9XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkoYXJyKTtcbiAgfVxufVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX2J5dGVzIChhKSB7XG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKGNhbWxfaW50NjRfb2ZfYnl0ZXMgKGEpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChzLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpLCB0eXBlb2Ygb2ZzPT1cIm51bWJlclwiP29mczpvZnNbMF0pO1xuICByZXR1cm4gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICBzaXplWzBdID0gODtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMgKHQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbWFyc2hhbCh3cml0ZXIsIHYsIHNpemVzKSB7XG4gIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB3cml0ZXIud3JpdGUgKDgsIGJbaV0pO1xuICBzaXplc1swXSA9IDg7IHNpemVzWzFdID0gODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl91bm1hcnNoYWxcbmZ1bmN0aW9uIGNhbWxfaW50MzJfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHNpemVbMF0gPSA0O1xuICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsKHJlYWRlciwgc2l6ZSl7XG4gIHN3aXRjaCAocmVhZGVyLnJlYWQ4dSAoKSkge1xuICBjYXNlIDE6XG4gICAgc2l6ZVswXSA9IDQ7XG4gICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICBjYXNlIDI6XG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBuYXRpdmUgaW50ZWdlciB2YWx1ZSB0b28gbGFyZ2VcIik7XG4gIGRlZmF1bHQ6IGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBuYXRpdmUgaW50ZWdlclwiKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsLCBjYW1sX2ludDY0X21hcnNoYWwsIGNhbWxfaW50NjRfY29tcGFyZSwgY2FtbF9pbnQ2NF9oYXNoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX3VubWFyc2hhbCwgY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2JhX3NlcmlhbGl6ZSwgY2FtbF9iYV9kZXNlcmlhbGl6ZSwgY2FtbF9iYV9jb21wYXJlLCBjYW1sX2JhX2hhc2hcbnZhciBjYW1sX2N1c3RvbV9vcHMgPVxuICAgIHtcIl9qXCI6IHtcbiAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQ2NF91bm1hcnNoYWwsXG4gICAgICBzZXJpYWxpemUgIDogY2FtbF9pbnQ2NF9tYXJzaGFsLFxuICAgICAgZml4ZWRfbGVuZ3RoIDogOCxcbiAgICAgIGNvbXBhcmUgOiBjYW1sX2ludDY0X2NvbXBhcmUsXG4gICAgICBoYXNoIDogY2FtbF9pbnQ2NF9oYXNoXG4gICAgfSxcbiAgICAgXCJfaVwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDMyX3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9uXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCxcbiAgICAgICBmaXhlZF9sZW5ndGggOiA0LFxuICAgICB9LFxuICAgICBcIl9iaWdhcnJheVwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfYmFfZGVzZXJpYWxpemUsXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH1cbiAgICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG5cbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpIHtcbiAgdmFyIF9tYWdpYyA9IHJlYWRlci5yZWFkMzJ1ICgpXG4gIHZhciBfYmxvY2tfbGVuID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBudW1fb2JqZWN0cyA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfMzIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzY0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgaW50ZXJuX29ial90YWJsZSA9IChudW1fb2JqZWN0cyA+IDApP1tdOm51bGw7XG4gIHZhciBvYmpfY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIGludGVybl9yZWMgKCkge1xuICAgIHZhciBjb2RlID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICBpZiAoY29kZSA+PSAweDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLykge1xuICAgICAgaWYgKGNvZGUgPj0gMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLykge1xuICAgICAgICB2YXIgdGFnID0gY29kZSAmIDB4RjtcbiAgICAgICAgdmFyIHNpemUgPSAoY29kZSA+PiA0KSAmIDB4NztcbiAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIChjb2RlICYgMHgzRik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb2RlID49IDB4MjAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HICovKSB7XG4gICAgICAgIHZhciBsZW4gPSBjb2RlICYgMHgxRjtcbiAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgMHgwMDogLy9jc3QuQ09ERV9JTlQ4OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDhzICgpO1xuICAgICAgICBjYXNlIDB4MDE6IC8vY3N0LkNPREVfSU5UMTY6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMTZzICgpO1xuICAgICAgICBjYXNlIDB4MDI6IC8vY3N0LkNPREVfSU5UMzI6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xuICAgICAgICBjYXNlIDB4MDM6IC8vY3N0LkNPREVfSU5UNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbnRlZ2VyIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA0OiAvL2NzdC5DT0RFX1NIQVJFRDg6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDU6IC8vY3N0LkNPREVfU0hBUkVEMTY6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMTZ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA2OiAvL2NzdC5DT0RFX1NIQVJFRDMyOlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwODogLy9jc3QuQ09ERV9CTE9DSzMyOlxuICAgICAgICAgIHZhciBoZWFkZXIgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICB2YXIgdGFnID0gaGVhZGVyICYgMHhGRjtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGhlYWRlciA+PiAxMDtcbiAgICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTM6IC8vY3N0LkNPREVfQkxPQ0s2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBkYXRhIGJsb2NrIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA5OiAvL2NzdC5DT0RFX1NUUklORzg6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBBOiAvL2NzdC5DT0RFX1NUUklORzMyOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEM6IC8vY3N0LkNPREVfRE9VQkxFX0xJVFRMRTpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0WzcgLSBpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQjogLy9jc3QuQ09ERV9ET1VCTEVfQklHOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEU6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRDogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDA3OiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0WzcgLSBqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHZbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRjogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMDogLy9jc3QuQ09ERV9DT0RFUE9JTlRFUjpcbiAgICAgICAgY2FzZSAweDExOiAvL2NzdC5DT0RFX0lORklYUE9JTlRFUjpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBjb2RlIHBvaW50ZXJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMjogLy9jc3QuQ09ERV9DVVNUT006XG4gICAgICAgIGNhc2UgMHgxODogLy9jc3QuQ09ERV9DVVNUT01fTEVOOlxuICAgICAgICBjYXNlIDB4MTk6IC8vY3N0LkNPREVfQ1VTVE9NX0ZJWEVEOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbc107XG4gICAgICAgICAgdmFyIGV4cGVjdGVkX3NpemU7XG4gICAgICAgICAgaWYoIW9wcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogdW5rbm93biBjdXN0b20gYmxvY2sgaWRlbnRpZmllclwiKTtcbiAgICAgICAgICBzd2l0Y2goY29kZSl7XG4gICAgICAgICAgY2FzZSAweDEyOiAvLyBjc3QuQ09ERV9DVVNUT00gKGRlcHJlY2F0ZWQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTk6IC8vIGNzdC5DT0RFX0NVU1RPTV9GSVhFRFxuICAgICAgICAgICAgaWYoIW9wcy5maXhlZF9sZW5ndGgpXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogZXhwZWN0ZWQgYSBmaXhlZC1zaXplIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSBvcHMuZml4ZWRfbGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE4OiAvLyBjc3QuQ09ERV9DVVNUT01fTEVOXG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgICAvLyBTa2lwIHNpemU2NFxuICAgICAgICAgICAgcmVhZGVyLnJlYWQzMnMoKTsgcmVhZGVyLnJlYWQzMnMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHJlYWRlci5pO1xuICAgICAgICAgIHZhciBzaXplID0gWzBdO1xuICAgICAgICAgIHZhciB2ID0gb3BzLmRlc2VyaWFsaXplKHJlYWRlciwgc2l6ZSk7XG4gICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoZXhwZWN0ZWRfc2l6ZSAhPSBzaXplWzBdKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGluY29ycmVjdCBsZW5ndGggb2Ygc2VyaWFsaXplZCBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoIChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IGludGVybl9yZWMgKCk7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNpemUgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBkID0gdi5sZW5ndGg7XG4gICAgaWYgKGQgPCBzaXplKSBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgIHZbZF0gPSBpbnRlcm5fcmVjICgpO1xuICB9XG4gIGlmICh0eXBlb2Ygb2ZzIT1cIm51bWJlclwiKSBvZnNbMF0gPSByZWFkZXIuaTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKHMsIG9mcykge1xuICBmdW5jdGlvbiBnZXQzMihzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpKSA8PCAyNCkgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDIpIDw8IDgpIHxcbiAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIH1cbiAgaWYgKGdldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGdldDMyKHMsIG9mcyArIDQpKTtcbn1cblxuLy9Qcm92aWRlczogTWxPYmplY3RUYWJsZVxudmFyIE1sT2JqZWN0VGFibGU7XG5pZiAodHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LldlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBwb2x5ZmlsbCAodXNpbmcgbGluZWFyIHNlYXJjaCkgKi9cbiAgICBmdW5jdGlvbiBOYWl2ZUxvb2t1cChvYmpzKSB7IHRoaXMub2JqcyA9IG9ianM7IH1cbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gdikgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfTtcbiAgICBOYWl2ZUxvb2t1cC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGhlcmUuIFtNbE9iamVjdFRhYmxlLnN0b3JlXSB3aWxsIHB1c2ggdG8gW3RoaXMub2Jqc10gZGlyZWN0bHkuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IE5haXZlTG9va3VwKHRoaXMub2Jqcyk7XG4gICAgfTtcbiAgfSgpO1xufVxuZWxzZSB7XG4gIE1sT2JqZWN0VGFibGUgPSBmdW5jdGlvbiBNbE9iamVjdFRhYmxlKCkge1xuICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwKCk7XG4gIH07XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24odikge1xuICB0aGlzLmxvb2t1cC5zZXQodiwgdGhpcy5vYmpzLmxlbmd0aCk7XG4gIHRoaXMub2Jqcy5wdXNoKHYpO1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5yZWNhbGwgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBpID0gdGhpcy5sb29rdXAuZ2V0KHYpO1xuICByZXR1cm4gKGkgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZCA6IHRoaXMub2Jqcy5sZW5ndGggLSBpOyAgIC8qIGluZGV4IGlzIHJlbGF0aXZlICovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246ID49IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IGZhbHNlXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlXG4vL1ZlcnNpb246IDwgNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gdHJ1ZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWxcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogTWxPYmplY3RUYWJsZSwgY2FtbF9saXN0X3RvX2pzX2FycmF5LCBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2F0OmZ1bmN0aW9uIChwb3MsIHNpemUsIHZhbHVlKSB7XG4gICAgICB2YXIgcG9zID0gcG9zO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbcG9zKytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX3NoYXJlZDpmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICBpZiAob2Zmc2V0IDwgKDEgPDwgOCkpIHRoaXMud3JpdGVfY29kZSg4LCAweDA0IC8qY3N0LkNPREVfU0hBUkVEOCovLCBvZmZzZXQpO1xuICAgICAgZWxzZSBpZiAob2Zmc2V0IDwgKDEgPDwgMTYpKSB0aGlzLndyaXRlX2NvZGUoMTYsIDB4MDUgLypjc3QuQ09ERV9TSEFSRUQxNiovLCBvZmZzZXQpO1xuICAgICAgZWxzZSB0aGlzLndyaXRlX2NvZGUoMzIsIDB4MDYgLypjc3QuQ09ERV9TSEFSRUQzMiovLCBvZmZzZXQpO1xuICAgIH0sXG4gICAgcG9zOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2h1bmtfaWR4IH0sXG4gICAgZmluYWxpemU6ZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5ibG9ja19sZW4gPSB0aGlzLmNodW5rX2lkeCAtIDIwO1xuICAgICAgdGhpcy5jaHVua19pZHggPSAwO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIDB4ODQ5NUE2QkUpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuYmxvY2tfbGVuKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLm9ial9jb3VudGVyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfMzIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV82NCk7XG4gICAgICByZXR1cm4gdGhpcy5jaHVuaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh2LCBmbGFncykge1xuICAgIGZsYWdzID0gY2FtbF9saXN0X3RvX2pzX2FycmF5KGZsYWdzKTtcblxuICAgIHZhciBub19zaGFyaW5nID0gKGZsYWdzLmluZGV4T2YoMCAvKk1hcnNoYWwuTm9fc2hhcmluZyovKSAhPT0gLTEpLFxuICAgICAgICBjbG9zdXJlcyA9ICAoZmxhZ3MuaW5kZXhPZigxIC8qTWFyc2hhbC5DbG9zdXJlcyovKSAhPT0gLTEpO1xuICAgICAgICAvKiBNYXJzaGFsLkNvbXBhdF8zMiBpcyByZWR1bmRhbnQgc2luY2UgaW50ZWdlcnMgYXJlIDMyLWJpdCBhbnl3YXkgKi9cblxuICAgIGlmIChjbG9zdXJlcylcbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUud2FybihcImluIGNhbWxfb3V0cHV0X3ZhbDogZmxhZyBNYXJzaGFsLkNsb3N1cmVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBXcml0ZXIgKCk7XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGludGVybl9vYmpfdGFibGUgPSBub19zaGFyaW5nID8gbnVsbCA6IG5ldyBNbE9iamVjdFRhYmxlKCk7XG5cbiAgICBmdW5jdGlvbiBtZW1vKHYpIHtcbiAgICAgIGlmIChub19zaGFyaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgZXhpc3Rpbmdfb2Zmc2V0ID0gaW50ZXJuX29ial90YWJsZS5yZWNhbGwodik7XG4gICAgICBpZiAoZXhpc3Rpbmdfb2Zmc2V0KSB7IHdyaXRlci53cml0ZV9zaGFyZWQoZXhpc3Rpbmdfb2Zmc2V0KTsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgeyBpbnRlcm5fb2JqX3RhYmxlLnN0b3JlKHYpOyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlcm5fcmVjICh2KSB7XG4gICAgICBpZiAodi5jYW1sX2N1c3RvbSkge1xuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZSA9IHYuY2FtbF9jdXN0b207XG4gICAgICAgIHZhciBvcHMgPSBjYW1sX2N1c3RvbV9vcHNbbmFtZV07XG4gICAgICAgIHZhciBzel8zMl82NCA9IFswLDBdO1xuICAgICAgICBpZighb3BzLnNlcmlhbGl6ZSlcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChDdXN0b20pXCIpO1xuICAgICAgICBpZihjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxMiAvKmNzdC5DT0RFX0NVU1RPTSovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgIH0gZWxzZSBpZihvcHMuZml4ZWRfbGVuZ3RoID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE4IC8qY3N0LkNPREVfQ1VTVE9NX0xFTiovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBoZWFkZXJfcG9zID0gd3JpdGVyLnBvcyAoKTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zLCAzMiwgc3pfMzJfNjRbMF0pO1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgNCwgMzIsIDApOyAvLyB6ZXJvXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA4LCAzMiwgc3pfMzJfNjRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOSAvKmNzdC5DT0RFX0NVU1RPTV9GSVhFRCovKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIG5hbWUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlKDgsIDApO1xuICAgICAgICAgIHZhciBvbGRfcG9zID0gd3JpdGVyLnBvcygpO1xuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgaWYgKG9wcy5maXhlZF9sZW5ndGggIT0gd3JpdGVyLnBvcygpIC0gb2xkX3BvcylcbiAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGluY29ycmVjdCBmaXhlZCBzaXplcyBzcGVjaWZpZWQgYnkgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAyICsgKChzel8zMl82NFswXSArIDMpID4+IDIpO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAyICsgKChzel8zMl82NFsxXSArIDcpID4+IDMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICAgIGlmICh2WzBdID09IDI1MSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChBYnN0cmFjdClcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSAmJiBtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgICBpZighKGNhbWxfaXNfbWxfYnl0ZXMoY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKSkpKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogW0J5dGVzLnRdIGNhbm5vdCBzYWZlbHkgYmUgbWFyc2hhbGVkIHdpdGggWy0tZW5hYmxlIHVzZS1qcy1zdHJpbmddXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldCh2LGkpKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMSArICgoKGxlbiArIDQpIC8gNCl8MCk7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDEgKyAoKChsZW4gKyA4KSAvIDgpfDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgIT0gKHZ8MCkpe1xuICAgICAgICAgIHZhciB0eXBlX29mX3YgPSB0eXBlb2YgdjtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGEgZmxvYXQgaGFwcGVucyB0byBiZSBhbiBpbnRlZ2VyIGl0IGlzIHNlcmlhbGl6ZWQgYXMgYW4gaW50ZWdlclxuICAgICAgICAgIC8vIChKc19vZl9vY2FtbCBjYW5ub3QgdGVsbCB3aGV0aGVyIHRoZSB0eXBlIG9mIGFuIGludGVnZXIgbnVtYmVyIGlzXG4gICAgICAgICAgLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuICAgICAgICAgIC8vIHVubWFyc2hhbGxpbmcgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bnRpbWUuIEl0IHNlZW1zIGJldHRlciB0b1xuICAgICAgICAgIC8vIHN5c3RlbWF0aWNhbGx5IGZhaWwgb24gbWFyc2hhbGxpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgICAgICAgICBpZih0eXBlX29mX3YgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoXCIrdHlwZV9vZl92K1wiKVwiKTtcbiAgICAgICAgICAvLyAgICAgICAgICB2YXIgdCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHYpKTtcbiAgICAgICAgICAvLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuICAgICAgICAgIC8vICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8ODsgaSsrKXt3cml0ZXIud3JpdGUoOCx0W2ldKX1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IDAgJiYgdiA8IDB4NDApIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDBYNDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovICsgdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHYgPj0gLSgxIDw8IDcpICYmIHYgPCAoMSA8PCA3KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDgsIDB4MDAgLypjc3QuQ09ERV9JTlQ4Ki8sIHYpO1xuICAgICAgICAgIGVsc2UgaWYgKHYgPj0gLSgxIDw8IDE1KSAmJiB2IDwgKDEgPDwgMTUpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMTYsIDB4MDEgLypjc3QuQ09ERV9JTlQxNiovLCB2KTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwMiAvKmNzdC5DT0RFX0lOVDMyKi8sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGV4dGVybl9yZWMgKHYpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIHZhciB2ID0gc3RhY2sucG9wICgpO1xuICAgICAgaWYgKGkgKyAxIDwgdi5sZW5ndGgpIHN0YWNrLnB1c2ggKHYsIGkgKyAxKTtcbiAgICAgIGV4dGVybl9yZWMgKHZbaV0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgd3JpdGVyLm9ial9jb3VudGVyID0gaW50ZXJuX29ial90YWJsZS5vYmpzLmxlbmd0aDtcbiAgICB3cml0ZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2J5dGVzX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgZmxhZ3MpIHtcbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKTtcbiAgaWYgKHQubGVuZ3RoID4gbGVuKSBjYW1sX2ZhaWx3aXRoIChcIk1hcnNoYWwudG9fYnVmZmVyOiBidWZmZXIgb3ZlcmZsb3dcIik7XG4gIGNhbWxfYmxpdF9ieXRlcyh0LCAwLCBzLCBvZnMsIHQubGVuZ3RoKTtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIElvXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICBkZWxldGUgY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfc3RkX291dHB1dChjaGFuaWQscyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgc3RyID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKTtcbiAgdmFyIHNsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgY2hhbi5maWxlLndyaXRlKGNoYW4ub2Zmc2V0LCBzdHIsIDAsIHNsZW4pO1xuICBjaGFuLm9mZnNldCArPSBzbGVuO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfb3BlblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLE1sRmFrZUZpbGVcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyciwganNfcHJpbnRfc3Rkb3V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuX2ludGVybmFsKGlkeCxvdXRwdXQsZmlsZSxmbGFncykge1xuICBpZihjYW1sX2dsb2JhbF9kYXRhLmZkcyA9PT0gdW5kZWZpbmVkKSBjYW1sX2dsb2JhbF9kYXRhLmZkcyA9IG5ldyBBcnJheSgpO1xuICBmbGFncz1mbGFncz9mbGFnczp7fTtcbiAgdmFyIGluZm8gPSB7fTtcbiAgaW5mby5maWxlID0gZmlsZTtcbiAgaW5mby5vZmZzZXQgPSBmbGFncy5hcHBlbmQ/ZmlsZS5sZW5ndGgoKTowO1xuICBpbmZvLmZsYWdzID0gZmxhZ3M7XG4gIGluZm8ub3V0cHV0ID0gb3V0cHV0O1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tpZHhdID0gaW5mbztcbiAgaWYoIWNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggfHwgaWR4ID4gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeClcbiAgICBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4ID0gaWR4O1xuICByZXR1cm4gaWR4O1xufVxuZnVuY3Rpb24gY2FtbF9zeXNfb3BlbiAobmFtZSwgZmxhZ3MsIF9wZXJtcykge1xuICB2YXIgZiA9IHt9O1xuICB3aGlsZShmbGFncyl7XG4gICAgc3dpdGNoKGZsYWdzWzFdKXtcbiAgICBjYXNlIDA6IGYucmRvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDE6IGYud3Jvbmx5ID0gMTticmVhaztcbiAgICBjYXNlIDI6IGYuYXBwZW5kID0gMTticmVhaztcbiAgICBjYXNlIDM6IGYuY3JlYXRlID0gMTticmVhaztcbiAgICBjYXNlIDQ6IGYudHJ1bmNhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNTogZi5leGNsID0gMTsgYnJlYWs7XG4gICAgY2FzZSA2OiBmLmJpbmFyeSA9IDE7YnJlYWs7XG4gICAgY2FzZSA3OiBmLnRleHQgPSAxO2JyZWFrO1xuICAgIGNhc2UgODogZi5ub25ibG9jayA9IDE7YnJlYWs7XG4gICAgfVxuICAgIGZsYWdzPWZsYWdzWzJdO1xuICB9XG4gIGlmKGYucmRvbmx5ICYmIGYud3Jvbmx5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3RleHQgYW5kIE9wZW5fYmluYXJ5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCxmKTtcbiAgdmFyIGlkeCA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg/Y2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeDowO1xuICByZXR1cm4gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCAoaWR4KzEsY2FtbF9zdGRfb3V0cHV0LGZpbGUsZik7XG59XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDAsY2FtbF9zdGRfb3V0cHV0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGluXG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDEsanNfcHJpbnRfc3Rkb3V0LCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZG91dFxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgyLGpzX3ByaW50X3N0ZGVyciwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRlcnJcblxuXG4vLyBvY2FtbCBDaGFubmVsc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX25hbWVcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSgpIHtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsc1xudmFyIGNhbWxfbWxfY2hhbm5lbHMgPSBuZXcgQXJyYXkoKTtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCAoKSB7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBjID0gMDsgYyA8IGNhbWxfbWxfY2hhbm5lbHMubGVuZ3RoOyBjKyspe1xuICAgIGlmKGNhbWxfbWxfY2hhbm5lbHNbY10gJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vcGVuZWQgJiYgY2FtbF9tbF9jaGFubmVsc1tjXS5vdXQpXG4gICAgICBsPVswLGNhbWxfbWxfY2hhbm5lbHNbY10uZmQsbF07XG4gIH1cbiAgcmV0dXJuIGw7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IChmZCkge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy5yZG9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgcmVhZG9ubHlcIik7XG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6dHJ1ZSxcbiAgICBidWZmZXI6XCJcIlxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pblxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N5c19vcGVuLGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9pbiAoZmQpICB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLndyb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyB3cml0ZW9ubHlcIik7XG5cbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDogZmFsc2UsXG4gICAgcmVmaWxsOm51bGxcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXTtcbiAgZGF0YS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgZGF0YS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjaGFuLmZpbGUuY2xvc2UoKTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0ID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKSB7XG4gIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICB2YXIgc3RyX2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBpZiAoc3RyX2xlbiA9PSAwKSBjaGFuLnJlZmlsbCA9IG51bGw7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLmZpbGUubGVuZ3RoKCksIHN0ciwgMCwgc3RyX2xlbik7XG4gIHJldHVybiBzdHJfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsID09IG51bGwpIHJldHVybjtcbiAgaWYgKGNoYW4uZmlsZS5sZW5ndGgoKSAhPSBjaGFuLm9mZnNldCkgcmV0dXJuO1xuICBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIHMsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBsMiA9IGNoYW4uZmlsZS5sZW5ndGgoKSAtIGNoYW4ub2Zmc2V0O1xuICBpZiAobDIgPT0gMCAmJiBjaGFuLnJlZmlsbCAhPSBudWxsKSBsMiA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICBpZiAobDIgPCBsKSBsID0gbDI7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBzLCBpLCBsKTtcbiAgY2hhbi5vZmZzZXQgKz0gbDtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMoOCk7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLDgpO1xuXG4gIC8vIEhlYWRlciBpcyAyMCBieXRlc1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoYnVmLCAwKSArIDIwO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuXG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoYnVmLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICBpZiAoY2hhbi5vZmZzZXQgPj0gY2hhbi5maWxlLmxlbmd0aCgpKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uZmlsZS5yZWFkX29uZShjaGFuLm9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0Kys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGZpbGUgPSBjaGFuLmZpbGU7XG4gIHdoaWxlICgoY2hhbi5vZmZzZXQgKyAzKSA+PSBmaWxlLmxlbmd0aCgpKSB7XG4gICAgdmFyIGwgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgICBpZiAobCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH1cbiAgdmFyIG8gPSBjaGFuLm9mZnNldDtcbiAgdmFyIHIgPShmaWxlLnJlYWRfb25lKG8gICkgPDwgMjQpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzEpIDw8IDE2KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysyKSA8PCA4KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobyszKSk7XG4gIGNoYW4ub2Zmc2V0Kz00O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7cmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXR9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtyZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KX1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICB2YXIgcCA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihwID49IGxlbikgeyByZXR1cm4gMDt9XG4gIHdoaWxlKHRydWUpIHtcbiAgICBpZihwID49IGxlbikgcmV0dXJuIC0gKHAgLSBjaGFuLm9mZnNldCk7XG4gICAgaWYoY2hhbi5maWxlLnJlYWRfb25lKHApID09IDEwKSByZXR1cm4gcCAtIGNoYW4ub2Zmc2V0ICsgMTtcbiAgICBwKys7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9mbHVzaFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyID09IFwiXCIpIHJldHVybiAwO1xuICBpZihjaGFuLmZkXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQ7XG4gICAgc3dpdGNoKG91dHB1dC5sZW5ndGgpe1xuICAgIGNhc2UgMjogb3V0cHV0KGNoYW5pZCxjaGFuLmJ1ZmZlcik7YnJlYWs7XG4gICAgZGVmYXVsdDogb3V0cHV0KGNoYW4uYnVmZmVyKVxuICAgIH07XG4gIH1cbiAgY2hhbi5idWZmZXIgPSBcIlwiO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIGJ5dGVzO1xuICBpZihvZmZzZXQgPT0gMCAmJiBjYW1sX21sX2J5dGVzX2xlbmd0aChidWZmZXIpID09IGxlbilcbiAgICBieXRlcyA9IGJ1ZmZlcjtcbiAgZWxzZSB7XG4gICAgYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LGJ5dGVzLDAsbGVuKTtcbiAgfVxuICB2YXIgc3RyaW5nID0gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnl0ZXMpO1xuICB2YXIganNzdHJpbmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHN0cmluZyk7XG4gIHZhciBpZCA9IGpzc3RyaW5nLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICBpZihpZCA8IDApXG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nO1xuICBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmcuc3Vic3RyKDAsaWQrMSk7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBjaGFuLmJ1ZmZlciArPSBqc3N0cmluZy5zdWJzdHIoaWQrMSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsY2FtbF9ieXRlc19vZl9zdHJpbmcoYnVmZmVyKSxvZmZzZXQsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIgKGNoYW5pZCxjKSB7XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUgKGNoYW5pZCx2LGZsYWdzKSB7XG4gIHZhciBzID0gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYsIGZsYWdzKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCxjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0XzY0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9pbnQgKGNoYW5pZCxpKSB7XG4gIHZhciBhcnIgPSBbKGk+PjI0KSAmIDB4RkYsKGk+PjE2KSAmIDB4RkYsKGk+PjgpICYgMHhGRixpICYgMHhGRiBdO1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsNCk7XG4gIHJldHVybiAwXG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY29tcGFjdGlvblxuZnVuY3Rpb24gY2FtbF9nY19jb21wYWN0aW9uKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb3VudGVyc1xuZnVuY3Rpb24gY2FtbF9nY19jb3VudGVycygpIHsgcmV0dXJuIFsyNTQsMCwwLDBdIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuLy9Qcm92aWRlczogY2FtbF9nY19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmQsIEFuZHkgUmF5XG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4vL1xuLy8gQmlnYXJyYXkuXG4vL1xuLy8gLSBhbGwgYmlnYXJyYXkgdHlwZXMgaW5jbHVkaW5nIEludDY0IGFuZCBDb21wbGV4LlxuLy8gLSBmb3J0cmFuICsgYyBsYXlvdXRzXG4vLyAtIHN1Yi9zbGljZS9yZXNoYXBlXG4vLyAtIHJldGFpbiBmYXN0IHBhdGggZm9yIDFkIGFycmF5IGFjY2Vzc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdCgpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSB7XG4gIHZhciBuX2RpbXMgPSBkaW1zLmxlbmd0aDtcbiAgdmFyIHNpemUgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltczsgaSsrKSB7XG4gICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgc2l6ZSA9IHNpemUgKiBkaW1zW2ldO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpe1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgNzogY2FzZSAxMDogY2FzZSAxMTogcmV0dXJuIDI7XG4gIGRlZmF1bHQ6IHJldHVybiAxO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciB2aWV3O1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMDogIHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTogIHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMjogIHZpZXcgPSBnLkludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgMzogIHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDQ6ICB2aWV3ID0gZy5JbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA1OiAgdmlldyA9IGcuVWludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDY6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA3OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgODogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDk6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMDogdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxMTogdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAxMjogdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIH1cbiAgaWYgKCF2aWV3KSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHZhciBkYXRhID0gbmV3IHZpZXcoc2l6ZSAqIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfaGkzMiwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBNbF9CaWdhcnJheSAoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcblxuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2JpZ2FycmF5XCI7XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciBvZnMgPSAwO1xuICBpZih0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSBhcmcgPSBbYXJnXTtcbiAgaWYgKCEgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnYXJyYXkuanM6IGludmFsaWQgb2Zmc2V0XCIpO1xuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBhcmcubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgaWYodGhpcy5sYXlvdXQgPT0gMCAvKiBjX2xheW91dCAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMCB8fCBhcmdbaV0gPj0gdGhpcy5kaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIGFyZ1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZGltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFyZ1tpXSA8IDEgfHwgYXJnW2ldID4gdGhpcy5kaW1zW2ldKXtcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgfVxuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyAoYXJnW2ldIC0gMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvZnM7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsLGgpO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIHIgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBpID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdXG4gIH1cbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IHZbMV07XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhW29mc10gPSB2O1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwXG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGEgPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdmFyIGIgPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgaWYoYSA9PSBiKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGEgOiBiO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciBpbSA9IHZbMV07XG4gICAgdmFyIHJlID0gdlsyXTtcbiAgICBpZihpbSA9PSByZSl7XG4gICAgICB0aGlzLmRhdGEuZmlsbChpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gaW0gOiByZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiLCB0b3RhbCkge1xuICBpZiAodGhpcy5sYXlvdXQgIT0gYi5sYXlvdXQgfHwgdGhpcy5raW5kICE9IGIua2luZCkge1xuICAgIHZhciBrMSA9IHRoaXMua2luZCB8ICh0aGlzLmxheW91dCA8PCA4KTtcbiAgICB2YXIgazIgPSAgICBiLmtpbmQgfCAoYi5sYXlvdXQgPDwgOCk7XG4gICAgcmV0dXJuIGsyIC0gazE7XG4gIH1cbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYi5kaW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAodGhpcy5kaW1zW2ldICE9IGIuZGltc1tpXSlcbiAgICAgIHJldHVybiAodGhpcy5kaW1zW2ldIDwgYi5kaW1zW2ldKSA/IC0xIDogMTtcbiAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gIGNhc2UgMTA6XG4gIGNhc2UgMTE6XG4gICAgLy8gRmxvYXRzXG4gICAgdmFyIHgsIHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSB0aGlzLmRhdGFbaV07XG4gICAgICB5ID0gYi5kYXRhW2ldO1xuICAgICAgaWYgKHggPCB5KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoeCA+IHkpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICBpZiAoeCA9PSB4KSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHkgPT0geSkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAvLyBDaGVjayBoaWdoZXN0IGJpdHMgZmlyc3RcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA8IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPiBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPCAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApID4gKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICBjYXNlIDM6XG4gIGNhc2UgNDpcbiAgY2FzZSA1OlxuICBjYXNlIDY6XG4gIGNhc2UgODpcbiAgY2FzZSA5OlxuICBjYXNlIDEyOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldID4gYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgICA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlID0gbmV3IE1sX0JpZ2FycmF5KClcbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpe1xuICAgIGlmKChhcmcgaW5zdGFuY2VvZiBBcnJheSkgJiYgYXJnLmxlbmd0aCA9PSAxKVxuICAgICAgYXJnID0gYXJnWzBdO1xuICAgIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiTWxfQmlnYXJyYXlfY18xXzEub2Zmc2V0XCIpO1xuICB9XG4gIGlmIChhcmcgPCAwIHx8IGFyZyA+PSB0aGlzLmRpbXNbMF0pXG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJnO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICByZXR1cm4gdGhpcy5kYXRhW29mc107XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgdGhpcy5kYXRhW29mc10gPSB2O1xuICByZXR1cm4gMFxufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuZGF0YS5maWxsKHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NvbXBhcmVcbmZ1bmN0aW9uIGNhbWxfYmFfY29tcGFyZShhLGIsdG90YWwpe1xuICByZXR1cm4gYS5jb21wYXJlKGIsdG90YWwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpe1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCk7XG4gIGlmKGNhbWxfYmFfZ2V0X3NpemUoZGltcykgKiBzaXplX3Blcl9lbGVtZW50ICE9IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZihsYXlvdXQgPT0gMCAmJiAvLyBjX2xheW91dFxuICAgICBkaW1zLmxlbmd0aCA9PSAxICYmIC8vIEFycmF5MVxuICAgICBzaXplX3Blcl9lbGVtZW50ID09IDEpIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG5cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGUoa2luZCwgbGF5b3V0LCBkaW1zX21sKSB7XG4gIHZhciBkaW1zID0gY2FtbF9qc19mcm9tX2FycmF5KGRpbXNfbWwpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBjYW1sX2JhX2dldF9zaXplKGRpbXMpKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NoYW5nZV9sYXlvdXRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9jaGFuZ2VfbGF5b3V0KGJhLCBsYXlvdXQpIHtcbiAgaWYoYmEubGF5b3V0ID09IGxheW91dCkgcmV0dXJuIGJhO1xuICB2YXIgbmV3X2RpbXMgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2JhLmRpbXMubGVuZ3RoIC0gaSAtIDFdO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGxheW91dCwgbmV3X2RpbXMsIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICByZXR1cm4gYmEua2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9sYXlvdXRcbmZ1bmN0aW9uIGNhbWxfYmFfbGF5b3V0KGJhKSB7XG4gIHJldHVybiBiYS5sYXlvdXQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbnVtX2RpbXNcbmZ1bmN0aW9uIGNhbWxfYmFfbnVtX2RpbXMoYmEpIHtcbiAgcmV0dXJuIGJhLmRpbXMubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2RpbShiYSwgaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMpO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzICsgMSk7XG4gIHJldHVybiAoYjEgfCAoYjIgPDwgOCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICByZXR1cm4gKCAoYjEgPDwgMCkgIHxcbiAgICAgICAgICAgKGIyIDw8IDgpICB8XG4gICAgICAgICAgIChiMyA8PCAxNikgfFxuICAgICAgICAgICAoYjQgPDwgMjQpICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0NjQoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHZhciBiNSA9IGJhLmdldChvZnMrNCk7XG4gIHZhciBiNiA9IGJhLmdldChvZnMrNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMrNik7XG4gIHZhciBiOCA9IGJhLmdldChvZnMrNyk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFtiOCxiNyxiNixiNSxiNCxiMyxiMixiMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8xKGJhLCBpMCkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChpMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8yXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8yKGJhLCBpMCwgaTEpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3NldF9nZW5lcmljKGJhLCBpLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0NjQoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDg7IGkrKykgYmEuc2V0KG9mcytpLCB2WzctaV0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzIoYmEsIGkwLCBpMSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMV0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYmFfZmlsbChiYSwgdikge1xuICBiYS5maWxsKHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfYmxpdChzcmMsIGRzdCkge1xuICBpZiAoZHN0LmRpbXMubGVuZ3RoICE9IHNyYy5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZHN0LmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRzdC5kaW1zW2ldICE9IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYmEuZGltcy5sZW5ndGggLSAxKTsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgKG9mcyArIGxlbikgPiBiYS5kaW1zW2NoYW5nZWRfZGltXSl7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc3ViOiBiYWQgc3ViLWFycmF5XCIpO1xuICB9XG4gIHZhciBuZXdfZGltcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMDtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UobnVtX2luZHMpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2JhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMgKyBpXSA9IHZpbmRbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDE7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKDAsIGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMpO1xuICB9XG4gIG9mcyA9IGJhLm9mZnNldChpbmRleCk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShzdWJfZGltcyk7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBzaXplX3Blcl9lbGVtZW50LCAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50KTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIHN1Yl9kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfcmVzaGFwZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuZnVuY3Rpb24gY2FtbF9iYV9yZXNoYXBlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBuZXdfZGltID0gW107XG4gIHZhciBudW1fZGltcyA9IHZpbmQubGVuZ3RoO1xuXG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT0gc2l6ZSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBzaXplIG1pc21hdGNoXCIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbSwgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9zZXJpYWxpemUod3JpdGVyLCBiYSwgc3opIHtcbiAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZSgzMiwgKGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB3cml0ZXIud3JpdGUoMzIsYmEuZGltc1tpXSk7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3ope1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSBkaW1zLnB1c2gocmVhZGVyLnJlYWQzMnUoKSk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSk7XG4gIHZhciBiYSA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHZhciBzaXh0eSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICBpZihzaXh0eSkgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjYW5ub3QgcmVhZCBiaWdhcnJheSB3aXRoIDY0LWJpdCBPQ2FtbCBpbnRzXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6IC8vIChpbnQ2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgYmEuc2V0KGksaW50NjQpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVha1xuICB9XG4gIHN6WzBdID0gKDQgKyBudW1fZGltcykgKiA0O1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vRGVwcmVjYXRlZFxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YTEsIGRhdGEyLCBqc3R5cCwga2luZCwgbGF5b3V0LCBkaW1zKXtcbiAgaWYoZGF0YTIgfHwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSA9PSAyKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2NyZWF0ZV9mcm9tOiB1c2UgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVwiKTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YTEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX2hhc2goYmEpe1xuICB2YXIgbnVtX2VsdHMgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICB2YXIgaCA9IDA7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMjU2KSBudW1fZWx0cyA9IDI1NjtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgNCA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCA4KSB8IChiYS5kYXRhW2krMl0gPDwgMTYpIHwgKGJhLmRhdGFbaSszXSA8PCAyNCk7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgdyA9IDA7XG4gICAgc3dpdGNoIChudW1fZWx0cyAmIDMpIHtcbiAgICBjYXNlIDM6IHcgID0gYmEuZGF0YVtpKzJdIDw8IDE2OyAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMjogdyB8PSBiYS5kYXRhW2krMV0gPDwgODsgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAxOiB3IHw9IGJhLmRhdGFbaSswXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDIgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTIpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgMTYpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIGlmICgobnVtX2VsdHMgJiAxKSAhPSAwKVxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIG51bV9lbHRzICo9IDJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYmEpe1xuICByZXR1cm4gYmEuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIGtpbmQ7XG4gIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQzMkFycmF5KSBraW5kID0gMDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDhBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQxNkFycmF5KSBraW5kID0gNTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiBvIGluc3RhbmNlb2YgYzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvcj9qb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBlbnRpdHkgPSAvXiYjP1swLTlhLXpBLVpdKzskL1xuICBpZihzLm1hdGNoKGVudGl0eSkpXG4gIHtcbiAgICB2YXIgc3RyLCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIHRlbXAuaW5uZXJIVE1MPSBzO1xuICAgIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wPW51bGw7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW52YWxpZCBlbnRpdHkgXCIgKyBzKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLyBEZWJ1Z2dpbmcgY29uc29sZVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gam9vX2dsb2JhbF9vYmplY3QuY29uc29sZT9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRvdXQocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3RkZXJyKHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgaWYoZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgIHJldHVybiBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNzovL3Rlc3RzaGlmdDpcbiAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBjbWQgPSBzaGlmdDsgYnJlYWs7XG4gICAgICB9XG4gICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIGNtZCA9IHJlZHVjZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgIHJlcyA9IENBTExfRVJST1JfRlVOQ1RJT047XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAzOi8vU1RBQ0tTX0dST1dOXzI6XG4gICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgY2FzZSA0Oi8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBhcmc7XG4gICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgaWYgKHNwID4gYXNwKSB7XG4gICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgfVxuICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkge1xuICByZXR1cm4gYS5zbGljZSgxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYlswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8bGVuO2krKykgYltpKzFdID0gYVtpXTtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF9vZl9qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF90b19qc19hcnJheShsKXtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKDsgbCAhPT0gMDsgbCA9IGxbMl0pIHtcbiAgICBhLnB1c2gobFsxXSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdmFyIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmKCF4Lm1hdGNoKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKFxcLlthLXpBLVpfJF1bYS16QS1aXyQwLTldKikqJC8pKXtcbiAgICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFthcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSAmJiBmLmxlbmd0aCA9PSBhcml0eSkgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsYXJncyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cG9ydF92YXJcbmZ1bmN0aW9uIGNhbWxfanNfZXhwb3J0X3ZhciAoKXtcbiAgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0c1xuICBlbHNlXG4gICAgcmV0dXJuIGpvb19nbG9iYWxfb2JqZWN0O1xufVxuIiwiLy9Qcm92aWRlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfZ2V0dGltZW9mZGF5ICgpIHtcbiAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X3RpbWUgKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcih1bml4X2dldHRpbWVvZmRheSAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfZ210aW1lXG5mdW5jdGlvbiB1bml4X2dtdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBkX251bSA9IGQuZ2V0VGltZSgpO1xuICB2YXIgamFudWFyeWZpcnN0ID0gKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgdmFyIGphbiA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gIHZhciBqdWwgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuICB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heChqYW4uZ2V0VGltZXpvbmVPZmZzZXQoKSwganVsLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRTZWNvbmRzKCksIGQuZ2V0TWludXRlcygpLCBkLmdldEhvdXJzKCksXG4gICAgICAgICAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldERheSgpLCBkb3ksXG4gICAgICAgICAgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0KSB8IDAgLyogZGF5bGlnaHQgc2F2aW5ncyB0aW1lICBmaWVsZC4gKi8pXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbWt0aW1lXG4vL1JlcXVpcmVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9ta3RpbWUodG0pe1xuICB2YXIgZCA9IChuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKSkuZ2V0VGltZSgpO1xuICB2YXIgdCA9IE1hdGguZmxvb3IoZCAvIDEwMDApO1xuICB2YXIgdG0yID0gdW5peF9sb2NhbHRpbWUodCk7XG4gIHJldHVybiBCTE9DSygwLHQsdG0yKTtcbn1cblxuLy9Qcm92aWRlczogd2luX3N0YXJ0dXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2NsZWFudXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2hhbmRsZV9mZCBjb25zdFxuZnVuY3Rpb24gd2luX2hhbmRsZV9mZCh4KSB7cmV0dXJuIHg7fVxuXG4vL1Byb3ZpZGVzOiB1bml4X2lzYXR0eSBcbi8vUmVxdWlyZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiB1bml4X2lzYXR0eShmaWxlRGVzY3JpcHRvcikge1xuICBpZihmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAgdmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuICAgIHJldHVybiB0dHkuaXNhdHR5KGZpbGVEZXNjcmlwdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2ludCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcsIGNhbWxfc3RyX3JlcGVhdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfaW50KGZtdCwgaSkge1xuICBpZiAoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhmbXQpID09IFwiJWRcIikgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocykge1xuICB2YXIgaSA9IDAsIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSwgYmFzZSA9IDEwLCBzaWduID0gMTtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKSkge1xuICAgIGNhc2UgNDU6IGkrKzsgc2lnbiA9IC0xOyBicmVhaztcbiAgICBjYXNlIDQzOiBpKys7IHNpZ24gPSAxOyBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGkgKyAxIDwgbGVuICYmIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSkgPT0gNDgpXG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkgKyAxKSkge1xuICAgIGNhc2UgMTIwOiBjYXNlIDg4OiBiYXNlID0gMTY7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTE6IGNhc2UgNzk6IGJhc2UgPSAgODsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlICA5ODogY2FzZSA2NjogYmFzZSA9ICAyOyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTE3OiBjYXNlIDg1OiBpICs9IDI7IGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIFtpLCBzaWduLCBiYXNlXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9kaWdpdFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9kaWdpdChjKSB7XG4gIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpICByZXR1cm4gYyAtIDQ4O1xuICBpZiAoYyA+PSA2NSAmJiBjIDw9IDkwKSAgcmV0dXJuIGMgLSA1NTtcbiAgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMjIpIHJldHVybiBjIC0gODc7XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX3BhcnNlX2RpZ2l0LCBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2ludF9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIHIgPSBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpO1xuICB2YXIgaSA9IHJbMF0sIHNpZ24gPSByWzFdLCBiYXNlID0gclsyXTtcbiAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKTtcbiAgdmFyIHRocmVzaG9sZCA9IC0xID4+PiAwO1xuICB2YXIgYyA9IChpIDwgbGVuKT9jYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpOjA7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBkO1xuICBmb3IgKGkrKztpPGxlbjtpKyspIHtcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgcmVzID0gYmFzZSAqIHJlcyArIGQ7XG4gICAgaWYgKHJlcyA+IHRocmVzaG9sZCkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgLy8gRm9yIGJhc2UgZGlmZmVyZW50IGZyb20gMTAsIHdlIGV4cGVjdCBhbiB1bnNpZ25lZCByZXByZXNlbnRhdGlvbixcbiAgLy8gaGVuY2UgYW55IHZhbHVlIG9mICdyZXMnIChsZXNzIHRoYW4gJ3RocmVzaG9sZCcpIGlzIGFjY2VwdGFibGUuXG4gIC8vIEJ1dCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGhlIHJlc3VsdCBiYWNrIHRvIGEgc2lnbmVkIGludGVnZXIuXG4gIHJlcyA9IHNpZ24gKiByZXM7XG4gIGlmICgoYmFzZSA9PSAxMCkgJiYgKChyZXMgfCAwKSAhPSByZXMpKVxuICAgIC8qIFNpZ25lZCByZXByZXNlbnRhdGlvbiBleHBlY3RlZCwgYWxsb3cgLTJeKG5iaXRzLTEpIHRvIDJeKG5iaXRzLTEpIC0gMSAqL1xuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICByZXR1cm4gcmVzIHwgMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tdWwgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbXVsKGEsYil7XG4gIHJldHVybiBNYXRoLmltdWwoYSxiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9kaXZcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfZGl2KHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4gKHgveSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIGNhbWxfbW9kKHgseSkge1xuICBpZiAoeSA9PSAwKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICByZXR1cm4geCV5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHZhciB5ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh4KTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoW3lbN10sIHlbNl0sIHlbNV0sIHlbNF0sIHlbM10sIHlbMl0sIHlbMV0sIHlbMF1dKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSGFzaHRibFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfdW5pdl9wYXJhbSAoY291bnQsIGxpbWl0LCBvYmopIHtcbiAgdmFyIGhhc2hfYWNjdSA9IDA7XG4gIGZ1bmN0aW9uIGhhc2hfYXV4IChvYmopIHtcbiAgICBsaW1pdCAtLTtcbiAgICBpZiAoY291bnQgPCAwIHx8IGxpbWl0IDwgMCkgcmV0dXJuO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSAmJiBvYmpbMF0gPT09IChvYmpbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAob2JqWzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMl0pIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBsaW1pdCsrOyBoYXNoX2F1eChvYmopOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBvYmpbMF0pIHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9iai5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSBoYXNoX2F1eCAob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMob2JqKSkge1xuICAgICAgY291bnQgLS07XG4gICAgICBzd2l0Y2ggKG9iai50ICYgNikge1xuICAgICAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKG9iaik7XG4gICAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICAgIGZvciAodmFyIGIgPSBvYmouYywgbCA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKG9iaiksIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICAgICAgZm9yICh2YXIgYSA9IG9iai5jLCBsID0gY2FtbF9tbF9ieXRlc19sZW5ndGgob2JqKSwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcob2JqKSkge1xuICAgICAgICB2YXIganNieXRlcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob2JqKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IGpzYnl0ZXMsIGwgPSBqc2J5dGVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvciAodmFyIGIgPSBvYmosIGwgPSBvYmoubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gKG9ianwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgY291bnQgLS07XG4gICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmopIHwgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gK29iaikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGNvdW50LS07XG4gICAgICB2YXIgcCA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAob2JqKSk7XG4gICAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyBpLS0pIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIHBbaV0pIHwgMDtcbiAgICB9IGVsc2UgaWYob2JqICYmIG9iai5jYW1sX2N1c3RvbSkge1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaCA9IGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gob2JqKSB8IDA7XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIGgpIHwgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaGFzaF9taXhfaW50NjRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmxvYXQgKGgsIHYwKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2ludDY0KGgsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50NjRcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2xvMzIsIGNhbWxfaW50NjRfaGkzMlxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdikge1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9sbzMyKHYpKTtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfaGkzMih2KSk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgOClcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzIpIDw8IDE2KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTpcbiAgICB3IHw9IHMuY2hhckNvZGVBdChpKTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsIHYpIHtcbiAgc3dpdGNoICh2LnQgJiA2KSB7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAodik7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHYuYyk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMjogLyogQVJSQVkgKi9cbiAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgdi5jKTtcbiAgfVxuICByZXR1cm4gaFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLCB2KSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZyh2KSk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9mbG9hdCwgY2FtbF9oYXNoX21peF9zdHJpbmcsIGNhbWxfaGFzaF9taXhfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2hhc2ggKGNvdW50LCBsaW1pdCwgc2VlZCwgb2JqKSB7XG4gIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gIHN6ID0gbGltaXQ7XG4gIGlmIChzeiA8IDAgfHwgc3ogPiAyNTYpIHN6ID0gMjU2O1xuICBudW0gPSBjb3VudDtcbiAgaCA9IHNlZWQ7XG4gIHF1ZXVlID0gW29ial07IHJkID0gMDsgd3IgPSAxO1xuICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgdiA9IHF1ZXVlW3JkKytdO1xuICAgIGlmICh2ICYmIHYuY2FtbF9jdXN0b20pe1xuICAgICAgaWYoY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoaCA9IGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXS5oYXNoKHYpO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQgKGgsIGhoKTtcbiAgICAgICAgbnVtIC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgIHN3aXRjaCAodlswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgIG51bS0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIHF1ZXVlWy0tcmRdID0gdlsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdGFnID0gKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF07XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB0YWcpO1xuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSB2Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHdyID49IHN6KSBicmVhaztcbiAgICAgICAgICBxdWV1ZVt3cisrXSA9IHZbaV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9ieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICh2fDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdit2KzEpO1xuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgLy8gRmxvYXRcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICBudW0tLTtcbiAgICB9XG4gIH1cbiAgaCA9IGNhbWxfaGFzaF9taXhfZmluYWwoaCk7XG4gIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSl7XG4gIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoYSkpIHJldHVybiAyNTI7IC8vIHN0cmluZ190YWdcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoYSkpIHJldHVybiAxMjUyOyAvLyBvY2FtbCBzdHJpbmcgKGlmIGRpZmZlcmVudCBmcm9tIGJ5dGVzKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYVswXSA9PT0gKGFbMF0+Pj4wKSAmJiBhWzBdIDw9IDI1NSkge1xuICAgIC8vIExvb2sgbGlrZSBhbiBvY2FtbCBibG9ja1xuICAgIHZhciB0YWcgPSBhWzBdIHwgMDtcbiAgICAvLyBpZ25vcmUgZG91YmxlX2FycmF5X3RhZyBiZWNhdXNlIHdlIGNhbm5vdCBhY2N1cmF0ZWx5IHNldFxuICAgIC8vIHRoaXMgdGFnIHdoZW4gd2UgY3JlYXRlIGFuIGFycmF5IG9mIGZsb2F0LlxuICAgIHJldHVybiAodGFnID09IDI1NCk/MDp0YWdcbiAgfVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChhICYmIGEuY2FtbF9jdXN0b20pIHJldHVybiAxMjU1OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAoYSAmJiBhLmNvbXBhcmUpIHJldHVybiAxMjU2OyAvLyBsaWtlIGN1c3RvbV90YWcgKDI1NSlcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gMTI0NzsgLy8gbGlrZSBjbG9zdXJlX3RhZyAoMjQ3KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN5bWJvbFwiKSByZXR1cm4gMTI1MTtcbiAgcmV0dXJuIDEwMDE7IC8vb3V0X29mX2hlYXBfdGFnXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jdXN0b21fb3BzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSl7XG4gIHJldHVybiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dLmNvbXBhcmU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20obnVtLCBjdXN0b20sIHN3YXAsIHRvdGFsKSB7XG4gIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGN1c3RvbSk7XG4gIGlmKGNvbXApIHtcbiAgICB2YXIgeCA9IChzd2FwID4gMCk/Y29tcChjdXN0b20sbnVtLHRvdGFsKTpjb21wKG51bSxjdXN0b20sdG90YWwpO1xuICAgIGlmKHRvdGFsICYmIHggIT0geCkgcmV0dXJuIHN3YXA7IC8vIHRvdGFsICYmIG5hblxuICAgIGlmKCt4ICE9ICt4KSByZXR1cm4gK3g7IC8vIG5hblxuICAgIGlmKCh4IHwgMCkgIT0gMCkgcmV0dXJuICh4IHwgMCk7IC8vICFuYW5cbiAgfVxuICByZXR1cm4gc3dhcFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsIChjb25zdCwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnRfY29tcGFyZSwgY2FtbF9zdHJpbmdfY29tcGFyZSwgY2FtbF9ieXRlc19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbSwgY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICB2YXIgdGFnX2EgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19hID09IDI1MCkgeyBhID0gYVsxXTsgY29udGludWUgfVxuXG4gICAgICB2YXIgdGFnX2IgPSBjYW1sX2NvbXBhcmVfdmFsX3RhZyhiKTtcbiAgICAgIC8vIGZvcndhcmRfdGFnID9cbiAgICAgIGlmKHRhZ19iID09IDI1MCkgeyBiID0gYlsxXTsgY29udGludWUgfVxuXG4gICAgICAvLyB0YWdzIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmKHRhZ19hICE9PSB0YWdfYikge1xuICAgICAgICBpZih0YWdfYSA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2IgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShhLCBiLCAtMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdfYiA9PSAxMDAwKSB7XG4gICAgICAgICAgaWYodGFnX2EgPT0gMTI1NSkgeyAvL2ltbWVkaWF0ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGN1c3RvbVxuICAgICAgICAgICAgcmV0dXJuIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShiLCBhLCAxLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0YWdfYSA8IHRhZ19iKT8tMToxO1xuICAgICAgfVxuICAgICAgc3dpdGNoKHRhZ19hKXtcbiAgICAgICAgLy8gMjQ2OiBMYXp5X3RhZyBoYW5kbGVkIGJlbGxvd1xuICAgICAgY2FzZSAyNDc6IC8vIENsb3N1cmVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjQ4OiAvLyBPYmplY3RcbiAgICAgICAgdmFyIHggPSBjYW1sX2ludF9jb21wYXJlKGFbMl0sIGJbMl0pO1xuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OTogLy8gSW5maXhcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTA6IC8vIEZvcndhcmQgdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBGb3J3YXJkX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTE6IC8vQWJzdHJhY3RcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUyOiAvLyBPQ2FtbCBieXRlc1xuICAgICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICAgIHZhciB4ID0gY2FtbF9ieXRlc19jb21wYXJlKGEsIGIpO1xuICAgICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUzOiAvLyBEb3VibGVfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5X3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX2FycmF5X3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1NTogLy8gQ3VzdG9tX3RhZ1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEN1c3RvbV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI0NzogLy8gRnVuY3Rpb25cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTU6IC8vIEN1c3RvbVxuICAgICAgICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKTtcbiAgICAgICAgaWYoY29tcCAhPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYikpe1xuICAgICAgICAgIHJldHVybiAoYS5jYW1sX2N1c3RvbTxiLmNhbWxfY3VzdG9tKT8tMToxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjb21wKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGFic3RyYWN0IHZhbHVlXCIpO1xuICAgICAgICB2YXIgeCA9IGNvbXAoYSxiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTY6IC8vIGNvbXBhcmUgZnVuY3Rpb25cbiAgICAgICAgdmFyIHggPSBhLmNvbXBhcmUoYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCkgeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMDogLy8gTnVtYmVyXG4gICAgICAgIGEgPSArYTtcbiAgICAgICAgYiA9ICtiO1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAxOiAvLyBUaGUgcmVzdFxuICAgICAgICAvLyBIZXJlIHdlIGNhbiBiZSBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBKYXZhU2NyaXB0IHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAyLiBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvLyAzLiBKYXZhU2NyaXB0IG9iamVjdCB0aGFuIGNhbm5vdCBiZSBjb2VyY2VkIHRvIHByaW1pdGl2ZSB0eXBlc1xuICAgICAgICAvL1xuICAgICAgICAvLyAoMykgd2lsbCByYWlzZSBhIFtUeXBlRXJyb3JdXG4gICAgICAgIC8vICgyKSB3aWxsIGNvZXJjZSB0byBwcmltaXRpdmUgdHlwZXMgdXNpbmcgW3ZhbHVlT2ZdIG9yIFt0b1N0cmluZ11cbiAgICAgICAgLy8gKDIpIGFuZCAoMyksIGFmdGVyIGV2ZW50dWFsIGNvZXJjaW9uXG4gICAgICAgIC8vIC0gaWYgYSBhbmQgYiBhcmUgc3RyaW5ncywgYXBwbHkgbGV4aWNvZ3JhcGhpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIC0gaWYgYSBvciBiIGFyZSBub3Qgc3RyaW5ncywgY29udmVydCBhIGFuZCBiIHRvIG51bWJlclxuICAgICAgICAvLyAgIGFuZCBhcHBseSBzdGFuZGFyZCBjb21wYXJpc29uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV4Y2VwdGlvbjogYCE9YCB3aWxsIG5vdCBjb2VyY2UvY29udmVydCBpZiBib3RoIGEgYW5kIGIgYXJlIG9iamVjdHNcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MTogLy8gSmF2YVNjcmlwdCBTeW1ib2wsIG5vIG9yZGVyaW5nLlxuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjogLy8gb2NhbWwgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYSk7XG4gICAgICAgIHZhciBiID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhiKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyMDogLy8gamF2YXNjcmlwdCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gYS50b1N0cmluZygpO1xuICAgICAgICB2YXIgYiA9IGIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgICAgaWYoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDY6IC8vIExhenlfdGFnXG4gICAgICBjYXNlIDI1NDogLy8gRG91YmxlX2FycmF5XG4gICAgICBkZWZhdWx0OiAvLyBCbG9jayB3aXRoIG90aGVyIHRhZ1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiAoYS5sZW5ndGggPCBiLmxlbmd0aCk/LTE6MTtcbiAgICAgICAgaWYgKGEubGVuZ3RoID4gMSkgc3RhY2sucHVzaChhLCBiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFjay5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGkgPSBzdGFjay5wb3AoKTtcbiAgICBiID0gc3RhY2sucG9wKCk7XG4gICAgYSA9IHN0YWNrLnBvcCgpO1xuICAgIGlmIChpICsgMSA8IGEubGVuZ3RoKSBzdGFjay5wdXNoKGEsIGIsIGkgKyAxKTtcbiAgICBhID0gYVtpXTtcbiAgICBiID0gYltpXTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmUgKGEsIGIpIHsgcmV0dXJuIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRydWUpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9jb21wYXJlIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfaW50X2NvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSByZXR1cm4gKC0xKTsgaWYgKGEgPT0gYikgcmV0dXJuIDA7IHJldHVybiAxO1xufVxuLy9Qcm92aWRlczogY2FtbF9lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA9PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX25vdGVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSAhPSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVyZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVyZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID49IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJ0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcnRoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID4gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc2VxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzdGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3N0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA8IDApOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QobG9jLHNoYXBlKSB7XG4gIGZ1bmN0aW9uIHVuZGVmX21vZHVsZSAoX3gpIHtcbiAgICBjYW1sX3JhaXNlX3dpdGhfYXJnKGNhbWxfZ2xvYmFsX2RhdGEuVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUsIGxvYyk7XG4gIH1cbiAgZnVuY3Rpb24gbG9vcCAoc2hhcGUsc3RydWN0LGlkeCl7XG4gICAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgICAgc3dpdGNoKHNoYXBlKXtcbiAgICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgICAgIHN0cnVjdFtpZHhdPXtmdW46dW5kZWZfbW9kdWxlfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6Ly9sYXp5XG4gICAgICAgIHN0cnVjdFtpZHhdPVsyNDYsIHVuZGVmX21vZHVsZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDovL2Nhc2UgMjovL2NsYXNzXG4gICAgICAgIHN0cnVjdFtpZHhdPVtdO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgICBjYXNlIDA6Ly9tb2R1bGVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBbMF07XG4gICAgICAgIGZvcih2YXIgaT0xO2k8c2hhcGVbMV0ubGVuZ3RoO2krKylcbiAgICAgICAgICBsb29wKHNoYXBlWzFdW2ldLHN0cnVjdFtpZHhdLGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDE6Ly9WYWx1ZVxuICAgICAgICBzdHJ1Y3RbaWR4XSA9IHNoYXBlWzFdO1xuICAgICAgfVxuICB9XG4gIHZhciByZXMgPSBbXTtcbiAgbG9vcChzaGFwZSxyZXMsMCk7XG4gIHJldHVybiByZXNbMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlLHJlYWwseCkge1xuICBpZih0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpXG4gICAgc3dpdGNoKHNoYXBlKXtcbiAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgIGNhc2UgMTovL2xhenlcbiAgICBjYXNlIDI6Ly9jbGFzc1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX3VwZGF0ZV9kdW1teShyZWFsLHgpO1xuICAgIH1cbiAgZWxzZVxuICAgIHN3aXRjaChzaGFwZVswXSl7XG4gICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGVbMV1baV0scmVhbFtpXSx4W2ldKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy9jYXNlIDE6Ly9WYWx1ZVxuICAgIGRlZmF1bHQ6XG4gICAgfTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfdXBkYXRlX2R1bW15XG5mdW5jdGlvbiBjYW1sX3VwZGF0ZV9kdW1teSAoeCwgeSkge1xuICBpZiggdHlwZW9mIHk9PT1cImZ1bmN0aW9uXCIgKSB7IHguZnVuID0geTsgcmV0dXJuIDA7IH1cbiAgaWYoIHkuZnVuICkgeyB4LmZ1biA9IHkuZnVuOyByZXR1cm4gMDsgfVxuICB2YXIgaSA9IHkubGVuZ3RoOyB3aGlsZSAoaS0tKSB4W2ldID0geVtpXTsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2lzX2Jsb2NrIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2lzX2Jsb2NrICh4KSB7IHJldHVybiArKHggaW5zdGFuY2VvZiBBcnJheSk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfaXNfbWxfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX29ial90YWcgKHgpIHtcbiAgaWYgKCh4IGluc3RhbmNlb2YgQXJyYXkpICYmIHhbMF0gPT0gKHhbMF0gPj4+IDApKVxuICAgIHJldHVybiB4WzBdXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXMoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKCh4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8IHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gMjQ3XG4gIGVsc2UgaWYgKHggJiYgeC5jYW1sX2N1c3RvbSlcbiAgICByZXR1cm4gMjU1XG4gIGVsc2VcbiAgICByZXR1cm4gMTAwMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9zZXRfdGFnIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF90YWcgKHgsIHRhZykgeyB4WzBdID0gdGFnOyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9vYmpfYmxvY2sgY29uc3QgKGNvbnN0LGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfYmxvY2sgKHRhZywgc2l6ZSkge1xuICB2YXIgbyA9IG5ldyBBcnJheShzaXplKzEpO1xuICBvWzBdPXRhZztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSBvW2ldID0gMDtcbiAgcmV0dXJuIG87XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3dpdGhfdGFnXG5mdW5jdGlvbiBjYW1sX29ial93aXRoX3RhZyh0YWcseCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgYVswXSA9IHRhZztcbiAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfZHVwIG11dGFibGUgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfZHVwICh4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial90cnVuY2F0ZSAobXV0YWJsZSwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfb2JqX3RydW5jYXRlICh4LCBzKSB7XG4gIGlmIChzPD0wIHx8IHMgKyAxID4geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIk9iai50cnVuY2F0ZVwiKTtcbiAgaWYgKHgubGVuZ3RoICE9IHMgKyAxKSB4Lmxlbmd0aCA9IHMgKyAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfbWFrZV9mb3J3YXJkXG5mdW5jdGlvbiBjYW1sX29ial9tYWtlX2ZvcndhcmQgKGIsdikge1xuICBiWzBdPTI1MDtcbiAgYlsxXT12O1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IG51bGwpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlKGV4biwgYnQpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrICgpIHsgcmV0dXJuIFswXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPCA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfZGF0YV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5zZXRcIik7XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldCh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICByZXR1cm4gKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF09PT11bmRlZmluZWQpPzA6eFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldF9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0LGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXAsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldF9jb3B5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9jb3B5XCIpO1xuICB2YXIgeSA9IGNhbWxfd2Vha19nZXQoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY2hlY2sgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jaGVjayh4LCBpKSB7XG4gIGlmKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSE9PXVuZGVmaW5lZCAmJiB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gIT09MClcbiAgICByZXR1cm4gMTtcbiAgZWxzZVxuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlXG52YXIgY2FtbF9lcGhlX2NyZWF0ZSA9IGNhbWxfd2Vha19jcmVhdGVcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfYmxpdFxudmFyIGNhbWxfZXBoZV9ibGl0X2tleSA9IGNhbWxfd2Vha19ibGl0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0XG52YXIgY2FtbF9lcGhlX2dldF9rZXkgPSBjYW1sX3dlYWtfZ2V0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRfY29weVxudmFyIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkgPSBjYW1sX3dlYWtfZ2V0X2NvcHlcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NoZWNrXG52YXIgY2FtbF9lcGhlX2NoZWNrX2tleSA9IGNhbWxfd2Vha19jaGVja1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCBbMCwgdl0pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCAwKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfZGF0YShzcmMsIGRzdCl7XG4gIGRzdFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gc3JjW2NhbWxfZXBoZV9kYXRhX29mZnNldF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gZGF0YTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9jaGFuXG4vL1JlcXVpcmVzOiBjYW1sX21kNV9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2FycmF5LGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsbGVuKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBjaGFuX2xlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYobGVuPDApIGxlbiA9IGNoYW5fbGVuIC0gY2hhbi5vZmZzZXQ7XG4gIGlmKGNoYW4ub2Zmc2V0ICsgbGVuID4gY2hhbl9sZW4pIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG4gIHJldHVybiBjYW1sX21kNV9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKSwwLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfbWQ1X2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9zdHJpbmcocywgb2ZzLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfbWQ1X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpLG9mcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbnZhciBjYW1sX21kNV9ieXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgc3dpdGNoIChzLnQgJiA2KSB7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgdmFyIGIgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9XG4gICAgICAgICAgYi5jaGFyQ29kZUF0KGopIHwgKGIuY2hhckNvZGVBdChqKzEpIDw8IDgpIHxcbiAgICAgICAgICAoYi5jaGFyQ29kZUF0KGorMikgPDwgMTYpIHwgKGIuY2hhckNvZGVBdChqKzMpIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBiLmNoYXJDb2RlQXQoaSArIG9mcykgPDwgKDggKiAoaSAmIDMpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPSBhW2pdIHwgKGFbaisxXSA8PCA4KSB8IChhW2orMl0gPDwgMTYpIHwgKGFbaiszXSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYVtpICsgb2ZzXSA8PCAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkobWQ1KGJ1ZiwgbGVuKSk7XG4gIH1cbn0gKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBIdWdvIEhldXphcmRcbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIFNoYWNoYXIgSXR6aGFreVxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL2Jsb2IvNC4wNy9vdGhlcmxpYnMvc3RyL3N0cnN0dWJzLmNcbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2NvcS9qc2NvcS9ibG9iL3Y4LjExL2NvcS1qcy9qc19zdHViL3N0ci5qc1xuXG4vL1Byb3ZpZGVzOiByZV9tYXRjaFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZ2V0XG5cbnZhciByZV9tYXRjaCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZV93b3JkX2xldHRlcnMgPSBbXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHgwMC0weDFGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHhGRiwgMHgwMywgICAgICAgLyogMHgyMC0weDNGOiBkaWdpdHMgMC05ICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHg4NywgICAgICAgLyogMHg0MC0weDVGOiBBIHRvIFosIF8gKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDA3LCAgICAgICAvKiAweDYwLTB4N0Y6IGEgdG8geiAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4ODAtMHg5Rjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4QTAtMHhCRjogbm9uZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYsICAgICAgIC8qIDB4QzAtMHhERjogTGF0aW4tMSBhY2NlbnRlZCB1cHBlcmNhc2UgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGICAgICAgICAvKiAweEUwLTB4RkY6IExhdGluLTEgYWNjZW50ZWQgbG93ZXJjYXNlICovXG4gIF07XG5cbiAgdmFyIG9wY29kZXMgPSB7XG4gICAgQ0hBUjogMCwgQ0hBUk5PUk06IDEsIFNUUklORzogMiwgU1RSSU5HTk9STTogMywgQ0hBUkNMQVNTOiA0LFxuICAgIEJPTDogNSwgRU9MOiA2LCBXT1JEQk9VTkRBUlk6IDcsXG4gICAgQkVHR1JPVVA6IDgsIEVOREdST1VQOiA5LCBSRUZHUk9VUDogMTAsXG4gICAgQUNDRVBUOiAxMSxcbiAgICBTSU1QTEVPUFQ6IDEyLCBTSU1QTEVTVEFSOiAxMywgU0lNUExFUExVUzogMTQsXG4gICAgR09UTzogMTUsIFBVU0hCQUNLOiAxNiwgU0VUTUFSSzogMTcsXG4gICAgQ0hFQ0tQUk9HUkVTUzogMThcbiAgfTtcblxuICBmdW5jdGlvbiBpc193b3JkX2xldHRlcihjKSB7XG4gICAgcmV0dXJuIChyZV93b3JkX2xldHRlcnNbICAoYyA+PiAzKV0gPj4gKGMgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fYml0c2V0KHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9zdHJpbmdfZ2V0KHMsKGkgPj4gMykpID4+IChpICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlX21hdGNoX2ltcGwocmUsIHMsIHBvcywgcGFydGlhbCkge1xuXG4gICAgdmFyIHByb2cgICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMV0pLFxuICAgICAgICBjcG9vbCAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzJdKSxcbiAgICAgICAgbm9ybXRhYmxlICAgICA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVbM10pLFxuICAgICAgICBudW1ncm91cHMgICAgID0gcmVbNF0gfCAwLFxuICAgICAgICBudW1yZWdpc3RlcnMgID0gcmVbNV0gfCAwLFxuICAgICAgICBzdGFydGNoYXJzICAgID0gcmVbNl0gfCAwO1xuXG4gICAgdmFyIHMgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzKTtcblxuICAgIHZhciBwYyA9IDAsXG4gICAgICAgIHF1aXQgPSBmYWxzZSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgZ3JvdXBzID0gbmV3IEFycmF5KG51bWdyb3VwcyksXG4gICAgICAgIHJlX3JlZ2lzdGVyID0gbmV3IEFycmF5KG51bXJlZ2lzdGVycyk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGdyb3Vwc1tpXSA9IHtzdGFydDogLTEsIGVuZDotMX1cbiAgICB9XG4gICAgZ3JvdXBzWzBdLnN0YXJ0ID0gcG9zO1xuXG4gICAgdmFyIGJhY2t0cmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGl0ZW0udW5kbykge1xuICAgICAgICAgIGl0ZW0udW5kby5vYmpbaXRlbS51bmRvLnByb3BdID0gaXRlbS51bmRvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoaXRlbS5wb3MpIHtcbiAgICAgICAgICBwYyA9IGl0ZW0ucG9zLnBjO1xuICAgICAgICAgIHBvcyA9IGl0ZW0ucG9zLnR4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1aXQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHsgc3RhY2sucHVzaChpdGVtKTsgfTtcblxuICAgIHZhciBhY2NlcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBncm91cHNbMF0uZW5kID0gcG9zO1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSgxICsgZ3JvdXBzLmxlbmd0aCoyKTtcbiAgICAgIHJlc3VsdFswXSA9IDA7IC8vIHRhZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBnID0gZ3JvdXBzW2ldO1xuICAgICAgICBpZihnLnN0YXJ0IDwgMCB8fCBnLmVuZCA8IDApIHtcbiAgICAgICAgICBnLnN0YXJ0ID0gZy5lbmQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbMippICsgMSBdID0gZy5zdGFydDtcbiAgICAgICAgcmVzdWx0WzIqaSArIDEgKyAxIF0gPSBnLmVuZDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIHZhciBwcmVmaXhfbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZihwYXJ0aWFsKSByZXR1cm4gYWNjZXB0ICgpO1xuICAgICAgZWxzZSBiYWNrdHJhY2sgKCk7XG4gICAgfVxuXG4gICAgLyogTWFpbiBERkEgaW50ZXJwcmV0ZXIgbG9vcCAqL1xuICAgIHdoaWxlICghcXVpdCkge1xuICAgICAgdmFyIG9wID0gcHJvZ1twY10gJiAweGZmLFxuICAgICAgICAgIHNhcmcgPSBwcm9nW3BjXSA+PiA4LFxuICAgICAgICAgIHVhcmcgPSBzYXJnICYgMHhmZixcbiAgICAgICAgICBjID0gc1twb3NdLFxuICAgICAgICAgIGdyb3VwO1xuXG4gICAgICBwYysrO1xuXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUjpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoYyA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJOT1JNOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklORzpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChjID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HTk9STTpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJDTEFTUzpcbiAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IGxleF9yZWZpbGwgcmVhZF9mdW4gYXV4X2J1ZmZlciBsZXhidWYgPVxuICBsZXQgcmVhZCA9XG4gICAgcmVhZF9mdW4gYXV4X2J1ZmZlciAoQnl0ZXMubGVuZ3RoIGF1eF9idWZmZXIpIGluXG4gIGxldCBuID1cbiAgICBpZiByZWFkID4gMFxuICAgIHRoZW4gcmVhZFxuICAgIGVsc2UgKGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZTsgMCkgaW5cbiAgKCogQ3VycmVudCBzdGF0ZSBvZiB0aGUgYnVmZmVyOlxuICAgICAgICA8LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0+XG4gICAgICAgIHwgIGp1bmsgfCAgICAgIHZhbGlkIGRhdGEgICAgIHwgICBqdW5rICAgIHxcbiAgICAgICAgXiAgICAgICBeICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgXlxuICAgICAgICAwICAgIHN0YXJ0X3BvcyAgICAgICAgICAgICBidWZmZXJfZW5kICAgIEJ5dGVzLmxlbmd0aCBidWZmZXJcbiAgKilcbiAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuICsgbiA+IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlciB0aGVuIGJlZ2luXG4gICAgKCogVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG5cbiAgICAgICA8PSBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXJcbiAgICB0aGVuIGJlZ2luXG4gICAgICAoKiBCdXQgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGlmIHdlIHJlY2xhaW0gdGhlIGp1bmsgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgb2YgdGhlIGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbGV4YnVmLmxleF9idWZmZXIgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBXZSBtdXN0IGdyb3cgdGhlIGJ1ZmZlci4gIERvdWJsaW5nIGl0cyBzaXplIHdpbGwgcHJvdmlkZSBlbm91Z2hcbiAgICAgICAgIHNwYWNlIHNpbmNlIG4gPD0gU3RyaW5nLmxlbmd0aCBhdXhfYnVmZmVyIDw9IFN0cmluZy5sZW5ndGggYnVmZmVyLlxuICAgICAgICAgV2F0Y2ggb3V0IGZvciBzdHJpbmcgbGVuZ3RoIG92ZXJmbG93LCB0aG91Z2guICopXG4gICAgICBsZXQgbmV3bGVuID1cbiAgICAgICAgbWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCB3aXRoX3Bvc2l0aW9ucyBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3NcblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBsZXQgbGVuID0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3MgbGVuXG5cbmxldCBzdWJfbGV4ZW1lIGxleGJ1ZiBpMSBpMiA9XG4gIGxldCBsZW4gPSBpMi1pMSBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlblxuXG5sZXQgc3ViX2xleGVtZV9vcHQgbGV4YnVmIGkxIGkyID1cbiAgaWYgaTEgPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IGxlbiA9IGkyLWkxIGluXG4gICAgU29tZSAoQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW4pXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTm9uZVxuICBlbmRcblxubGV0IHN1Yl9sZXhlbWVfY2hhciBsZXhidWYgaSA9IEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXJfb3B0IGxleGJ1ZiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBTb21lIChCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaSlcbiAgZWxzZVxuICAgIE5vbmVcblxuXG5sZXQgbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPVxuICBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgKGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgaSlcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3AucG9zX2NudW1cbmxldCBsZXhlbWVfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19jbnVtXG5cbmxldCBsZXhlbWVfc3RhcnRfcCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3BcbmxldCBsZXhlbWVfZW5kX3AgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3BcblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxldCBsY3AgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsZXhidWYubGV4X2N1cnJfcCA8LVxuICAgICAgeyBsY3Agd2l0aFxuICAgICAgICBwb3NfbG51bSA9IGxjcC5wb3NfbG51bSArIDE7XG4gICAgICAgIHBvc19ib2wgPSBsY3AucG9zX2NudW07XG4gICAgICB9XG5cblxuXG4oKiBEaXNjYXJkIGRhdGEgbGVmdCBpbiBsZXhlciBidWZmZXIuICopXG5cbmxldCBmbHVzaF9pbnB1dCBsYiA9XG4gIGxiLmxleF9jdXJyX3BvcyA8LSAwO1xuICBsYi5sZXhfYWJzX3BvcyA8LSAwO1xuICBsZXQgbGNwID0gbGIubGV4X2N1cnJfcCBpblxuICBpZiBsY3AgIT0gZHVtbXlfcG9zIHRoZW5cbiAgICBsYi5sZXhfY3Vycl9wIDwtIHt6ZXJvX3BvcyB3aXRoIHBvc19mbmFtZSA9IGxjcC5wb3NfZm5hbWV9O1xuICBsYi5sZXhfYnVmZmVyX2xlbiA8LSAwO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAoKiBUb29scyB0byBtYW5pcHVsYXRlIHNjYW5uaW5nIHNldCBvZiBjaGFycyAoc2VlICVbLi4uXSkgKilcblxudHlwZSBtdXRhYmxlX2NoYXJfc2V0ID0gYnl0ZXNcblxuKCogQ3JlYXRlIGEgZnJlc2gsIGVtcHR5LCBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGNyZWF0ZV9jaGFyX3NldCAoKSA9IEJ5dGVzLm1ha2UgMzIgJ1xcMDAwJ1xuXG4oKiBBZGQgYSBjaGFyIGluIGEgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICBCeXRlcy5zZXQgY2hhcl9zZXQgc3RyX2luZFxuICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKEJ5dGVzLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsb3IgbWFzaykpXG5cbmxldCBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBCeXRlcy50b19zdHJpbmcgY2hhcl9zZXRcblxuKCogQ29tcHV0ZSB0aGUgY29tcGxlbWVudCBvZiBhIGNoYXIgc2V0LiAqKVxubGV0IHJldl9jaGFyX3NldCBjaGFyX3NldCA9XG4gIGxldCBjaGFyX3NldCcgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIDMxIGRvXG4gICAgQnl0ZXMuc2V0IGNoYXJfc2V0JyBpXG4gICAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IGkpIGx4b3IgMHhGRikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNoYXJfc2V0J1xuXG4oKiBSZXR1cm4gdHJ1ZSBpZiBhIGBjJyBpcyBpbiBgY2hhcl9zZXQnLiAqKVxubGV0IGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxhbmQgbWFzaykgPD4gMFxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogSWdub3JlZCBwYXJhbSBjb252ZXJzaW9uICopXG5cbigqIEdBRFQgdXNlZCB0byBhYnN0cmFjdCBhbiBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlci4gKilcbigqIFNlZSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiID0gUGFyYW1fZm9ybWF0X0VCQiA6XG4gICAgKCd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiXG5cbigqIENvbXB1dGUgYSBwYWRkaW5nIGFzc29jaWF0ZWQgdG8gYSBwYWRfb3B0aW9uIChzZWUgXCIlXzQyZFwiKS4gKilcbmxldCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wYWRkaW5nXG4gIHwgU29tZSB3aWR0aCAtPiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuXG4oKiBDb21wdXRlIGEgcHJlY2lzaW9uIGFzc29jaWF0ZWQgdG8gYSBwcmVjX29wdGlvbiAoc2VlIFwiJV8uNDJmXCIpLiAqKVxubGV0IHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQgPSBtYXRjaCBwcmVjX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wcmVjaXNpb25cbiAgfCBTb21lIG5kZWMgLT4gTGl0X3ByZWNpc2lvbiBuZGVjXG5cbigqIFR1cm4gYW4gaWdub3JlZCBwYXJhbSBpbnRvIGl0cyBlcXVpdmFsZW50IG5vdC1pZ25vcmVkIGZvcm1hdCBub2RlLiAqKVxuKCogVXNlZCBmb3IgZm9ybWF0IHByZXR0eS1wcmludGluZyBhbmQgU2NhbmYuICopXG5sZXQgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+ICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYXJhbV9mb3JtYXRfZWJiID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2hhciBmbXQpXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX2NoYXIgZm10KVxuICB8IElnbm9yZWRfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDMyIChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50MzIgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChOYXRpdmVpbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQ2NCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDY0IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfZmxvYXQgKHBhZF9vcHQsIHByZWNfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGbG9hdCAoKEZsb2F0X2ZsYWdfLCBGbG9hdF9mKSxcbiAgICAgICAgICAgICAgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Jvb2wgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEJvb2wgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChSZWFkZXIgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10KVxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlcyAqKVxuXG50eXBlICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlbiA9XG4gIHwgQWNjX29wZW5fdGFnIG9mICgnYiwgJ2MpIGFjY1xuICB8IEFjY19vcGVuX2JveCBvZiAoJ2IsICdjKSBhY2NcblxuKCogUmV2ZXJzZWQgbGlzdCBvZiBwcmludGluZyBhdG9tcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBwcmludGYgYXJndW1lbnRzLiAqKVxuYW5kICgnYiwgJ2MpIGFjYyA9XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IG9mICgnYiwgJ2MpIGFjYyAqIGZvcm1hdHRpbmdfbGl0XG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gb2YgKCdiLCAnYykgYWNjICogKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuXG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBMaXRlcmFsIHN0cmluZyAqKVxuICB8IEFjY19jaGFyX2xpdGVyYWwgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIExpdGVyYWwgY2hhciAqKVxuICB8IEFjY19kYXRhX3N0cmluZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIEdlbmVyYXRlZCBzdHJpbmcgKilcbiAgfCBBY2NfZGF0YV9jaGFyICAgICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBHZW5lcmF0ZWQgY2hhciAqKVxuICB8IEFjY19kZWxheSAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IgLT4gJ2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBEZWxheWVkIHByaW50aW5nICglYSwgJXQpICopXG4gIHwgQWNjX2ZsdXNoICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAgICAgICAgICAgICAgKCogRmx1c2ggKilcbiAgfCBBY2NfaW52YWxpZF9hcmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nXG4gICAgICAoKiBSYWlzZSBJbnZhbGlkX2FyZ3VtZW50IG1zZyAqKVxuICB8IEVuZF9vZl9hY2NcblxuKCogTGlzdCBvZiBoZXRlcm9nZW5lb3VzIHZhbHVlcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBzY2FuZiBjYWxsYmFjayBhcmd1bWVudHMuICopXG50eXBlICgnYSwgJ2IpIGhldGVyX2xpc3QgPVxuICB8IENvbnMgOiAnYyAqICgnYSwgJ2IpIGhldGVyX2xpc3QgLT4gKCdjIC0+ICdhLCAnYikgaGV0ZXJfbGlzdFxuICB8IE5pbCA6ICgnYiwgJ2IpIGhldGVyX2xpc3RcblxuKCogRXhpc3RlbnRpYWwgQmxhY2sgQm94ZXMuICopXG4oKiBVc2VkIHRvIGFic3RyYWN0IHNvbWUgZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRkaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmIgPSBQYWRkaW5nX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRwcmVjIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmIgPSBQYWRwcmVjX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICd6KSBwcmVjaXNpb24gKiAoJ3osICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZGRpbmdfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiID0gUGFkZGluZ19mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwYWRkaW5nICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wcmVjaXNpb25fZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmIgPSBQcmVjaXNpb25fZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkcHJlY19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmIgPSBQYWRwcmVjX2ZtdF9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAncCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgdGhlICdhIGFuZCAnZCBwYXJhbWV0ZXJzIG9mIGFuIGZtdC4gKilcbigqIE91dHB1dCB0eXBlIG9mIHRoZSBmb3JtYXQgcGFyc2luZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiID0gRm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2Zvcm1hdF9nZW4gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiID0gRm10X2ZtdHR5X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXQgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYiA9IEZtdHR5X2ZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10dHkgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10X2ZtdHR5X2ViYiAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgZm10dHkgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIGZvcm1hdCB0eXBlcy4gKilcbnR5cGUgZm10dHlfZWJiID0gRm10dHlfRUJCIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+IGZtdHR5X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcGFkZGluZyB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcGFkZGluZ3MuICopXG50eXBlIHBhZGRpbmdfZWJiID0gUGFkZGluZ19FQkIgOiAoJ2EsICdiKSBwYWRkaW5nIC0+IHBhZGRpbmdfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwcmVjaXNpb24gdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHByZWNpc2lvbnMuICopXG50eXBlIHByZWNpc2lvbl9lYmIgPSBQcmVjaXNpb25fRUJCIDogKCdhLCAnYikgcHJlY2lzaW9uIC0+IHByZWNpc2lvbl9lYmJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb25zdGFudHMgKilcblxuKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIGZsb2F0IHByaW50aW5nLiAqKVxubGV0IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252ID1cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyB8IEZsb2F0X2ggfCBGbG9hdF9IXG4gIHwgRmxvYXRfQ0YgLT4gLTZcbiAgKCogRm9yICVoICVIIGFuZCAlI0YgZm9ybWF0cywgYSBuZWdhdGl2ZSBwcmVjaXNpb24gbWVhbnMgXCJhcyBtYW55IGRpZ2l0cyBhc1xuICAgICBuZWNlc3NhcnlcIi4gIEZvciB0aGUgb3RoZXIgRlAgZm9ybWF0cywgd2UgdGFrZSB0aGUgYWJzb2x1dGUgdmFsdWVcbiAgICAgb2YgdGhlIHByZWNpc2lvbiwgaGVuY2UgNiBkaWdpdHMgYnkgZGVmYXVsdC4gKilcbiAgfCBGbG9hdF9GIC0+IDEyXG4gICgqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBPQ2FtbCBmbG9hdCBwcmludGluZyAoJUYpLiAqKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEV4dGVybmFscyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQ6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDMyOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfbmF0aXZlaW50OiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ2NDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuZXh0ZXJuYWwgaGV4c3RyaW5nX29mX2Zsb2F0OiBmbG9hdCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0XCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICgqIFRvb2xzIHRvIHByZXR0eS1wcmludCBmb3JtYXRzICopXG5cbigqIFR5cGUgb2YgZXh0ZW5zaWJsZSBjaGFyYWN0ZXIgYnVmZmVycy4gKilcbnR5cGUgYnVmZmVyID0ge1xuICBtdXRhYmxlIGluZCA6IGludDtcbiAgbXV0YWJsZSBieXRlcyA6IGJ5dGVzO1xufVxuXG4oKiBDcmVhdGUgYSBmcmVzaCBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NyZWF0ZSBpbml0X3NpemUgPSB7IGluZCA9IDA7IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGluaXRfc2l6ZSB9XG5cbigqIENoZWNrIHNpemUgb2YgdGhlIGJ1ZmZlciBhbmQgZ3JvdyBpdCBpZiBuZWVkZWQuICopXG5sZXQgYnVmZmVyX2NoZWNrX3NpemUgYnVmIG92ZXJoZWFkID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYuYnl0ZXMgaW5cbiAgbGV0IG1pbl9sZW4gPSBidWYuaW5kICsgb3ZlcmhlYWQgaW5cbiAgaWYgbWluX2xlbiA+IGxlbiB0aGVuIChcbiAgICBsZXQgbmV3X2xlbiA9IG1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIHwgSW50X0NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpXG4gIHwgSW50X0NpIC0+ICdpJyB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vXG4gIHwgSW50X0NvIC0+ICdvJyB8IEludF91IHwgSW50X0N1IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxuKCogYGNGJyB3aWxsIGJlICdGJyBmb3IgZGlzcGxheWluZyBmb3JtYXQgYW5kICdnJyB0byBjYWxsIGxpYmMgcHJpbnRmICopXG5sZXQgY2hhcl9vZl9mY29udiA/KGNGPSdGJykgZmNvbnYgPSBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgLT4gJ2YnIHwgRmxvYXRfZSAtPiAnZSdcbiAgfCBGbG9hdF9FIC0+ICdFJyB8IEZsb2F0X2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyAtPiAnRycgfCBGbG9hdF9GIC0+IGNGXG4gIHwgRmxvYXRfaCAtPiAnaCcgfCBGbG9hdF9IIC0+ICdIJ1xuICB8IEZsb2F0X0NGIC0+ICdGJ1xuXG5cbigqIENvbnZlcnQgYSBzY2FubmluZyBjb3VudGVyIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIgPSBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgIC0+ICdsJ1xuICB8IENoYXJfY291bnRlciAgLT4gJ24nXG4gIHwgVG9rZW5fY291bnRlciAtPiAnTidcblxuKCoqKilcblxuKCogUHJpbnQgYSBjaGFyX3NldCBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBPQ2FtbCBmb3JtYXQgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQgPVxuICBsZXQgcmVjIHByaW50X3N0YXJ0IHNldCA9XG4gICAgbGV0IGlzX2Fsb25lIGMgPVxuICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIgPSBDaGFyLihjaHIgKGNvZGUgYyAtIDEpLCBjaHIgKGNvZGUgYyArIDEpKSBpblxuICAgICAgaXNfaW5fY2hhcl9zZXQgc2V0IGNcbiAgICAgICYmIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IGJlZm9yZSAmJiBpc19pbl9jaGFyX3NldCBzZXQgYWZ0ZXIpIGluXG4gICAgaWYgaXNfYWxvbmUgJ10nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSc7XG4gICAgcHJpbnRfb3V0IHNldCAxO1xuICAgIGlmIGlzX2Fsb25lICctJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nO1xuICBhbmQgcHJpbnRfb3V0IHNldCBpID1cbiAgICBpZiBpIDwgMjU2IHRoZW5cbiAgICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlbiBwcmludF9maXJzdCBzZXQgaVxuICAgICAgZWxzZSBwcmludF9vdXQgc2V0IChpICsgMSlcbiAgYW5kIHByaW50X2ZpcnN0IHNldCBpID1cbiAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICdcXDI1NScgLT4gcHJpbnRfY2hhciBidWYgMjU1O1xuICAgIHwgJ10nIHwgJy0nIC0+IHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICB8IF8gLT4gcHJpbnRfc2Vjb25kIHNldCAoaSArIDEpO1xuICBhbmQgcHJpbnRfc2Vjb25kIHNldCBpID1cbiAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW5cbiAgICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgICAgfCAnXFwyNTUnIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NDtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU1O1xuICAgICAgfCAnXScgfCAnLScgd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICAgIHwgXyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDIpO1xuICAgICAgfCBfIC0+XG4gICAgICAgIHByaW50X2luIHNldCAoaSAtIDEpIChpICsgMik7XG4gICAgZWxzZSAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIClcbiAgYW5kIHByaW50X2luIHNldCBpIGogPVxuICAgIGlmIGogPSAyNTYgfHwgbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGopKSB0aGVuIChcbiAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaW50X29mX2NoYXIgJy0nKTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChqIC0gMSk7XG4gICAgICBpZiBqIDwgMjU2IHRoZW4gcHJpbnRfb3V0IHNldCAoaiArIDEpO1xuICAgICkgZWxzZVxuICAgICAgcHJpbnRfaW4gc2V0IGkgKGogKyAxKTtcbiAgYW5kIHByaW50X2NoYXIgYnVmIGkgPSBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICB8ICclJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgfCAnQCcgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0AnO1xuICAgIHwgYyAgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgaW5cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnWyc7XG4gIHByaW50X3N0YXJ0IChcbiAgICBpZiBpc19pbl9jaGFyX3NldCBjaGFyX3NldCAnXFwwMDAnXG4gICAgdGhlbiAoIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ14nOyByZXZfY2hhcl9zZXQgY2hhcl9zZXQgKVxuICAgIGVsc2UgY2hhcl9zZXRcbiAgKTtcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXSdcblxuKCoqKilcblxuKCogUHJpbnQgYSBwYWR0eSBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eSA9IG1hdGNoIHBhZHR5IHdpdGhcbiAgfCBMZWZ0ICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICctJ1xuICB8IFJpZ2h0IC0+ICgpXG4gIHwgWmVyb3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnMCdcblxuKCogUHJpbnQgdGhlICdfJyBvZiBhbiBpZ25vcmVkIGZsYWcgaWYgbmVlZGVkLiAqKVxubGV0IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnID1cbiAgaWYgaWduX2ZsYWcgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICdfJ1xuXG4oKioqKVxuXG5sZXQgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB3aWR0aCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgd2lkdGgpXG5cbigqKiopXG5cbigqIFByaW50IHBhZGRpbmcgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWRkaW5nIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHBhZGRpbmcgLT4gdW5pdCA9XG5mdW4gYnVmIHBhZCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT4gKClcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIG4pIC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyonXG5cbigqIFByaW50IHByZWNpc2lvbiBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3ByZWNpc2lvbiA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwcmVjaXNpb24gLT4gdW5pdCA9XG4gIGZ1biBidWYgcHJlYyAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gLT4gKClcbiAgfCBMaXRfcHJlY2lzaW9uIG4gLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgbik7XG4gIHwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIi4qXCJcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIG9yICcjJyBhc3NvY2lhdGVkIHRvIGFuIGludCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfcGQgfCBJbnRfcGkgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBJbnRfc2QgfCBJbnRfc2kgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBJbnRfQ3ggfCBJbnRfQ1ggfCBJbnRfQ28gfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgSW50X2QgfCBJbnRfaSB8IEludF94IHwgSW50X1ggfCBJbnRfbyB8IEludF91IC0+ICgpXG5cbigqIFByaW50IGFuIGNvbXBsZXRlIGludCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUzLipkXCIpLiAqKVxubGV0IGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyBjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJywgJyAnIGFuZC9vciAnIycgYXNzb2NpYXRlZCB0byBhIGZsb2F0IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252ID1cbiAgYmVnaW4gbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgfCBGbG9hdF9mbGFnX3AgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKydcbiAgfCBGbG9hdF9mbGFnX3MgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBGbG9hdF9mbGFnXyAtPiAoKSBlbmQ7XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfQ0YgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfR1xuICB8IEZsb2F0X0YgfCBGbG9hdF9oIHwgRmxvYXRfSCAtPiAoKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZsb2F0IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJSsqLjNmXCIpLiAqKVxubGV0IGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfZmNvbnYgZmNvbnYpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgRm9ybWF0dGluZ19saXQuICopXG4oKiBVc2VkIGJ5IFByaW50ZiBhbmQgU2NhbmYgd2hlcmUgZm9ybWF0dGluZyBpcyBub3QgaW50ZXJwcmV0ZWQuICopXG5sZXQgc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0ID0gbWF0Y2ggZm9ybWF0dGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgIC0+IFwiQF1cIlxuICB8IENsb3NlX3RhZyAgICAgICAgICAgIC0+IFwiQH1cIlxuICB8IEJyZWFrIChzdHIsIF8sIF8pICAgIC0+IHN0clxuICB8IEZGbHVzaCAgICAgICAgICAgICAgIC0+IFwiQD9cIlxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgIC0+IFwiQFxcblwiXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgLT4gXCJALlwiXG4gIHwgTWFnaWNfc2l6ZSAoc3RyLCBfKSAgLT4gc3RyXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgLT4gXCJAQFwiXG4gIHwgRXNjYXBlZF9wZXJjZW50ICAgICAgLT4gXCJAJVwiXG4gIHwgU2Nhbl9pbmRpYyBjIC0+IFwiQFwiIF4gKFN0cmluZy5tYWtlIDEgYylcblxuKCoqKilcblxuKCogUHJpbnQgYSBsaXRlcmFsIGNoYXIgaW4gYSBidWZmZXIsIGVzY2FwZSAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNociA9IG1hdGNoIGNociB3aXRoXG4gIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUlXCJcbiAgfCBfIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgY2hyXG5cbigqIFByaW50IGEgbGl0ZXJhbCBzdHJpbmcgaW4gYSBidWZmZXIsIGVzY2FwZSBhbGwgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0ciA9XG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHN0ciAtIDEgZG9cbiAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBzdHIuW2ldXG4gIGRvbmVcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHByZXR0eS1wcmludGluZyAqKVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCB0eXBlIChhbiBmbXR0eSkgaW4gYSBidWZmZXIuICopXG5sZXQgcmVjIGJwcmludF9mbXR0eSA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAgIGJ1ZmZlciAtPiAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCkgZm10dHlfcmVsIC0+IHVuaXQgPVxuZnVuIGJ1ZiBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlc1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludF90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVpXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbmlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDY0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVMaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWZcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBCb29sX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlQlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFscGhhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVhXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXRcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlP1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFJlYWRlcl90eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVyXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJV9yXCI7XG4gICAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV7XCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV9XCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eSwgXywgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKFwiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlKVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBFbmRfb2ZfZm10dHkgLT4gKClcblxuKCoqKilcblxubGV0IHJlYyBpbnRfb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSBhIGIgYyAuXG4gIChhLCBiLCBjKSBjdXN0b21fYXJpdHkgLT4gaW50ID1cbiAgZnVuY3Rpb25cbiAgfCBDdXN0b21femVybyAtPiAwXG4gIHwgQ3VzdG9tX3N1Y2MgeCAtPiAxICsgaW50X29mX2N1c3RvbV9hcml0eSB4XG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9mbXQgYnVmIGZtdCA9XG4gIGxldCByZWMgZm10aXRlciA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBib29sIC0+IHVuaXQgPVxuICBmdW4gZm10IGlnbl9mbGFnIC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1MnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ24nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ0wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdjJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdCJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2EnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICd0JzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgIGZvciBfaSA9IDEgdG8gaW50X29mX2N1c3RvbV9hcml0eSBhcml0eSBkb1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJz8nO1xuICAgICAgZG9uZTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFJlYWRlciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdyJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSFcIjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3snO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ30nO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICcoJztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICcpJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiB3aWR0aF9vcHQ7IGJwcmludF9jaGFyX3NldCBidWYgY2hhcl9zZXQ7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9jb3VudGVyIGNvdW50ZXIpO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBcIjBjXCI7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgbGV0IFBhcmFtX2Zvcm1hdF9FQkIgZm10JyA9IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdCBpblxuICAgICAgZm10aXRlciBmbXQnIHRydWU7XG5cbiAgICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQpO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpIC0+XG4gICAgICBiZWdpbiBtYXRjaCBmbXRpbmdfZ2VuIHdpdGhcbiAgICAgIHwgT3Blbl90YWcgKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQHtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgfCBPcGVuX2JveCAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAW1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICBlbmQ7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IEVuZF9vZl9mb3JtYXQgLT4gKClcblxuICBpbiBmbXRpdGVyIGZtdCBmYWxzZVxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHRvIHN0cmluZy4gKilcbmxldCBzdHJpbmdfb2ZfZm10IGZtdCA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXQgYnVmIGZtdDtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlIGV4dHJhY3Rpb24gKilcblxudHlwZSAoXywgXykgZXEgPSBSZWZsIDogKCdhLCAnYSkgZXFcblxuKCogSW52YXJpYW50OiB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBpZGVudGl0eSBvbiB2YWx1ZXMuXG5cbiAgIEluIHBhcnRpY3VsYXIsIGlmICh0eTEsIHR5MikgaGF2ZSBlcXVhbCB2YWx1ZXMsIHRoZW5cbiAgICh0cmFucyAoc3ltbSB0eTEpIHR5MikgcmVzcGVjdHMgdGhlICd0cmFucycgcHJlY29uZGl0aW9uLiAqKVxubGV0IHJlYyBzeW1tIDogdHlwZSBhMSBiMSBjMSBkMSBlMSBmMSBhMiBiMiBjMiBkMiBlMiBmMiAuXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdHR5X3JlbFxuPSBmdW5jdGlvblxuICB8IENoYXJfdHkgcmVzdCAtPiBDaGFyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT4gSW50X3R5IChzeW1tIHJlc3QpXG4gIHwgSW50MzJfdHkgcmVzdCAtPiBJbnQzMl90eSAoc3ltbSByZXN0KVxuICB8IEludDY0X3R5IHJlc3QgLT4gSW50NjRfdHkgKHN5bW0gcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPiBOYXRpdmVpbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBGbG9hdF90eSByZXN0IC0+IEZsb2F0X3R5IChzeW1tIHJlc3QpXG4gIHwgQm9vbF90eSByZXN0IC0+IEJvb2xfdHkgKHN5bW0gcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPiBTdHJpbmdfdHkgKHN5bW0gcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+IFRoZXRhX3R5IChzeW1tIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPiBBbHBoYV90eSAoc3ltbSByZXN0KVxuICB8IEFueV90eSByZXN0IC0+IEFueV90eSAoc3ltbSByZXN0KVxuICB8IFJlYWRlcl90eSByZXN0IC0+IFJlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT4gSWdub3JlZF9yZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgc3ltbSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIsIHR5MSwgc3ltbSByZXN0KVxuICB8IEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcblxubGV0IHJlYyBmbXR0eV9yZWxfZGV0IDogdHlwZSBhMSBiIGMgZDEgZTEgZjEgYTIgZDIgZTIgZjIgLlxuICAoYTEsIGIsIGMsIGQxLCBlMSwgZjEsXG4gICBhMiwgYiwgYywgZDIsIGUyLCBmMikgZm10dHlfcmVsIC0+XG4gICAgKChmMSwgZjIpIGVxIC0+IChhMSwgYTIpIGVxKVxuICAqICgoYTEsIGEyKSBlcSAtPiAoZjEsIGYyKSBlcSlcbiAgKiAoKGUxLCBlMikgZXEgLT4gKGQxLCBkMikgZXEpXG4gICogKChkMSwgZDIpIGVxIC0+IChlMSwgZTIpIGVxKVxuPSBmdW5jdGlvblxuICB8IEVuZF9vZl9mbXR0eSAtPlxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKVxuICB8IENoYXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQzMl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDY0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG5cbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQW55X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBGb3JtYXRfYXJnX3R5IChfdHksIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBsZXQgYWcsIGdhLCBkaiwgamQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBsZXQgUmVmbCA9IGFnIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZ2EgUmVmbCBpbiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBsZXQgUmVmbCA9IGRqIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gamQgUmVmbCBpbiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcblxuKCogUHJlY29uZGl0aW9uOiB3ZSBhc3N1bWUgdGhhdCB0aGUgdHdvIGZtdHR5X3JlbCBhcmd1bWVudHMgaGF2ZSBlcXVhbFxuICAgdmFsdWVzIChhdCBwb3NzaWJseSBkaXN0aW5jdCB0eXBlcyk7IHRoaXMgaW52YXJpYW50IGNvbWVzIGZyb20gdGhlIHdheVxuICAgZm10dHlfcmVsIHdpdG5lc3NlcyBhcmUgcHJvZHVjZWQgYnkgdGhlIHR5cGUtY2hlY2tlclxuXG4gICBUaGUgY29kZSBiZWxvdyB1c2VzIChhc3NlcnQgZmFsc2UpIHdoZW4gdGhpcyBhc3N1bXB0aW9uIGlzIGJyb2tlbi4gVGhlXG4gICBjb2RlIHBhdHRlcm4gaXMgdGhlIGZvbGxvd2luZzpcblxuICAgICB8IEZvbyB4LCBGb28geSAtPlxuICAgICAgICgqIGNhc2Ugd2hlcmUgaW5kZWVkIGJvdGggdmFsdWVzXG4gICAgICAgICAgc3RhcnQgd2l0aCBjb25zdHJ1Y3RvciBGb28gKilcbiAgICAgfCBGb28gXywgX1xuICAgICB8IF8sIEZvbyBfIC0+XG4gICAgICAgKCogZGlmZmVyZW50IGhlYWQgY29uc3RydWN0b3JzOiBicm9rZW4gcHJlY29uZGl0aW9uICopXG4gICAgICAgYXNzZXJ0IGZhbHNlXG4qKVxuYW5kIHRyYW5zIDogdHlwZVxuICBhMSBiMSBjMSBkMSBlMSBmMVxuICBhMiBiMiBjMiBkMiBlMiBmMlxuICBhMyBiMyBjMyBkMyBlMyBmM1xuLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbi0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuPSBmdW4gdHkxIHR5MiAtPiBtYXRjaCB0eTEsIHR5MiB3aXRoXG4gIHwgQ2hhcl90eSByZXN0MSwgQ2hhcl90eSByZXN0MiAtPiBDaGFyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBTdHJpbmdfdHkgcmVzdDEsIFN0cmluZ190eSByZXN0MiAtPiBTdHJpbmdfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEJvb2xfdHkgcmVzdDEsIEJvb2xfdHkgcmVzdDIgLT4gQm9vbF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50X3R5IHJlc3QxLCBJbnRfdHkgcmVzdDIgLT4gSW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQzMl90eSByZXN0MSwgSW50MzJfdHkgcmVzdDIgLT4gSW50MzJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDY0X3R5IHJlc3QxLCBJbnQ2NF90eSByZXN0MiAtPiBJbnQ2NF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QxLCBOYXRpdmVpbnRfdHkgcmVzdDIgLT4gTmF0aXZlaW50X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBGbG9hdF90eSByZXN0MSwgRmxvYXRfdHkgcmVzdDIgLT4gRmxvYXRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuXG4gIHwgQWxwaGFfdHkgcmVzdDEsIEFscGhhX3R5IHJlc3QyIC0+IEFscGhhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbHBoYV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFscGhhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBUaGV0YV90eSByZXN0MSwgVGhldGFfdHkgcmVzdDIgLT4gVGhldGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFRoZXRhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgVGhldGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEFueV90eSByZXN0MSwgQW55X3R5IHJlc3QyIC0+IEFueV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQW55X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQW55X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBSZWFkZXJfdHkgcmVzdDEsIFJlYWRlcl90eSByZXN0MiAtPiBSZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFJlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFJlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDEsIElnbm9yZWRfcmVhZGVyX3R5IHJlc3QyIC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgSWdub3JlZF9yZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9hcmdfdHkgKHR5MSwgcmVzdDEpLCBGb3JtYXRfYXJnX3R5ICh0eTIsIHJlc3QyKSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHRyYW5zIHR5MSB0eTIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9hcmdfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfYXJnX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MTIsIHJlc3QxKSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MjEsIHR5MjIsIHJlc3QyKSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MTIpIHR5MjEgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkyMiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X3N1YnN0X3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBFbmRfb2ZfZm10dHksIEVuZF9vZl9mbXR0eSAtPiBFbmRfb2ZfZm10dHlcbiAgfCBFbmRfb2ZfZm10dHksIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRW5kX29mX2ZtdHR5IC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcmVjIGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEV4dHJhY3QgdGhlIHR5cGUgcmVwcmVzZW50YXRpb24gKGFuIGZtdHR5KSBvZiBhIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9mbXQgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG5cbiAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDMyX3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChOYXRpdmVpbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50NjRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoRmxvYXRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG5cbiAgfCBDaGFyIHJlc3QgICAgICAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBCb29sIChwYWQsIHJlc3QpICAgICAgICAgICAtPlxuICAgICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKEJvb2xfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAtPiBBbHBoYV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gVGhldGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpICAgIC0+IGZtdHR5X29mX2N1c3RvbSBhcml0eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgUmVhZGVyIHJlc3QgICAgICAgICAgICAgICAgLT4gUmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHksIHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT4gU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPiBJbnRfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgIC0+IGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0XG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgIC0+XG4gICAgY29uY2F0X2ZtdHR5IChmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAtPiBFbmRfb2ZfZm10dHlcblxuYW5kIGZtdHR5X29mX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgKHksIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBhcml0eSBmbXR0eSAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gZm10dHlcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPiBBbnlfdHkgKGZtdHR5X29mX2N1c3RvbSBhcml0eSBmbXR0eSlcblxuKCogRXh0cmFjdCB0aGUgZm10dHkgb2YgYW4gaWdub3JlZCBwYXJhbWV0ZXIgZm9sbG93ZWQgYnkgdGhlIHJlc3Qgb2ZcbiAgIHRoZSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBjb25jYXRfZm10dHkgZm10dHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBJZ25vcmVkX3JlYWRlcl90eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHBhZGRpbmcgaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqc1wiKS4gKilcbmFuZCBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3BhZGRpbmcgXyAtPiBmbXR0eVxuICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBJbnRfdHkgZm10dHlcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHByZWNpc2lvbiBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKS4qKVxuYW5kIGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgfCBOb19wcmVjaXNpb24gICAgLT4gZm10dHlcbiAgICB8IExpdF9wcmVjaXNpb24gXyAtPiBmbXR0eVxuICAgIHwgQXJnX3ByZWNpc2lvbiAgIC0+IEludF90eSBmbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBpbmcgKilcblxuKCogRXhjZXB0aW9uIHJhaXNlZCB3aGVuIGEgZm9ybWF0IGRvZXMgbm90IG1hdGNoIGEgZ2l2ZW4gZm9ybWF0IHR5cGUuICopXG5leGNlcHRpb24gVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgcGFkZGluZy4gKilcbigqIFRha2UgYW4gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIHRoZSBpbnRlZ2VyIHNob3VsZCBiZSBrZXB0IGFzIGFyZ3VtZW50LiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRkaW5nIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZGRpbmdfZm10dHlfZWJiID1cbmZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkLCBmbXR0eSB3aXRoXG4gIHwgTm9fcGFkZGluZywgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTm9fcGFkZGluZywgZm10dHkpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTGl0X3BhZGRpbmcgKHBhZHR5LHcpLGZtdHR5KVxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBJbnRfdHkgcmVzdCAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoQXJnX3BhZGRpbmcgcGFkdHkscmVzdClcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogQ29udmVydCBhICh1cGFkZGluZywgdXByZWNpc2lvbikgdG8gYSAocGFkZGluZywgcHJlY2lzaW9uKS4gKilcbigqIFRha2Ugb25lIG9yIHR3byBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgbmVlZGVkLiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRwcmVjIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgeiAuXG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6KSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZHByZWNfZm10dHlfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjLCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgfCBOb19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTm9fcHJlY2lzaW9uLCByZXN0KVxuICB8IExpdF9wcmVjaXNpb24gcCwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBMaXRfcHJlY2lzaW9uIHAsIHJlc3QpXG4gIHwgQXJnX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgSW50X3R5IHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgQXJnX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBfLCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIElmIHR5cGluZyBzdWNjZWVkLCBnZW5lcmF0ZSBhIGNvcHkgb2YgdGhlIGZvcm1hdCB3aXRoIHRoZSBzYW1lXG4gICAgdHlwZSBwYXJhbWV0ZXJzIGFzIHRoZSBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHJlYyB0eXBlX2Zvcm1hdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSB3aXRoXG4gIHwgRm10X2ZtdHR5X0VCQiAoZm10JywgRW5kX29mX2ZtdHR5KSAtPiBmbXQnXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdF9nZW4gOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCBmbXQsIGZtdHR5IHdpdGhcbiAgfCBDaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhciBmbXQnLCBmbXR0eScpXG4gIHwgQ2FtbF9jaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9jaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBTdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQzMl90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50NjRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBGbG9hdF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQm9vbCAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgQm9vbF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQm9vbCAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsdXNoIGZtdF9yZXN0LCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZsdXNoIGZtdCcsIGZtdHR5JylcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXQnKSwgZm10dHknKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhcl9saXRlcmFsIChjaHIsIGZtdCcpLCBmbXR0eScpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWJfZm10dHkgPD4gRm10dHlfRUJCIHN1Yl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHknLCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHkxLCBfc3ViX2ZtdHR5MiwgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eTEpIHRoZW5cbiAgICAgIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPVxuICAgICAgdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IChlcmFzZV9yZWwgZm10dHlfcmVzdClcbiAgICBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5MSwgZm10JyksIGZtdHR5JylcbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEFscGhhIGZtdF9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEFscGhhIGZtdCcsIGZtdHR5JylcbiAgfCBUaGV0YSBmbXRfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChUaGV0YSBmbXQnLCBmbXR0eScpXG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmdfZ2VuLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2Zvcm1hdHRpbmdfZ2VuIGZvcm1hdHRpbmdfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3RcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIGZtdF9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChSZWFkZXIgZm10JywgZm10dHknKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdF9yZXN0KSwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10JyksIGZtdHR5JylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCksIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCcpLCBmbXR0eScpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbSBpZ24gcmVzdCBmbXR0eV9yZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0IC0+IEZtdF9mbXR0eV9FQkIgKEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QpXG5cbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGExIGEzIGIxIGIzIGMxIGMzIGQxIGQzIGUxIGUyIGUzIGYxIGYyIGYzIC5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoZjEsIGIxLCBjMSwgZTEsIGUyLCBmMikgZm10IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIGZtdDAgZm10dHkwIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuXG4oKiBUeXBlIGFuIElnbm9yZWRfcGFyYW0gbm9kZSBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtIDogdHlwZSBwIHEgeCB5IHogdCB1IHYgYSBiIGMgZCBlIGYgLlxuICAgICh4LCB5LCB6LCB0LCBxLCBwKSBpZ25vcmVkIC0+XG4gICAgKHAsIHksIHosIHEsIHUsIHYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXRfZm10dHlfZWJiID1cbmZ1biBpZ24gZm10IGZtdHR5IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQgXyAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQzMiBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgXyAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQ2NCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mbG9hdCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSAoSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpKSBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHknLCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHkgZm10IGZtdHR5IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdHR5JylcbiAgfCBJZ25vcmVkX3JlYWRlciAtPiAoXG4gICAgbWF0Y2ggZm10dHkgd2l0aFxuICAgIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXQnKSwgZm10dHknKVxuICAgIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcblxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgOiB0eXBlIGExIGEyIGIxIGIyIGMxIGMyIGQxIGQyIGUxIGUyIGYxIGYyIC5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGQyLCBhMikgaWdub3JlZCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXQgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHkgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gaWduIGZtdCBmbXR0eSAtPlxuICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgaW5cbiAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoaWduLCBmbXQnKSwgZm10dHknKVxuXG4oKiBUeXBpbmcgb2YgdGhlIGNvbXBsZXggY2FzZTogXCIlXyguLi4lKVwiLiAqKVxuYW5kIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIDogdHlwZSB3IHggeSB6IHAgcyB0IHUgYSBiIGMgZCBlIGYgLlxuICAgICh3LCB4LCB5LCB6LCBzLCBwKSBmbXR0eSAtPlxuICAgIChwLCB4LCB5LCBzLCB0LCB1KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5X2ZtdF9lYmIgPVxuZnVuIHN1Yl9mbXR0eSBmbXQgZm10dHkgLT4gbWF0Y2ggc3ViX2ZtdHR5LCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSBzdWJfZm10dHlfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QsIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludF90eSBzdWJfZm10dHlfcmVzdCwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDMyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQ2NF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEZsb2F0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBCb29sX3R5IHN1Yl9mbXR0eV9yZXN0LCBCb29sX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChBbHBoYV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5LCBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1YjJfZm10dHkgPD4gRm10dHlfRUJCIHN1YjJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBzdWJfZm10dHlfcmVzdCcpLCBmbXQnKVxuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eSwgIHN1YjJfZm10dHksICBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgKCogVE9ETyBkZWZpbmUgRm10dHlfcmVsX0VCQiB0byByZW1vdmUgdGhvc2UgZXJhc2VfcmVsICopXG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgc3ViX2ZtdHR5JyA9IHRyYW5zIChzeW1tIHN1YjFfZm10dHknKSBzdWIyX2ZtdHR5JyBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHN1Yl9mbXR0eScgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiAoZXJhc2VfcmVsIHN1Yl9mbXR0eV9yZXN0KSBmbXQgZm10dHlfcmVzdFxuICAgIGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1tIHN1Yl9mbXR0eV9yZXN0JyksXG4gICAgICAgICAgICAgICAgICAgZm10JylcbiAgfCBFbmRfb2ZfZm10dHksIGZtdHR5IC0+XG4gICAgRm10dHlfZm10X0VCQiAoRW5kX29mX2ZtdHR5LCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGByZWNhc3RgIGlzIGEgYml0IGRpc2FwcG9pbnRpbmcuIFRoZVxuICAgaW52YXJpYW50IHByb3ZpZGVkIGJ5IHRoZSB0eXBlIGFyZSB2ZXJ5IHN0cm9uZzogdGhlIGlucHV0IGZvcm1hdCdzXG4gICB0eXBlIGlzIGluIHJlbGF0aW9uIHRvIHRoZSBvdXRwdXQgdHlwZSdzIGFzIHdpdG5lc3NlZCBieSB0aGVcbiAgIGZtdHR5X3JlbCBhcmd1bWVudC4gT25lIHdvdWxkIGF0IGZpcnN0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICB0b3RhbCwgYW5kIGltcGxlbWVudGFibGUgYnkgZXhoYXVzdGl2ZSBwYXR0ZXJuIG1hdGNoaW5nLiBJbnN0ZWFkLFxuICAgd2UgcmV1c2UgdGhlIGhpZ2hseSBwYXJ0aWFsIGFuZCBtdWNoIGxlc3Mgd2VsbC1kZWZpbmVkIGZ1bmN0aW9uXG4gICBgdHlwZV9mb3JtYXRgIHRoYXQgaGFzIGxvc3QgYWxsIGtub3dsZWRnZSBvZiB0aGUgY29ycmVzcG9uZGVuY2VcbiAgIGJldHdlZW4gdGhlIGFyZ3VtZW50J3MgdHlwZXMuXG5cbiAgIEJlc2lkZXMgdGhlIGZhY3QgdGhhdCB0aGlzIGZ1bmN0aW9uIHJldXNlcyBhIGxvdCBvZiB0aGVcbiAgIGB0eXBlX2Zvcm1hdGAgbG9naWMgKGVnLjogc2VlaW5nIEludF90eSBpbiB0aGUgZm10dHkgcGFyYW1ldGVyIGRvZXNcbiAgIG5vdCBsZXQgeW91IG1hdGNoIG9uIEludCBvbmx5LCBhcyB5b3UgbWF5IGluIGZhY3QgaGF2ZSBGbG9hdFxuICAgKEFyZ19wYWRkaW5nLCAuLi4pIChcIiUuKmRcIikgYmVnaW5uaW5nIHdpdGggYW4gSW50X3R5KSwgaXQgaXMgYWxzb1xuICAgYSBwYXJ0aWFsIGZ1bmN0aW9uLCBiZWNhdXNlIHRoZSB0eXBpbmcgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgaXNcbiAgIG5vdCBxdWl0ZSBlbm91Z2ggdG8gcmVjb25zdHJ1Y3QgaXQgdW5hbWJpZ3VvdXNseS4gRm9yIGV4YW1wbGUsIHRoZVxuICAgZm9ybWF0IHR5cGVzIG9mIFwiJWQlX3JcIiBhbmQgXCIlX3IlZFwiIGhhdmUgdGhlIHNhbWUgZm9ybWF0NlxuICAgcGFyYW1ldGVycywgYnV0IHRoZXkgYXJlIG5vdCBhdCBhbGwgZXhjaGFuZ2VhYmxlLCBhbmQgcHV0dGluZyBvbmVcbiAgIGluIHBsYWNlIG9mIHRoZSBvdGhlciBtdXN0IHJlc3VsdCBpbiBhIGR5bmFtaWMgZmFpbHVyZS5cblxuICAgR2l2ZW4gdGhhdDpcbiAgIC0gd2UnZCBoYXZlIHRvIGR1cGxpY2F0ZSBhIGxvdCBvZiBub24tdHJpdmlhbCB0eXBpbmcgbG9naWMgZnJvbSB0eXBlX2Zvcm1hdFxuICAgLSB0aGlzIHdvdWxkbid0IGV2ZW4gZWxpbWluYXRlIChhbGwpIHRoZSBkeW5hbWljIGZhaWx1cmVzXG4gICB3ZSBkZWNpZGVkIHRvIGp1c3QgcmV1c2UgdHlwZV9mb3JtYXQgZGlyZWN0bHkgZm9yIG5vdy5cbiopXG5sZXQgcmVjYXN0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT5cbiAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQcmludGluZyB0b29scyAqKVxuXG4oKiBBZGQgcGFkZGluZyBzcGFjZXMgYXJvdW5kIGEgc3RyaW5nLiAqKVxubGV0IGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoIHN0ciA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGgsIHBhZHR5ID1cbiAgICBhYnMgd2lkdGgsXG4gICAgKCogd2hpbGUgbGl0ZXJhbCBwYWRkaW5nIHdpZHRocyBhcmUgYWx3YXlzIG5vbi1uZWdhdGl2ZSxcbiAgICAgICBkeW5hbWljYWxseS1zZXQgd2lkdGhzIChBcmdfcGFkZGluZywgZWcuICUqZCkgbWF5IGJlIG5lZ2F0aXZlO1xuICAgICAgIHdlIGludGVycHJldCB0aG9zZSBhcyBzcGVjaWZ5aW5nIGEgcGFkZGluZy10by10aGUtbGVmdDsgdGhpc1xuICAgICAgIG1lYW5zIHRoYXQgJzAnIG1heSBnZXQgZHJvcHBlZCBldmVuIGlmIGl0IHdhcyBleHBsaWNpdGx5IHNldCxcbiAgICAgICBidXQ6XG4gICAgICAgLSB0aGlzIGlzIHdoYXQgdGhlIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkb2VzLCBhbmRcbiAgICAgICAgIHdlIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgaWYgcG9zc2libGVcbiAgICAgICAtIHdlIGNvdWxkIG9ubHkgc2lnbmFsIHRoaXMgaXNzdWUgYnkgZmFpbGluZyBhdCBydW50aW1lLFxuICAgICAgICAgd2hpY2ggaXMgbm90IHZlcnkgbmljZS4uLiAqKVxuICAgIGlmIHdpZHRoIDwgMCB0aGVuIExlZnQgZWxzZSBwYWR0eSBpblxuICBpZiB3aWR0aCA8PSBsZW4gdGhlbiBzdHIgZWxzZVxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHdpZHRoIChpZiBwYWR0eSA9IFplcm9zIHRoZW4gJzAnIGVsc2UgJyAnKSBpblxuICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICB8IExlZnQgIC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAwIGxlblxuICAgIHwgUmlnaHQgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDAgJiYgKHN0ci5bMF0gPSAnKycgfHwgc3RyLlswXSA9ICctJyB8fCBzdHIuWzBdID0gJyAnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAwIHN0ci5bMF07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHdpZHRoIC0gbGVuICsgMSkgKGxlbiAtIDEpXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDEgJiYgc3RyLlswXSA9ICcwJyAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHdpZHRoIC0gbGVuICsgMikgKGxlbiAtIDIpXG4gICAgfCBaZXJvcyAtPlxuICAgICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgZW5kO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEFkZCAnMCcgcGFkZGluZyB0byBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxubGV0IGZpeF9pbnRfcHJlY2lzaW9uIHByZWMgc3RyID1cbiAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbWF0Y2ggc3RyLlswXSB3aXRoXG4gIHwgKCcrJyB8ICctJyB8ICcgJykgYXMgYyB3aGVuIHByZWMgKyAxID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAxKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDAgYztcbiAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHByZWMgLSBsZW4gKyAyKSAobGVuIC0gMSk7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgd2hlbiBwcmVjICsgMiA+IGxlbiAmJiBsZW4gPiAxICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAyKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHByZWMgLSBsZW4gKyA0KSAobGVuIC0gMik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgd2hlbiBwcmVjID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgcHJlYyAnMCcgaW5cbiAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHByZWMgLSBsZW4pIGxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8IF8gLT5cbiAgICBzdHJcblxuKCogRXNjYXBlIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aW5nIGNvbnZlbnRpb24uICopXG5sZXQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcuZXNjYXBlZCBzdHIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXFwiJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9pbnQvaW50MzIvbmF0aXZlaW50L2ludDY0IGZpcnN0IGFyZ3VtZW50XG4gICBmcm9tIGFuIGludF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9pY29udiA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlZFwiIHwgSW50X3BkIC0+IFwiJStkXCIgfCBJbnRfc2QgLT4gXCIlIGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWlcIiB8IEludF9waSAtPiBcIiUraVwiIHwgSW50X3NpIC0+IFwiJSBpXCJcbiAgfCBJbnRfeCAtPiBcIiV4XCIgfCBJbnRfQ3ggLT4gXCIlI3hcIlxuICB8IEludF9YIC0+IFwiJVhcIiB8IEludF9DWCAtPiBcIiUjWFwiXG4gIHwgSW50X28gLT4gXCIlb1wiIHwgSW50X0NvIC0+IFwiJSNvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiV1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udkwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJUxkXCIgfCBJbnRfcGQgLT4gXCIlK0xkXCIgfCBJbnRfc2QgLT4gXCIlIExkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVMaVwiIHwgSW50X3BpIC0+IFwiJStMaVwiIHwgSW50X3NpIC0+IFwiJSBMaVwiXG4gIHwgSW50X3ggLT4gXCIlTHhcIiB8IEludF9DeCAtPiBcIiUjTHhcIlxuICB8IEludF9YIC0+IFwiJUxYXCIgfCBJbnRfQ1ggLT4gXCIlI0xYXCJcbiAgfCBJbnRfbyAtPiBcIiVMb1wiIHwgSW50X0NvIC0+IFwiJSNMb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlTHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252bCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbGRcIiB8IEludF9wZCAtPiBcIiUrbGRcIiB8IEludF9zZCAtPiBcIiUgbGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJWxpXCIgfCBJbnRfcGkgLT4gXCIlK2xpXCIgfCBJbnRfc2kgLT4gXCIlIGxpXCJcbiAgfCBJbnRfeCAtPiBcIiVseFwiIHwgSW50X0N4IC0+IFwiJSNseFwiXG4gIHwgSW50X1ggLT4gXCIlbFhcIiB8IEludF9DWCAtPiBcIiUjbFhcIlxuICB8IEludF9vIC0+IFwiJWxvXCIgfCBJbnRfQ28gLT4gXCIlI2xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVsdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZuID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVuZFwiIHwgSW50X3BkIC0+IFwiJStuZFwiIHwgSW50X3NkIC0+IFwiJSBuZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbmlcIiB8IEludF9waSAtPiBcIiUrbmlcIiB8IEludF9zaSAtPiBcIiUgbmlcIlxuICB8IEludF94IC0+IFwiJW54XCIgfCBJbnRfQ3ggLT4gXCIlI254XCJcbiAgfCBJbnRfWCAtPiBcIiVuWFwiIHwgSW50X0NYIC0+IFwiJSNuWFwiXG4gIHwgSW50X28gLT4gXCIlbm9cIiB8IEludF9DbyAtPiBcIiUjbm9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJW51XCJcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9mbG9hdCBmaXJzdCBhcmd1bWVudCBmcm9tIGEgZmxvYXRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYyA9XG4gICAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICAgIGxldCBzeW1iID0gY2hhcl9vZl9mY29udiB+Y0Y6J2cnIGZjb252IGluXG4gICAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnY7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHByZWMpO1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgc3ltYjtcbiAgICBidWZmZXJfY29udGVudHMgYnVmXG5cbmxldCB0cmFuc2Zvcm1faW50X2FsdCBpY29udiBzID1cbiAgbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgIGxldCBkaWdpdHMgPVxuICAgICAgbGV0IG4gPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgfCAnMCcuLic5JyAtPiBpbmNyIG5cbiAgICAgICAgfCBfIC0+ICgpXG4gICAgICBkb25lO1xuICAgICAgIW5cbiAgICBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgKFN0cmluZy5sZW5ndGggcyArIChkaWdpdHMgLSAxKSAvIDMpIGluXG4gICAgbGV0IHBvcyA9IHJlZiAwIGluXG4gICAgbGV0IHB1dCBjID0gQnl0ZXMuc2V0IGJ1ZiAhcG9zIGM7IGluY3IgcG9zIGluXG4gICAgbGV0IGxlZnQgPSByZWYgKChkaWdpdHMgLSAxKSBtb2QgMyArIDEpIGluXG4gICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICcwJy4uJzknIGFzIGMgLT5cbiAgICAgICAgICBpZiAhbGVmdCA9IDAgdGhlbiAocHV0ICdfJzsgbGVmdCA6PSAzKTsgZGVjciBsZWZ0OyBwdXQgY1xuICAgICAgfCBjIC0+IHB1dCBjXG4gICAgZG9uZTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGJ1ZlxuICB8IF8gLT4gc1xuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgY29udmVyc2lvbi4gKilcbmxldCBjb252ZXJ0X2ludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQgKGZvcm1hdF9vZl9pY29udiBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDMyIGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDMyIChmb3JtYXRfb2ZfaWNvbnZsIGljb252KSBuKVxubGV0IGNvbnZlcnRfbmF0aXZlaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X25hdGl2ZWludCAoZm9ybWF0X29mX2ljb252biBpY29udikgbilcbmxldCBjb252ZXJ0X2ludDY0IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludDY0IChmb3JtYXRfb2ZfaWNvbnZMIGljb252KSBuKVxuXG4oKiBDb252ZXJ0IGEgZmxvYXQgdG8gc3RyaW5nLiAqKVxuKCogRml4IHNwZWNpYWwgY2FzZSBvZiBcIk9DYW1sIGZsb2F0IGZvcm1hdFwiLiAqKVxubGV0IGNvbnZlcnRfZmxvYXQgZmNvbnYgcHJlYyB4ID1cbiAgbGV0IGhleCAoKSA9XG4gICAgbGV0IHNpZ24gPVxuICAgICAgbWF0Y2ggZnN0IGZjb252IHdpdGhcbiAgICAgIHwgRmxvYXRfZmxhZ19wIC0+ICcrJ1xuICAgICAgfCBGbG9hdF9mbGFnX3MgLT4gJyAnXG4gICAgICB8IF8gLT4gJy0nIGluXG4gICAgaGV4c3RyaW5nX29mX2Zsb2F0IHggcHJlYyBzaWduIGluXG4gIGxldCBhZGRfZG90X2lmX25lZWRlZCBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCByZWMgaXNfdmFsaWQgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gZmFsc2UgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnLicgfCAnZScgfCAnRScgLT4gdHJ1ZVxuICAgICAgICB8IF8gLT4gaXNfdmFsaWQgKGkgKyAxKSBpblxuICAgIGlmIGlzX3ZhbGlkIDAgdGhlbiBzdHIgZWxzZSBzdHIgXiBcIi5cIiBpblxuICBsZXQgY2FtbF9zcGVjaWFsX3ZhbCBzdHIgPSBtYXRjaCBjbGFzc2lmeV9mbG9hdCB4IHdpdGhcbiAgICB8IEZQX25vcm1hbCB8IEZQX3N1Ym5vcm1hbCB8IEZQX3plcm8gLT4gc3RyXG4gICAgfCBGUF9pbmZpbml0ZSAtPiBpZiB4IDwgMC4wIHRoZW4gXCJuZWdfaW5maW5pdHlcIiBlbHNlIFwiaW5maW5pdHlcIlxuICAgIHwgRlBfbmFuIC0+IFwibmFuXCIgaW5cbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9oIC0+IGhleCAoKVxuICB8IEZsb2F0X0ggLT4gU3RyaW5nLnVwcGVyY2FzZV9hc2NpaSAoaGV4ICgpKVxuICB8IEZsb2F0X0NGIC0+IGNhbWxfc3BlY2lhbF92YWwgKGhleCAoKSlcbiAgfCBGbG9hdF9GIC0+XG4gICAgbGV0IHN0ciA9IGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHggaW5cbiAgICBjYW1sX3NwZWNpYWxfdmFsIChhZGRfZG90X2lmX25lZWRlZCBzdHIpXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgLT5cbiAgICBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4XG5cbigqIENvbnZlcnQgYSBjaGFyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uLiAqKVxubGV0IGZvcm1hdF9jYW1sX2NoYXIgYyA9XG4gIGxldCBzdHIgPSBDaGFyLmVzY2FwZWQgYyBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcJycgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdHlwZSB0byBzdHJpbmcgKilcbmxldCBzdHJpbmdfb2ZfZm10dHkgZm10dHkgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10dHkgYnVmIGZtdHR5O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAoKiBHZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uICopXG5cbigqIE1ha2UgYSBnZW5lcmljIHByaW50aW5nIGZ1bmN0aW9uLiAqKVxuKCogVXNlZCB0byBnZW5lcmF0ZSBQcmludGYgYW5kIEZvcm1hdCBwcmludGluZyBmdW5jdGlvbnMuICopXG4oKiBQYXJhbWV0ZXJzOlxuICAgICBrOiBhIGNvbnRpbnVhdGlvbiBmaW5hbGx5IGFwcGxpZWQgdG8gdGhlIG91dHB1dCBzdHJlYW0gYW5kIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgbzogdGhlIG91dHB1dCBzdHJlYW0gKHNlZSBrLCAlYSBhbmQgJXQpLlxuICAgICBhY2M6IHJldiBsaXN0IG9mIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXNoLCBmb3JtYXR0aW5nLCAuLi4pLlxuICAgICBmbXQ6IHRoZSBmb3JtYXQuICopXG5sZXQgcmVjIG1ha2VfcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfY2FtbF9jaGFyIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCAoZnVuIHN0ciAtPiBzdHIpXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQgaWNvbnZcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50MzIgaWNvbnZcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X25hdGl2ZWludCBpY29udlxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQ2NCBpY29udlxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBmY29udlxuICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgc3RyaW5nX29mX2Jvb2xcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgZnVuIGYgeCAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZnVuIG8gLT4gZiBvIHgpKSByZXN0XG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIGZ1biBmIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbSAoYXJpdHksIGYsIHJlc3QpIC0+XG4gICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiAoKSlcbiAgfCBSZWFkZXIgXyAtPlxuICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gKilcbiAgICAoKiBJbmRlZWQsIHNpbmNlIHByaW50ZiBhbmQgY28uIHRha2UgYSBmb3JtYXQ0IGFzIGFyZ3VtZW50LCB0aGUgJ2QgYW5kICdlXG4gICAgICAgdHlwZSBwYXJhbWV0ZXJzIG9mIGZtdCBhcmUgb2J2aW91c2x5IGVxdWFscy4gVGhlIFJlYWRlciBpcyB0aGVcbiAgICAgICBvbmx5IGNvbnN0cnVjdG9yIHdoaWNoIHRvdWNoICdkIGFuZCAnZSB0eXBlIHBhcmFtZXRlcnMgb2YgdGhlIGZvcm1hdFxuICAgICAgIHR5cGUsIGl0IGFkZHMgYW4gKC0+KSB0byB0aGUgJ2QgcGFyYW1ldGVycy4gQ29uc2VxdWVudGx5LCBhIGZvcm1hdDRcbiAgICAgICBjYW5ub3QgY29udGFpbiBhIFJlYWRlciBub2RlLCBleGNlcHQgaW4gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0b1xuICAgICAgIGFuICV7Li4uJX0uIEl0J3Mgbm90IGEgcHJvYmxlbSBiZWNhdXNlIG1ha2VfcHJpbnRmIGRvIG5vdCBjYWxsXG4gICAgICAgaXRzZWxmIHJlY3Vyc2l2ZWx5IG9uIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG8gJXsuLi4lfS4gKilcbiAgICBhc3NlcnQgZmFsc2VcbiAgfCBGbHVzaCByZXN0IC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2ZsdXNoIGFjYykgcmVzdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2Nfc3RyaW5nX2xpdGVyYWwgKGFjYywgc3RyKSkgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19jaGFyX2xpdGVyYWwgKGFjYywgY2hyKSkgcmVzdFxuXG4gIHwgRm9ybWF0X2FyZyAoXywgc3ViX2ZtdHR5LCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHN0cmluZ19vZl9mbXR0eSBzdWJfZm10dHkgaW5cbiAgICAoZnVuIHN0ciAtPlxuICAgICAgaWdub3JlIHN0cjtcbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCB0eSkpIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT4gbWFrZV9wcmludGYgayBhY2NcbiAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICBsZXQgbmV3X2FjYyA9IEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJVtcIikgaW5cbiAgICBmdW4gXyAtPiBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgKCogVGhpcyBjYXNlIHNob3VsZCBiZSByZWZ1c2VkIGZvciBQcmludGYuICopXG4gICAgKCogQWNjZXB0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuICopXG4gICAgKCogSW50ZXJwcmV0ICVsLCAlbiBhbmQgJUwgYXMgJXUuICopXG4gICAgZnVuIG4gLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9pbnQgXCIldVwiIG4pIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBtYWtlX2lnbm9yZWRfcGFyYW0gayBhY2MgaWduIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChmbXRpbmdfbGl0LCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2xpdCAoYWNjLCBmbXRpbmdfbGl0KSkgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX3RhZyBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGthY2MgPVxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX2JveCBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIEVuZF9vZl9hY2MgZm10J1xuXG4gIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgIGsgYWNjXG5cbigqIERlbGF5IHRoZSBlcnJvciAoSW52YWxpZF9hcmd1bWVudCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikuICopXG4oKiBHZW5lcmF0ZSBmdW5jdGlvbnMgdG8gdGFrZSByZW1haW5pbmcgYXJndW1lbnRzIChhZnRlciB0aGUgXCIlX1wiKS4gKilcbmFuZCBtYWtlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuXG5cbigqIFNwZWNpYWwgY2FzZSBvZiBwcmludGYgXCIlXyhcIi4gKilcbmFuZCBtYWtlX2Zyb21fZm10dHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBmbXR0eSAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10dHkgZm10IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFRoZXRhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFJlYWRlcl90eSBfICAgICAgICAgICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IF8gICAgIC0+IGFzc2VydCBmYWxzZVxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEVuZF9vZl9mbXR0eSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyAoY29uY2F0X2ZtdHR5IHR5IHJlc3QpIGZtdFxuXG4oKiBJbnNlcnQgYW4gQWNjX2ludmFsaWRfYXJnIGluIHRoZSBhY2N1bXVsYXRvciBhbmQgY29udGludWUgdG8gZ2VuZXJhdGVcbiAgIGNsb3N1cmVzIHRvIGdldCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cy4gKilcbmFuZCBtYWtlX2ludmFsaWRfYXJnIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgZm10IC0+XG4gIG1ha2VfcHJpbnRmIGsgKEFjY19pbnZhbGlkX2FyZyAoYWNjLCBcIlByaW50ZjogYmFkIGNvbnZlcnNpb24gJV9cIikpIGZtdFxuXG4oKiBGaXggcGFkZGluZywgdGFrZSBpdCBhcyBhbiBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50IGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX3BhZGRpbmcgOiB0eXBlIHggeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeiAtPiBhKSBwYWRkaW5nIC0+ICh6IC0+IHN0cmluZykgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHRyYW5zIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCB0cmFucyB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuXG4oKiBGaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGZvciBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQuICopXG4oKiBUYWtlIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4gKGludF9jb252IC0+IHogLT4gc3RyaW5nKSAtPlxuICAgIGludF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIHRyYW5zIGljb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSB0cmFucyBpY29udiB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5cbigqIENvbnZlcnQgYSBmbG9hdCwgZml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBpZiBuZWVkZWQuICopXG4oKiBUYWtlIHRoZSBmbG9hdCBhcmd1bWVudCBhbmQgb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCBmbG9hdCAtPiBhKSBwcmVjaXNpb24gLT4gZmxvYXRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyBmY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiAoZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYpIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuYW5kIG1ha2VfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB4IC0+IHkgPVxuICBmdW4gayBhY2MgcmVzdCBhcml0eSBmIC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmIHgpXG5cbmxldCBjb25zdCB4IF8gPSB4XG5cbmxldCByZWMgbWFrZV9pcHJpbnRmIDogdHlwZSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG4gIGZ1biBrIG8gZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IENhbWxfc3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEJvb2wgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9jdXN0b21fYXJpdHkgayBvIHJlc3QgYXJpdHlcbiAgICB8IFJlYWRlciBfIC0+XG4gICAgICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gIFNlZSB0aGVcbiAgICAgICAgICAgbm90ZSBpbiB0aGUgY29ycmVzcG9uZGluZyBjYXNlIGZvciBtYWtlX3ByaW50Zi4gKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgICAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT5cbiAgICAgICAgICBtYWtlX2lwcmludGYgayBvXG4gICAgICAgICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcbiAgICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lnbm9yZWRfcGFyYW0gKGZ1biBfIC0+IGsgbykgKEVuZF9vZl9hY2MpIGlnbiByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICAgICAgayBvXG5hbmQgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gOlxuICB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT4geCA9XG4gIGZ1biBrIG8gZm10IHBhZCBwcmVjIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IExpdF9wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgQXJnX3BhZGRpbmcgXywgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSkpXG5hbmQgZm5fb2ZfY3VzdG9tX2FyaXR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPlxuICBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geSA9XG4gIGZ1biBrIG8gZm10IC0+IGZ1bmN0aW9uXG4gICAgfCBDdXN0b21femVybyAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIGZtdFxuICAgIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICAgICAgY29uc3QgKGZuX29mX2N1c3RvbV9hcml0eSBrIG8gZm10IGFyaXR5KVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb250aW51YXRpb25zIGZvciBtYWtlX3ByaW50ZiAqKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGFuIG91dHB1dF9zdHJlYW0uICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBvdXRwdXRfYWNjIG8gYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAe1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gXCJAW1wiOyBvdXRwdXRfYWNjIG8gYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfc3RyaW5nIG8gc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBvdXRwdXRfY2hhciBvIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGYgb1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZmx1c2ggb1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIG8gcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgYnVmcHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7IGYgYlxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gYnVmcHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIGJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mICVhIGFuZCAldC4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIChmICgpKVxuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBiIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXJyb3IgbWFuYWdlbWVudCAqKVxuXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIHByZXR0eS1wcmludGVkIGVycm9yIG1lc3NhZ2UuICopXG5sZXQgZmFpbHdpdGhfbWVzc2FnZSAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDI1NiBpblxuICBsZXQgayBhY2MgPSBzdHJwdXRfYWNjIGJ1ZiBhY2M7IGZhaWx3aXRoIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0dGluZyB0b29scyAqKVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGFuIG9wZW4gYmxvY2sgZGVzY3JpcHRpb24gKGluZGVudCwgYmxvY2tfdHlwZSkgKilcbmxldCBvcGVuX2JveF9vZl9zdHJpbmcgc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuICgwLCBQcF9ib3gpIGVsc2VcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgaW52YWxpZF9ib3ggKCkgPSBmYWlsd2l0aF9tZXNzYWdlIFwiaW52YWxpZCBib3ggZGVzY3JpcHRpb24gJVNcIiBzdHIgaW5cbiAgICBsZXQgcmVjIHBhcnNlX3NwYWNlcyBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBpIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgLT4gcGFyc2Vfc3BhY2VzIChpICsgMSlcbiAgICAgICAgfCBfIC0+IGlcbiAgICBhbmQgcGFyc2VfbHdvcmQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJ2EnIC4uICd6JyAtPiBwYXJzZV9sd29yZCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGpcbiAgICBhbmQgcGFyc2VfaW50IGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT4gcGFyc2VfaW50IGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4gaiBpblxuICAgIGxldCB3c3RhcnQgPSBwYXJzZV9zcGFjZXMgMCBpblxuICAgIGxldCB3ZW5kID0gcGFyc2VfbHdvcmQgd3N0YXJ0IHdzdGFydCBpblxuICAgIGxldCBib3hfbmFtZSA9IFN0cmluZy5zdWIgc3RyIHdzdGFydCAod2VuZCAtIHdzdGFydCkgaW5cbiAgICBsZXQgbnN0YXJ0ID0gcGFyc2Vfc3BhY2VzIHdlbmQgaW5cbiAgICBsZXQgbmVuZCA9IHBhcnNlX2ludCBuc3RhcnQgbnN0YXJ0IGluXG4gICAgbGV0IGluZGVudCA9XG4gICAgICBpZiBuc3RhcnQgPSBuZW5kIHRoZW4gMCBlbHNlXG4gICAgICAgIHRyeSBpbnRfb2Zfc3RyaW5nIChTdHJpbmcuc3ViIHN0ciBuc3RhcnQgKG5lbmQgLSBuc3RhcnQpKVxuICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIGxldCBleHBfZW5kID0gcGFyc2Vfc3BhY2VzIG5lbmQgaW5cbiAgICBpZiBleHBfZW5kIDw+IGxlbiB0aGVuIGludmFsaWRfYm94ICgpO1xuICAgIGxldCBib3hfdHlwZSA9IG1hdGNoIGJveF9uYW1lIHdpdGhcbiAgICAgIHwgXCJcIiB8IFwiYlwiIC0+IFBwX2JveFxuICAgICAgfCBcImhcIiAgICAgIC0+IFBwX2hib3hcbiAgICAgIHwgXCJ2XCIgICAgICAtPiBQcF92Ym94XG4gICAgICB8IFwiaHZcIiAgICAgLT4gUHBfaHZib3hcbiAgICAgIHwgXCJob3ZcIiAgICAtPiBQcF9ob3Zib3hcbiAgICAgIHwgXyAgICAgICAgLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICAoaW5kZW50LCBib3hfdHlwZSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQYXJzaW5nIHRvb2xzICopXG5cbigqIENyZWF0ZSBhIHBhZGRpbmdfZm10X2ViYiBmcm9tIGEgcGFkZGluZyBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkZGluZ19mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwYWRkaW5nX2ZtdF9lYmIgPVxuZnVuIHBhZCBmbXQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChOb19wYWRkaW5nLCBmbXQpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZGRpbmdfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBmbXQpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgZm10KVxuXG4oKiBDcmVhdGUgYSBwcmVjaXNpb25fZm10X2ViYiBmcm9tIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIDogdHlwZSB4IHkgLlxuICAgICh4LCB5KSBwcmVjaXNpb24gLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHByZWNpc2lvbl9mbXRfZWJiID1cbmZ1biBwcmVjIGZtdCAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgfCBOb19wcmVjaXNpb24gICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKE5vX3ByZWNpc2lvbiwgZm10KVxuICB8IExpdF9wcmVjaXNpb24gcCAtPiBQcmVjaXNpb25fZm10X0VCQiAoTGl0X3ByZWNpc2lvbiBwLCBmbXQpXG4gIHwgQXJnX3ByZWNpc2lvbiAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChBcmdfcHJlY2lzaW9uLCBmbXQpXG5cbigqIENyZWF0ZSBhIHBhZHByZWNfZm10X2ViYiBmcm9tIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyBhbmQgdGhlIHByZWNpc2lvbiB0byBkaXNqb2luIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudHNcbiAgIGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgOiB0eXBlIHggeSB6IHQgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT5cbiAgICAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgKF8sIF8sIF8sIF8sIF8pIHBhZHByZWNfZm10X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10IC0+XG4gIGxldCBQcmVjaXNpb25fZm10X0VCQiAocHJlYywgZm10JykgPSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIHByZWMgZm10IGluXG4gIG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoTm9fcGFkZGluZywgcHJlYywgZm10JylcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkcHJlY19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIHByZWMsIGZtdCcpXG4gIHwgQXJnX3BhZGRpbmcgcyAgICAgIC0+IFBhZHByZWNfZm10X0VCQiAoQXJnX3BhZGRpbmcgcywgcHJlYywgZm10JylcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHBhcnNpbmcgKilcblxuKCogUGFyc2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZm9ybWF0IGFuZCBjcmVhdGUgYSBmbXRfZWJiLiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIGluIGNhc2Ugb2YgaW52YWxpZCBmb3JtYXQuICopXG5sZXQgZm10X2ViYl9vZl9zdHJpbmcgP2xlZ2FjeV9iZWhhdmlvciBzdHIgPVxuICAoKiBQYXJhbWV0ZXJzIG5hbWluZyBjb252ZW50aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBsaXRfc3RhcnQ6IHN0YXJ0IG9mIHRoZSBsaXRlcmFsIHNlcXVlbmNlLiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN0cl9pbmQ6IGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZy4gICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gZW5kX2luZDogZW5kIG9mIHRoZSBjdXJyZW50IChzdWItKWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwY3RfaW5kOiBpbmRleCBvZiB0aGUgJyUnIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgKilcbiAgKCogICAtIHplcm86ICBpcyB0aGUgJzAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gbWludXM6IGlzIHRoZSAnLScgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwbHVzOiAgaXMgdGhlICcrJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGhhc2g6ICBpcyB0aGUgJyMnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gc3BhY2U6IGlzIHRoZSAnICcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBpZ246ICAgaXMgdGhlICdfJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBhZDogcGFkZGluZyBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcHJlYzogcHJlY2lzaW9uIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzeW1iOiBjaGFyIHJlcHJlc2VudGluZyB0aGUgY29udmVyc2lvbiAoJ2MnLCAncycsICdkJywgLi4uKS4gKilcbiAgKCogICAtIGNoYXJfc2V0OiBzZXQgb2YgY2hhcmFjdGVycyBhcyBiaXRtYXAgKHNlZSBzY2FuZiAlWy4uLl0pLiAgICAqKVxuXG4gIGxldCBsZWdhY3lfYmVoYXZpb3IgPSBtYXRjaCBsZWdhY3lfYmVoYXZpb3Igd2l0aFxuICAgIHwgU29tZSBmbGFnIC0+IGZsYWdcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAoKiAgV2hlbiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgdGhlIGZvcm1hdCBwYXJzZXIgdHJpZXMgdG8gYmVoYXZlIGFzXG4gICAgICB0aGUgPDQuMDIgaW1wbGVtZW50YXRpb25zLCBpbiBwYXJ0aWN1bGFyIGl0IGlnbm9yZXMgbW9zdCBiZW5pbmVcbiAgICAgIG5vbnNlbnNpY2FsIGZvcm1hdC4gV2hlbiB0aGUgZmxhZyBpcyBkaXNhYmxlZCwgaXQgd2lsbCByZWplY3QgYW55XG4gICAgICBmb3JtYXQgdGhhdCBpcyBub3QgYWNjZXB0ZWQgYnkgdGhlIHNwZWNpZmljYXRpb24uXG5cbiAgICAgIEEgdHlwaWNhbCBleGFtcGxlIHdvdWxkIGJlIFwiJSsgZFwiOiBzcGVjaWZ5aW5nIGJvdGggJysnIChpZiB0aGVcbiAgICAgIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGggYSAnKycgdG8gZ2V0IHRoZSBzYW1lIHdpZHRoIGFzXG4gICAgICBuZWdhdGl2ZSBudW1iZXJzKSBhbmQgJyAnIChpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aFxuICAgICAgYSBzcGFjZSkgZG9lcyBub3QgbWFrZSBzZW5zZSwgYnV0IHRoZSBsZWdhY3kgKDwgNC4wMilcbiAgICAgIGltcGxlbWVudGF0aW9uIHdhcyBoYXBweSB0byBqdXN0IGlnbm9yZSB0aGUgc3BhY2UuXG4gICopXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kIG1zZyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgbXNnXG4gIGluXG5cbiAgKCogVXNlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIGZvcm1hdCAob3IgdGhlIGN1cnJlbnQgc3ViLWZvcm1hdCkgd2FzIGVuY291bnRlcmVkXG4gICAgICB1bmV4cGVjdGVkbHkuICopXG4gIGxldCB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBlbmRfaW5kXG4gICAgICBcInVuZXhwZWN0ZWQgZW5kIG9mIGZvcm1hdFwiXG4gIGluXG5cbiAgKCogVXNlZCBmb3IgJTBjOiBubyBvdGhlciB3aWR0aHMgYXJlIGltcGxlbWVudGVkICopXG4gIGxldCBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmRcbiAgICAgIFwibm9uLXplcm8gd2lkdGhzIGFyZSB1bnN1cHBvcnRlZCBmb3IgJWMgY29udmVyc2lvbnNcIlxuICBpblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gb3B0aW9uIGRlcGVuZGVuY3lcbiAgICAgcHJvYmxlbS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X3dpdGhvdXQgc3RyX2luZCBjIHMgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICclYycgd2l0aG91dCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBjIHNcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UgYWJvdXQgYW4gdW5leHBlY3RlZFxuICAgICBjaGFyYWN0ZXIuICopXG4gIGxldCBleHBlY3RlZF9jaGFyYWN0ZXIgc3RyX2luZCBleHBlY3RlZCByZWFkID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzIGV4cGVjdGVkLCByZWFkICVDXCJcbiAgICAgIHN0ciBzdHJfaW5kIGV4cGVjdGVkIHJlYWRcbiAgaW5cblxuICAoKiBQYXJzZSB0aGUgc3RyaW5nIGZyb20gYmVnX2luZCAoaW5jbHVkZWQpIHRvIGVuZF9pbmQgKGV4Y2x1ZGVkKS4gKilcbiAgbGV0IHJlYyBwYXJzZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBiZWdfaW5kIGVuZF9pbmQgLT4gcGFyc2VfbGl0ZXJhbCBiZWdfaW5kIGJlZ19pbmQgZW5kX2luZFxuXG4gICgqIFJlYWQgbGl0ZXJhbCBjaGFyYWN0ZXJzIHVwIHRvICclJyBvciAnQCcgc3BlY2lhbCBjaGFyYWN0ZXJzLiAqKVxuICBhbmQgcGFyc2VfbGl0ZXJhbCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgRW5kX29mX2Zvcm1hdCBlbHNlXG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfZm9ybWF0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9hZnRlcl9hdCAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9saXRlcmFsIGxpdF9zdGFydCAoc3RyX2luZCArIDEpIGVuZF9pbmRcblxuICAoKiBQYXJzZSBhIGZvcm1hdCBhZnRlciAnJScgKilcbiAgYW5kIHBhcnNlX2Zvcm1hdCA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIGVuZF9pbmQgLT4gcGFyc2VfaWduIHBjdF9pbmQgKHBjdF9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgYW5kIHBhcnNlX2lnbiA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXycgLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCAoc3RyX2luZCsxKSBlbmRfaW5kIHRydWVcbiAgICAgIHwgXyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBmYWxzZVxuXG4gIGFuZCBwYXJzZV9mbGFncyA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiAoXywgXywgZSwgZikgZm10X2ViYlxuICA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBpZ24gLT5cbiAgICBsZXQgemVybyA9IHJlZiBmYWxzZSBhbmQgbWludXMgPSByZWYgZmFsc2VcbiAgICBhbmQgcGx1cyA9IHJlZiBmYWxzZSBhbmQgc3BhY2UgPSByZWYgZmFsc2VcbiAgICBhbmQgaGFzaCA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBzZXRfZmxhZyBzdHJfaW5kIGZsYWcgPVxuICAgICAgKCogaW4gbGVnYWN5IG1vZGUsIGR1cGxpY2F0ZSBmbGFncyBhcmUgYWNjZXB0ZWQgKilcbiAgICAgIGlmICFmbGFnICYmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgZHVwbGljYXRlIGZsYWcgJUNcIlxuICAgICAgICAgIHN0ciBzdHJfaW5kIHN0ci5bc3RyX2luZF07XG4gICAgICBmbGFnIDo9IHRydWU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHJlYWRfZmxhZ3Mgc3RyX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICcwJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHplcm87ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJy0nIC0+IHNldF9mbGFnIHN0cl9pbmQgbWludXM7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnKycgLT4gc2V0X2ZsYWcgc3RyX2luZCBwbHVzOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcjJyAtPiBzZXRfZmxhZyBzdHJfaW5kIGhhc2g7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnICcgLT4gc2V0X2ZsYWcgc3RyX2luZCBzcGFjZTsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZFxuICAgICAgICAgICF6ZXJvICFtaW51cyAhcGx1cyAhaGFzaCAhc3BhY2UgaWduXG4gICAgICBlbmRcbiAgICBpblxuICAgIHJlYWRfZmxhZ3Mgc3RyX2luZFxuXG4gICgqIFRyeSB0byByZWFkIGEgZGlnaXRhbCBvciBhICcqJyBwYWRkaW5nLiAqKVxuICBhbmQgcGFyc2VfcGFkZGluZyA6IHR5cGUgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHplcm8gbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhZHR5ID0gbWF0Y2ggemVybywgbWludXMgd2l0aFxuICAgICAgfCBmYWxzZSwgZmFsc2UgLT4gUmlnaHRcbiAgICAgIHwgZmFsc2UsIHRydWUgIC0+IExlZnRcbiAgICAgIHwgIHRydWUsIGZhbHNlIC0+IFplcm9zXG4gICAgICB8ICB0cnVlLCB0cnVlICAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMZWZ0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICctJyBcIjBcIiBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPlxuICAgICAgbGV0IG5ld19pbmQsIHdpZHRoID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAoTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiAoQXJnX3BhZGRpbmcgcGFkdHkpXG4gICAgfCBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgICB8IExlZnQgIC0+XG4gICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLScgXCJwYWRkaW5nXCI7XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIHwgWmVyb3MgLT5cbiAgICAgICAgICgqIGEgJzAnIHBhZGRpbmcgaW5kaWNhdGlvbiBub3QgZm9sbG93ZWQgYnkgYW55dGhpbmcgc2hvdWxkXG4gICAgICAgICAgIGJlIGludGVycHJldGVkIGFzIGEgUmlnaHQgcGFkZGluZyBvZiB3aWR0aCAwLiBUaGlzIGlzIHVzZWRcbiAgICAgICAgICAgYnkgc2Nhbm5pbmcgY29udmVyc2lvbnMgJTBzIGFuZCAlMGMgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgKExpdF9wYWRkaW5nIChSaWdodCwgMCkpXG4gICAgICB8IFJpZ2h0IC0+XG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIE5vX3BhZGRpbmdcbiAgICAgIGVuZFxuXG4gICgqIElzIHByZWNpc2lvbiBkZWZpbmVkPyAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcGFkZGluZyA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcuJyAtPlxuICAgICAgcGFyc2VfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkXG4gICAgfCBzeW1iIC0+XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIE5vX3ByZWNpc2lvbiBwYWQgc3ltYlxuXG4gICgqIFJlYWQgdGhlIGRpZ2l0YWwgb3IgJyonIHByZWNpc2lvbi4gKilcbiAgYW5kIHBhcnNlX3ByZWNpc2lvbiA6IHR5cGUgeCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCBfKSBwYWRkaW5nIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kID1cbiAgICAgIGxldCBuZXdfaW5kLCBwcmVjID0gcGFyc2VfcG9zaXRpdmUgc3RyX2luZCBlbmRfaW5kIDAgaW5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiBwcmVjKSBpblxuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmRcbiAgICB8ICgnKycgfCAnLScpIGFzIHN5bWIgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT5cbiAgICAgICgqIExlZ2FjeSBtb2RlIHdvdWxkIGFjY2VwdCBhbmQgaWdub3JlICcrJyBvciAnLScgYmVmb3JlIHRoZVxuICAgICAgICAgaW50ZWdlciBkZXNjcmliaW5nIHRoZSBkZXNpcmVkIHByZWNpc2lvbjsgbm90ZSB0aGF0IHRoaXNcbiAgICAgICAgIGNhbm5vdCBoYXBwZW4gZm9yIHBhZGRpbmcgd2lkdGgsIGFzICcrJyBhbmQgJy0nIGFscmVhZHkgaGF2ZVxuICAgICAgICAgYSBzZW1hbnRpY3MgdGhlcmUuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgdGhlIGlkZWEgKHN1cHBvcnRlZCBieSB0aGlzIHR3ZWFrKSB0aGF0IHdpZHRoIGFuZFxuICAgICAgICAgcHJlY2lzaW9uIGxpdGVyYWxzIGFyZSBcImludGVnZXIgbGl0ZXJhbHNcIiBpbiB0aGUgT0NhbWwgc2Vuc2UgaXNcbiAgICAgICAgIHN0aWxsIGJsYXRhbnRseSB3cm9uZywgYXMgMTIzXzQ1NiBvciAweEZGIGFyZSByZWplY3RlZC4gKilcbiAgICAgIHBhcnNlX2xpdGVyYWwgKG1pbnVzIHx8IHN5bWIgPSAnLScpIChzdHJfaW5kICsgMSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gcGFkIEFyZ19wcmVjaXNpb25cbiAgICB8IF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIG5vdGUgdGhhdCBsZWdhY3kgaW1wbGVtZW50YXRpb24gZGlkIG5vdCBpZ25vcmUgJy4nIHdpdGhvdXRcbiAgICAgICAgICAgYSBudW1iZXIgKGFzIGl0IGRvZXMgZm9yIHBhZGRpbmcgaW5kaWNhdGlvbnMpLCBidXRcbiAgICAgICAgICAgaW50ZXJwcmV0cyBpdCBhcyAnLjAnICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIDApXG4gICAgICBlbHNlXG4gICAgICAgIGludmFsaWRfZm9ybWF0X3dpdGhvdXQgKHN0cl9pbmQgLSAxKSAnLicgXCJwcmVjaXNpb25cIlxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIDogdHlwZSB4IHkgeiB0IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFyc2VfY29udiAodHlwZSB1KSAodHlwZSB2KSAocGFkcHJlYyA6ICh1LCB2KSBwYWRkaW5nKSA9XG4gICAgICBwYXJzZV9jb252ZXJzaW9uIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkXG4gICAgICAgIHByZWMgcGFkcHJlYyBzdHIuW3N0cl9pbmRdIGluXG4gICAgKCogaW4gbGVnYWN5IG1vZGUsIHNvbWUgZm9ybWF0cyAoJXMgYW5kICVTKSBhY2NlcHQgYSB3ZWlyZCBtaXggb2ZcbiAgICAgICBwYWRkaW5nIGFuZCBwcmVjaXNpb24sIHdoaWNoIGlzIG1lcmdlZCBhcyBhIHNpbmdsZSBwYWRkaW5nXG4gICAgICAgaW5mb3JtYXRpb24uIEZvciBleGFtcGxlLCBpbiAlLjEwcyB0aGUgcHJlY2lzaW9uIGlzIGltcGxpY2l0bHlcbiAgICAgICB1bmRlcnN0b29kIGFzIHBhZGRpbmcgJTEwcywgYnV0IHRoZSBsZWZ0LXBhZGRpbmcgY29tcG9uZW50IG1heVxuICAgICAgIGJlIHNwZWNpZmllZCBlaXRoZXIgYXMgYSBsZWZ0IHBhZGRpbmcgb3IgYSBuZWdhdGl2ZSBwcmVjaXNpb246XG4gICAgICAgJS0uM3MgYW5kICUuLTNzIGFyZSBlcXVpdmFsZW50IHRvICUtM3MgKilcbiAgICBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAtPiAoXG4gICAgICBtYXRjaCBtaW51cywgcHJlYyB3aXRoXG4gICAgICAgIHwgXywgTm9fcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgTm9fcGFkZGluZ1xuICAgICAgICB8IGZhbHNlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKSlcbiAgICAgICAgfCB0cnVlLCBMaXRfcHJlY2lzaW9uIG4gLT4gcGFyc2VfY29udiAoTGl0X3BhZGRpbmcgKExlZnQsIG4pKVxuICAgICAgICB8IGZhbHNlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIFJpZ2h0KVxuICAgICAgICB8IHRydWUsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgTGVmdClcbiAgICApXG4gICAgfCBwYWQgLT4gcGFyc2VfY29udiBwYWRcblxuICAoKiBDYXNlIGFuYWx5c2lzIG9uIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9jb252ZXJzaW9uIDogdHlwZSB4IHkgeiB0IHUgdiBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiAoeCwgeSkgcGFkZGluZyAtPlxuICAgICAgICAoeiwgdCkgcHJlY2lzaW9uIC0+ICh1LCB2KSBwYWRkaW5nIC0+IGNoYXIgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyBwYWRwcmVjIHN5bWIgLT5cbiAgICAoKiBGbGFncyB1c2VkIHRvIGNoZWNrIG9wdGlvbiB1c2FnZXMvY29tcGF0aWJpbGl0aWVzLiAqKVxuICAgIGxldCBwbHVzX3VzZWQgID0gcmVmIGZhbHNlIGFuZCBoYXNoX3VzZWQgPSByZWYgZmFsc2VcbiAgICBhbmQgc3BhY2VfdXNlZCA9IHJlZiBmYWxzZSBhbmQgaWduX3VzZWQgICA9IHJlZiBmYWxzZVxuICAgIGFuZCBwYWRfdXNlZCAgID0gcmVmIGZhbHNlIGFuZCBwcmVjX3VzZWQgID0gcmVmIGZhbHNlIGluXG5cbiAgICAoKiBBY2Nlc3MgdG8gb3B0aW9ucywgdXBkYXRlIGZsYWdzLiAqKVxuICAgIGxldCBnZXRfcGx1cyAgICAoKSA9IHBsdXNfdXNlZCAgOj0gdHJ1ZTsgcGx1c1xuICAgIGFuZCBnZXRfaGFzaCAgICgpID0gaGFzaF91c2VkIDo9IHRydWU7IGhhc2hcbiAgICBhbmQgZ2V0X3NwYWNlICAgKCkgPSBzcGFjZV91c2VkIDo9IHRydWU7IHNwYWNlXG4gICAgYW5kIGdldF9pZ24gICAgICgpID0gaWduX3VzZWQgICA6PSB0cnVlOyBpZ25cbiAgICBhbmQgZ2V0X3BhZCAgICAgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZFxuICAgIGFuZCBnZXRfcHJlYyAgICAoKSA9IHByZWNfdXNlZCAgOj0gdHJ1ZTsgcHJlY1xuICAgIGFuZCBnZXRfcGFkcHJlYyAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkcHJlYyBpblxuXG4gICAgbGV0IGdldF9pbnRfcGFkICgpID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhKSAodHlwZSBiKSAocGFkIDogKGEsIGIpIHBhZGRpbmcpID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9XG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmRcbiAgICAgICAgICAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDxuYW1lPiBhZnRlciBcIkB7XCIgb3IgXCJAW1wiLiAqKVxuICBhbmQgcGFyc2VfdGFnIDogdHlwZSBlIGYgLiBib29sIC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gaXNfb3Blbl90YWcgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgdHJ5XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgbGV0IGluZCA9IFN0cmluZy5pbmRleF9mcm9tIHN0ciAoc3RyX2luZCArIDEpICc+JyBpblxuICAgICAgICBpZiBpbmQgPj0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciBzdHJfaW5kIChpbmQgLSBzdHJfaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCAoaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKHN1Yl9mbXQsIHN1Yl9zdHIpIGluXG4gICAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzcGFjZSwgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIGxldCBmbGFnID0gbWF0Y2ggcGx1cywgc3BhY2Ugd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfXG4gICAgfCBmYWxzZSwgIHRydWUgLT4gRmxvYXRfZmxhZ19zXG4gICAgfCAgdHJ1ZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19wXG4gICAgfCAgdHJ1ZSwgIHRydWUgLT5cbiAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBGbG9hdF9mbGFnX3BcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiIGluXG4gICAgbGV0IGtpbmQgPSBtYXRjaCBoYXNoLCBzeW1iIHdpdGhcbiAgICB8IF8sICdmJyAtPiBGbG9hdF9mXG4gICAgfCBfLCAnZScgLT4gRmxvYXRfZVxuICAgIHwgXywgJ0UnIC0+IEZsb2F0X0VcbiAgICB8IF8sICdnJyAtPiBGbG9hdF9nXG4gICAgfCBfLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgXywgJ2gnIC0+IEZsb2F0X2hcbiAgICB8IF8sICdIJyAtPiBGbG9hdF9IXG4gICAgfCBmYWxzZSwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8IHRydWUsICdGJyAtPiBGbG9hdF9DRlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgaW5cbiAgICBmbGFnLCBraW5kXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbnR5cGUgdCA9IGV4biA9IC4uXG5cbmxldCBwcmludGVycyA9IHJlZiBbXVxuXG5sZXQgbG9jZm10ID0gZm9ybWF0X29mX3N0cmluZyBcIkZpbGUgXFxcIiVzXFxcIiwgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZDogJXNcIlxuXG5sZXQgZmllbGQgeCBpID1cbiAgbGV0IGYgPSBPYmouZmllbGQgeCBpIGluXG4gIGlmIG5vdCAoT2JqLmlzX2Jsb2NrIGYpIHRoZW5cbiAgICBzcHJpbnRmIFwiJWRcIiAoT2JqLm1hZ2ljIGYgOiBpbnQpICAgICAgICAgICAoKiBjYW4gYWxzbyBiZSBhIGNoYXIgKilcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouc3RyaW5nX3RhZyB0aGVuXG4gICAgc3ByaW50ZiBcIiVTXCIgKE9iai5tYWdpYyBmIDogc3RyaW5nKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5kb3VibGVfdGFnIHRoZW5cbiAgICBzdHJpbmdfb2ZfZmxvYXQgKE9iai5tYWdpYyBmIDogZmxvYXQpXG4gIGVsc2VcbiAgICBcIl9cIlxuXG5sZXQgcmVjIG90aGVyX2ZpZWxkcyB4IGkgPVxuICBpZiBpID49IE9iai5zaXplIHggdGhlbiBcIlwiXG4gIGVsc2Ugc3ByaW50ZiBcIiwgJXMlc1wiIChmaWVsZCB4IGkpIChvdGhlcl9maWVsZHMgeCAoaSsxKSlcblxubGV0IGZpZWxkcyB4ID1cbiAgbWF0Y2ggT2JqLnNpemUgeCB3aXRoXG4gIHwgMCAtPiBcIlwiXG4gIHwgMSAtPiBcIlwiXG4gIHwgMiAtPiBzcHJpbnRmIFwiKCVzKVwiIChmaWVsZCB4IDEpXG4gIHwgXyAtPiBzcHJpbnRmIFwiKCVzJXMpXCIgKGZpZWxkIHggMSkgKG90aGVyX2ZpZWxkcyB4IDIpXG5cbmxldCB1c2VfcHJpbnRlcnMgeCA9XG4gIGxldCByZWMgY29udiA9IGZ1bmN0aW9uXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICAobWF0Y2ggaGQgeCB3aXRoXG4gICAgICAgICB8IE5vbmUgfCBleGNlcHRpb24gXyAtPiBjb252IHRsXG4gICAgICAgICB8IFNvbWUgcyAtPiBTb21lIHMpXG4gICAgfCBbXSAtPiBOb25lIGluXG4gIGNvbnYgIXByaW50ZXJzXG5cbmxldCB0b19zdHJpbmdfZGVmYXVsdCA9IGZ1bmN0aW9uXG4gIHwgT3V0X29mX21lbW9yeSAtPiBcIk91dCBvZiBtZW1vcnlcIlxuICB8IFN0YWNrX292ZXJmbG93IC0+IFwiU3RhY2sgb3ZlcmZsb3dcIlxuICB8IE1hdGNoX2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzUpIFwiUGF0dGVybiBtYXRjaGluZyBmYWlsZWRcIlxuICB8IEFzc2VydF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIkFzc2VydGlvbiBmYWlsZWRcIlxuICB8IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis2KSBcIlVuZGVmaW5lZCByZWN1cnNpdmUgbW9kdWxlXCJcbiAgfCB4IC0+XG4gICAgICBsZXQgeCA9IE9iai5yZXByIHggaW5cbiAgICAgIGlmIE9iai50YWcgeCA8PiAwIHRoZW5cbiAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIHggMCkgOiBzdHJpbmcpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBjb25zdHJ1Y3RvciA9XG4gICAgICAgICAgKE9iai5tYWdpYyAoT2JqLmZpZWxkIChPYmouZmllbGQgeCAwKSAwKSA6IHN0cmluZykgaW5cbiAgICAgICAgY29uc3RydWN0b3IgXiAoZmllbGRzIHgpXG5cbmxldCB0b19zdHJpbmcgZSA9XG4gIG1hdGNoIHVzZV9wcmludGVycyBlIHdpdGhcbiAgfCBTb21lIHMgLT4gc1xuICB8IE5vbmUgLT4gdG9fc3RyaW5nX2RlZmF1bHQgZVxuXG5sZXQgcHJpbnQgZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGZsdXNoIHN0ZGVycjtcbiAgICByYWlzZSB4XG5cbmxldCBjYXRjaCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBmbHVzaCBzdGRvdXQ7XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGV4aXQgMlxuXG50eXBlIHJhd19iYWNrdHJhY2Vfc2xvdFxudHlwZSByYXdfYmFja3RyYWNlXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlOlxuICB1bml0IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlXCJcblxuZXh0ZXJuYWwgcmFpc2Vfd2l0aF9iYWNrdHJhY2U6IGV4biAtPiByYXdfYmFja3RyYWNlIC0+ICdhXG4gID0gXCIlcmFpc2Vfd2l0aF9iYWNrdHJhY2VcIlxuXG50eXBlIGJhY2t0cmFjZV9zbG90ID1cbiAgfCBLbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSAgICA6IGJvb2w7XG4gICAgICBmaWxlbmFtZSAgICA6IHN0cmluZztcbiAgICAgIGxpbmVfbnVtYmVyIDogaW50O1xuICAgICAgc3RhcnRfY2hhciAgOiBpbnQ7XG4gICAgICBlbmRfY2hhciAgICA6IGludDtcbiAgICAgIGlzX2lubGluZSAgIDogYm9vbDtcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbigqIHRvIGF2b2lkIHdhcm5pbmcgKilcbmxldCBfID0gW0tub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZTsgZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX251bWJlciA9IDA7IHN0YXJ0X2NoYXIgPSAwOyBlbmRfY2hhciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2lubGluZSA9IGZhbHNlIH07XG4gICAgICAgICBVbmtub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZSB9XVxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IGJhY2t0cmFjZV9zbG90ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlOlxuICByYXdfYmFja3RyYWNlIC0+IGJhY2t0cmFjZV9zbG90IGFycmF5ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZVwiXG5cbmxldCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQgPVxuICB0cnkgU29tZSAoY29udmVydF9yYXdfYmFja3RyYWNlIGJ0KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgcG9zIHNsb3QgPVxuICBsZXQgaW5mbyBpc19yYWlzZSA9XG4gICAgaWYgaXNfcmFpc2UgdGhlblxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGF0XCIgZWxzZSBcIlJlLXJhaXNlZCBhdFwiXG4gICAgZWxzZVxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGJ5IHByaW1pdGl2ZSBvcGVyYXRpb24gYXRcIiBlbHNlIFwiQ2FsbGVkIGZyb21cIlxuICBpblxuICBtYXRjaCBzbG90IHdpdGhcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIGlmIGwuaXNfcmFpc2UgdGhlblxuICAgICAgICAoKiBjb21waWxlci1pbnNlcnRlZCByZS1yYWlzZSwgc2tpcHBlZCAqKSBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIFNvbWUgKHNwcmludGYgXCIlcyB1bmtub3duIGxvY2F0aW9uXCIgKGluZm8gZmFsc2UpKVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIFNvbWUgKHNwcmludGYgXCIlcyBmaWxlIFxcXCIlc1xcXCIlcywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZFwiXG4gICAgICAgICAgICAgIChpbmZvIGwuaXNfcmFpc2UpIGwuZmlsZW5hbWVcbiAgICAgICAgICAgICAgKGlmIGwuaXNfaW5saW5lIHRoZW4gXCIgKGlubGluZWQpXCIgZWxzZSBcIlwiKVxuICAgICAgICAgICAgICBsLmxpbmVfbnVtYmVyIGwuc3RhcnRfY2hhciBsLmVuZF9jaGFyKVxuXG5sZXQgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICAgZnByaW50ZiBvdXRjaGFuXG4gICAgICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGZwcmludGYgb3V0Y2hhbiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lXG5cbmxldCBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gcmF3X2JhY2t0cmFjZSA9XG4gIHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOiBwcmludHMgdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IHByaW50X2JhY2t0cmFjZSBvdXRjaGFuID1cbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxubGV0IGJhY2t0cmFjZV90b19zdHJpbmcgYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBicHJpbnRmIGIgXCIlc1xcblwiIHN0clxuICAgICAgZG9uZTtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG5cbmxldCByYXdfYmFja3RyYWNlX3RvX3N0cmluZyByYXdfYmFja3RyYWNlID1cbiAgYmFja3RyYWNlX3RvX3N0cmluZyAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX2lubGluZVxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuXG50eXBlIGxvY2F0aW9uID0ge1xuICBmaWxlbmFtZSA6IHN0cmluZztcbiAgbGluZV9udW1iZXIgOiBpbnQ7XG4gIHN0YXJ0X2NoYXIgOiBpbnQ7XG4gIGVuZF9jaGFyIDogaW50O1xufVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24gPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgIFNvbWUge1xuICAgICAgZmlsZW5hbWUgICAgPSBsLmZpbGVuYW1lO1xuICAgICAgbGluZV9udW1iZXIgPSBsLmxpbmVfbnVtYmVyO1xuICAgICAgc3RhcnRfY2hhciAgPSBsLnN0YXJ0X2NoYXI7XG4gICAgICBlbmRfY2hhciAgICA9IGwuZW5kX2NoYXI7XG4gICAgfVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzIHJhd19iYWNrdHJhY2UgPVxuICAoKiBUaGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGd1YXJhbnRlZXMgdGhhdCBTb21lIGlzXG4gICAgIHJldHVybmVkIG9ubHkgaWYgYSBwYXJ0IG9mIHRoZSB0cmFjZSBpcyB1c2FibGUuIFRoaXMgZ2l2ZXMgdXNcbiAgICAgYSBiaXQgbW9yZSB3b3JrIHRoYW4ganVzdCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UsIGJ1dCBpdCBtYWtlcyB0aGVcbiAgICAgQVBJIG1vcmUgdXNlci1mcmllbmRseSAtLSBvdGhlcndpc2UgbW9zdCB1c2VycyB3b3VsZCBoYXZlIHRvXG4gICAgIHJlaW1wbGVtZW50IHRoZSBcIlByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBzb3JyeVwiIGxvZ2ljXG4gICAgIHRoZW1zZWx2ZXMuICopXG4gIG1hdGNoIGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBiYWNrdHJhY2UgLT5cbiAgICAgIGxldCB1c2FibGVfc2xvdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG4gICAgICAgIHwgS25vd25fbG9jYXRpb24gXyAtPiB0cnVlIGluXG4gICAgICBsZXQgcmVjIGV4aXN0c191c2FibGUgPSBmdW5jdGlvblxuICAgICAgICB8ICgtMSkgLT4gZmFsc2VcbiAgICAgICAgfCBpIC0+IHVzYWJsZV9zbG90IGJhY2t0cmFjZS4oaSkgfHwgZXhpc3RzX3VzYWJsZSAoaSAtIDEpIGluXG4gICAgICBpZiBleGlzdHNfdXNhYmxlIChBcnJheS5sZW5ndGggYmFja3RyYWNlIC0gMSlcbiAgICAgIHRoZW4gU29tZSBiYWNrdHJhY2VcbiAgICAgIGVsc2UgTm9uZVxuXG5tb2R1bGUgU2xvdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBiYWNrdHJhY2Vfc2xvdFxuICBsZXQgZm9ybWF0ID0gZm9ybWF0X2JhY2t0cmFjZV9zbG90XG4gIGxldCBpc19yYWlzZSA9IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlXG4gIGxldCBpc19pbmxpbmUgPSBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmVcbiAgbGV0IGxvY2F0aW9uID0gYmFja3RyYWNlX3Nsb3RfbG9jYXRpb25cbmVuZFxuXG5leHRlcm5hbCByYXdfYmFja3RyYWNlX2xlbmd0aCA6XG4gIHJhd19iYWNrdHJhY2UgLT4gaW50ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2UgLT4gaW50IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QgOlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gcmF3X2JhY2t0cmFjZV9zbG90IG9wdGlvblxuICA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFwiXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOlxuICAgcmV0dXJucyB0aGUgKnN0cmluZyogY29ycmVzcG9uZGluZyB0byB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgZ2V0X2JhY2t0cmFjZSAoKSA9IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxuZXh0ZXJuYWwgcmVjb3JkX2JhY2t0cmFjZTogYm9vbCAtPiB1bml0ID0gXCJjYW1sX3JlY29yZF9iYWNrdHJhY2VcIlxuZXh0ZXJuYWwgYmFja3RyYWNlX3N0YXR1czogdW5pdCAtPiBib29sID0gXCJjYW1sX2JhY2t0cmFjZV9zdGF0dXNcIlxuXG5sZXQgcmVnaXN0ZXJfcHJpbnRlciBmbiA9XG4gIHByaW50ZXJzIDo9IGZuIDo6ICFwcmludGVyc1xuXG5leHRlcm5hbCBnZXRfY2FsbHN0YWNrOiBpbnQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2tcIlxuXG5sZXQgZXhuX3Nsb3QgeCA9XG4gIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICBpZiBPYmoudGFnIHggPSAwIHRoZW4gT2JqLmZpZWxkIHggMCBlbHNlIHhcblxubGV0IGV4bl9zbG90X2lkIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDEpIDogaW50KVxuXG5sZXQgZXhuX3Nsb3RfbmFtZSB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAwKSA6IHN0cmluZylcblxuXG5sZXQgdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgPSByZWYgTm9uZVxuXG5sZXQgc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGZuID0gdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgOj0gU29tZSBmblxuXG5sZXQgZW1wdHlfYmFja3RyYWNlIDogcmF3X2JhY2t0cmFjZSA9IE9iai5vYmogKE9iai5uZXdfYmxvY2sgT2JqLmFic3RyYWN0X3RhZyAwKVxuXG5sZXQgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpID1cbiAgdHJ5XG4gICAgZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgd2l0aCBfICgqIE91dF9vZl9tZW1vcnk/ICopIC0+XG4gICAgZW1wdHlfYmFja3RyYWNlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgKCogR2V0IHRoZSBiYWNrdHJhY2Ugbm93LCBpbiBjYXNlIG9uZSBvZiB0aGUgW2F0X2V4aXRdIGZ1bmN0aW9uXG4gICAgICAgZGVzdHJveXMgaXQuICopXG4gICAgbGV0IHJhd19iYWNrdHJhY2UgPVxuICAgICAgaWYgZGVidWdnZXJfaW5fdXNlICgqIFNhbWUgdGVzdCBhcyBpbiBbcnVudGltZS9wcmludGV4Yy5jXSAqKSB0aGVuXG4gICAgICAgIGVtcHR5X2JhY2t0cmFjZVxuICAgICAgZWxzZVxuICAgICAgICB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgICBpblxuICAgICh0cnkgU3RkbGliLmRvX2F0X2V4aXQgKCkgd2l0aCBfIC0+ICgpKTtcbiAgICBtYXRjaCAhdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgICAgZmx1c2ggc3RkZXJyXG4gICAgfCBTb21lIGhhbmRsZXIgLT5cbiAgICAgICAgdHJ5XG4gICAgICAgICAgaGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZVxuICAgICAgICB3aXRoIGV4bicgLT5cbiAgICAgICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiAlc1xcblwiICh0b19zdHJpbmcgZXhuKTtcbiAgICAgICAgICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICAgICAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgICAgICh0b19zdHJpbmcgZXhuJyk7XG4gICAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZSc7XG4gICAgICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbcnVudGltZS9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpID0gc3VmZlxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIHIgPSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRNUERJUlwiIHdpdGggTm90X2ZvdW5kIC0+IFwiL3RtcFwiXG4gIGxldCBxdW90ZSA9IGdlbmVyaWNfcXVvdGUgXCInXFxcXCcnXCJcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgcXVvdGUgKGNtZCA6OiBhcmdzKSlcbiAgICBeIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRlcnIgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFwiIDI+JjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGUgZilcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFdpbjMyIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiTlVMXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSByID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVEVNUFwiIHdpdGggTm90X2ZvdW5kIC0+IFwiLlwiXG4gIGxldCBxdW90ZSBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJyBlbHNlXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICdcXFwiJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCBjICAgIC0+IEJ1ZmZlci5hZGRfY2hhciBiIGM7IGxvb3AgKGkrMSk7XG4gICAgYW5kIGxvb3BfYnMgbiBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgICAgICBhZGRfYnMgbjtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICAgfCAnXFxcIicgLT4gYWRkX2JzICgyKm4rMSk7IEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJzsgbG9vcCAoaSsxKTtcbiAgICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAobisxKSAoaSsxKTtcbiAgICAgICAgfCBfICAgIC0+IGFkZF9icyBuOyBsb29wIGlcbiAgICAgIGVuZFxuICAgIGFuZCBhZGRfYnMgbiA9IGZvciBfaiA9IDEgdG8gbiBkbyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcXCc7IGRvbmVcbiAgICBpblxuICAgIGxvb3AgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuKCpcblF1b3RpbmcgY29tbWFuZHMgZm9yIGV4ZWN1dGlvbiBieSBjbWQuZXhlIGlzIGRpZmZpY3VsdC5cbjEtIEVhY2ggYXJndW1lbnQgaXMgZmlyc3QgcXVvdGVkIHVzaW5nIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmUsIHRvXG4gICBwcm90ZWN0IGl0IGFnYWluc3QgdGhlIHByb2Nlc3NpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLFxuICAgdGhlbiBjbWQuZXhlJ3Mgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIHdpdGggJ14nLCB1c2luZ1xuICAgdGhlIFwicXVvdGVfY21kXCIgZnVuY3Rpb24gYmVsb3cuICBGb3IgbW9yZSBkZXRhaWxzLCBzZWVcbiAgIGh0dHBzOi8vYmxvZ3MubXNkbi5taWNyb3NvZnQuY29tL3R3aXN0eWxpdHRsZXBhc3NhZ2VzYWxsYWxpa2UvMjAxMS8wNC8yM1xuMi0gVGhlIGNvbW1hbmQgYW5kIHRoZSByZWRpcmVjdGlvbiBmaWxlcywgaWYgYW55LCBtdXN0IGJlIGRvdWJsZS1xdW90ZWRcbiAgIGluIGNhc2UgdGhleSBjb250YWluIHNwYWNlcy4gIFRoaXMgcXVvdGluZyBpcyBpbnRlcnByZXRlZCBieSBjbWQuZXhlLFxuICAgbm90IGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLCBoZW5jZSB0aGUgXCJxdW90ZVwiIGZ1bmN0aW9uIGFib3ZlXG4gICBjYW5ub3QgYmUgdXNlZC4gIFRoZSB0d28gY2hhcmFjdGVycyB3ZSBkb24ndCBrbm93IGhvdyB0byBxdW90ZVxuICAgaW5zaWRlIGEgZG91YmxlLXF1b3RlZCBjbWQuZXhlIHN0cmluZyBhcmUgZG91YmxlLXF1b3RlIGFuZCBwZXJjZW50LlxuICAgV2UganVzdCBmYWlsIGlmIHRoZSBjb21tYW5kIG5hbWUgb3IgdGhlIHJlZGlyZWN0aW9uIGZpbGUgbmFtZXNcbiAgIGNvbnRhaW4gYSBkb3VibGUgcXVvdGUgKG5vdCBhbGxvd2VkIGluIFdpbmRvd3MgZmlsZSBuYW1lcywgYW55d2F5KVxuICAgb3IgYSBwZXJjZW50LiAgU2VlIGZ1bmN0aW9uIFwicXVvdGVfY21kX2ZpbGVuYW1lXCIgYmVsb3cuXG4zLSBUaGUgd2hvbGUgc3RyaW5nIHBhc3NlZCB0byBTeXMuY29tbWFuZCBpcyB0aGVuIGVuY2xvc2VkIGluIGRvdWJsZVxuICAgcXVvdGVzLCB3aGljaCBhcmUgaW1tZWRpYXRlbHkgc3RyaXBwZWQgYnkgY21kLmV4ZS4gIE90aGVyd2lzZSxcbiAgIHNvbWUgb2YgdGhlIGRvdWJsZSBxdW90ZXMgZnJvbSBzdGVwIDIgYWJvdmUgY2FuIGJlIG1pc3BhcnNlZC5cbiAgIFNlZSBlLmcuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85OTY1MTQxXG4qKVxuICBsZXQgcXVvdGVfY21kIHMgPVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgMjApIGluXG4gICAgU3RyaW5nLml0ZXJcbiAgICAgIChmdW4gYyAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnKCcgfCAnKScgfCAnIScgfCAnXicgfCAnJScgfCAnXFxcIicgfCAnPCcgfCAnPicgfCAnJicgfCAnfCcgLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdeJzsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGMpXG4gICAgICBzO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gIGxldCBxdW90ZV9jbWRfZmlsZW5hbWUgZiA9XG4gICAgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJ1xcXCInIHx8IFN0cmluZy5jb250YWlucyBmICclJyB0aGVuXG4gICAgICBmYWlsd2l0aCAoXCJGaWxlbmFtZS5xdW90ZV9jb21tYW5kOiBiYWQgZmlsZSBuYW1lIFwiIF4gZilcbiAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBmICcgJyB0aGVuXG4gICAgICBcIlxcXCJcIiBeIGYgXiBcIlxcXCJcIlxuICAgIGVsc2VcbiAgICAgIGZcbiAgKCogUmVkaXJlY3Rpb25zIGluIGNtZC5leGU6IHNlZSBodHRwczovL3NzNjQuY29tL250L3N5bnRheC1yZWRpcmVjdGlvbi5odG1sXG4gICAgIGFuZCBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9wcmV2aW91cy12ZXJzaW9ucy93aW5kb3dzL2l0LXByby93aW5kb3dzLXhwL2JiNDkwOTgyKHY9dGVjaG5ldC4xMClcbiAgKilcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIlwiIFtcbiAgICAgIFwiXFxcIlwiO1xuICAgICAgcXVvdGVfY21kX2ZpbGVuYW1lIGNtZDtcbiAgICAgIFwiIFwiO1xuICAgICAgcXVvdGVfY21kIChTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSBhcmdzKSk7XG4gICAgICAobWF0Y2ggc3RkaW4gIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiIDxcIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN0ZGVyciA9IHN0ZG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgXCJcXFwiXCJcbiAgICBdXG4gIGxldCBoYXNfZHJpdmUgcyA9XG4gICAgbGV0IGlzX2xldHRlciA9IGZ1bmN0aW9uXG4gICAgICB8ICdBJyAuLiAnWicgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgU3RyaW5nLmxlbmd0aCBzID49IDIgJiYgaXNfbGV0dGVyIHMuWzBdICYmIHMuWzFdID0gJzonXG4gIGxldCBkcml2ZV9hbmRfcGF0aCBzID1cbiAgICBpZiBoYXNfZHJpdmUgc1xuICAgIHRoZW4gKFN0cmluZy5zdWIgcyAwIDIsIFN0cmluZy5zdWIgcyAyIChTdHJpbmcubGVuZ3RoIHMgLSAyKSlcbiAgICBlbHNlIChcIlwiLCBzKVxuICBsZXQgZGlybmFtZSBzID1cbiAgICBsZXQgKGRyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBsZXQgZGlyID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoIGluXG4gICAgZHJpdmUgXiBkaXJcbiAgbGV0IGJhc2VuYW1lIHMgPVxuICAgIGxldCAoX2RyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoXG5lbmRcblxubW9kdWxlIEN5Z3dpbiA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgPSBXaW4zMi5jaG9wX3N1ZmZpeF9vcHRcbiAgbGV0IHRlbXBfZGlyX25hbWUgPSBVbml4LnRlbXBfZGlyX25hbWVcbiAgbGV0IHF1b3RlID0gVW5peC5xdW90ZVxuICBsZXQgcXVvdGVfY29tbWFuZCA9IFVuaXgucXVvdGVfY29tbWFuZFxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgU3lzZGVwcyA9XG4gICh2YWwgKG1hdGNoIFN5cy5vc190eXBlIHdpdGhcbiAgICAgICB8IFwiV2luMzJcIiAtPiAobW9kdWxlIFdpbjMyOiBTWVNERVBTKVxuICAgICAgIHwgXCJDeWd3aW5cIiAtPiAobW9kdWxlIEN5Z3dpbjogU1lTREVQUylcbiAgICAgICB8IF8gLT4gKG1vZHVsZSBVbml4OiBTWVNERVBTKSkpXG5cbmluY2x1ZGUgU3lzZGVwc1xuXG5sZXQgY29uY2F0IGRpcm5hbWUgZmlsZW5hbWUgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggZGlybmFtZSBpblxuICBpZiBsID0gMCB8fCBpc19kaXJfc2VwIGRpcm5hbWUgKGwtMSlcbiAgdGhlbiBkaXJuYW1lIF4gZmlsZW5hbWVcbiAgZWxzZSBkaXJuYW1lIF4gZGlyX3NlcCBeIGZpbGVuYW1lXG5cbmxldCBjaG9wX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZiBpblxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIG5cblxubGV0IGV4dGVuc2lvbl9sZW4gbmFtZSA9XG4gIGxldCByZWMgY2hlY2sgaTAgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkwIChpIC0gMSlcbiAgICBlbHNlIFN0cmluZy5sZW5ndGggbmFtZSAtIGkwXG4gIGluXG4gIGxldCByZWMgc2VhcmNoX2RvdCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaSAoaSAtIDEpXG4gICAgZWxzZSBzZWFyY2hfZG90IChpIC0gMSlcbiAgaW5cbiAgc2VhcmNoX2RvdCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubGV0IGV4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBcIlwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKSBsXG5cbmxldCBjaG9wX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3BfZXh0ZW5zaW9uXCJcbiAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxubGV0IHJlbW92ZV9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gbmFtZSBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5leHRlcm5hbCBvcGVuX2Rlc2M6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcbmV4dGVybmFsIGNsb3NlX2Rlc2M6IGludCAtPiB1bml0ID0gXCJjYW1sX3N5c19jbG9zZVwiXG5cbmxldCBwcm5nID0gbGF6eShSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQgKCkpXG5cbmxldCB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJuZCA9IChSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSkgbGFuZCAweEZGRkZGRiBpblxuICBjb25jYXQgdGVtcF9kaXIgKFByaW50Zi5zcHJpbnRmIFwiJXMlMDZ4JXNcIiBwcmVmaXggcm5kIHN1ZmZpeClcblxuXG5sZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lID0gcmVmIHRlbXBfZGlyX25hbWVcblxubGV0IHNldF90ZW1wX2Rpcl9uYW1lIHMgPSBjdXJyZW50X3RlbXBfZGlyX25hbWUgOj0gc1xubGV0IGdldF90ZW1wX2Rpcl9uYW1lICgpID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZVxuXG5sZXQgdGVtcF9maWxlID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIGNsb3NlX2Rlc2Mob3Blbl9kZXNjIG5hbWUgW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX2V4Y2xdIDBvNjAwKTtcbiAgICAgIG5hbWVcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcblxubGV0IG9wZW5fdGVtcF9maWxlID8obW9kZSA9IFtPcGVuX3RleHRdKSA/KHBlcm1zID0gMG82MDApXG4gICAgICAgICAgICAgICAgICAgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgKG5hbWUsXG4gICAgICAgb3Blbl9vdXRfZ2VuIChPcGVuX3dyb25seTo6T3Blbl9jcmVhdDo6T3Blbl9leGNsOjptb2RlKSBwZXJtcyBuYW1lKVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDb21wbGV4IG51bWJlcnMgKilcblxudHlwZSB0ID0geyByZTogZmxvYXQ7IGltOiBmbG9hdCB9XG5cbmxldCB6ZXJvID0geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxubGV0IG9uZSA9IHsgcmUgPSAxLjA7IGltID0gMC4wIH1cbmxldCBpID0geyByZSA9IDAuMDsgaW0gPSAxLjAgfVxuXG5sZXQgYWRkIHggeSA9IHsgcmUgPSB4LnJlICsuIHkucmU7IGltID0geC5pbSArLiB5LmltIH1cblxubGV0IHN1YiB4IHkgPSB7IHJlID0geC5yZSAtLiB5LnJlOyBpbSA9IHguaW0gLS4geS5pbSB9XG5cbmxldCBuZWcgeCA9IHsgcmUgPSAtLiB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgY29uaiB4ID0geyByZSA9IHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBtdWwgeCB5ID0geyByZSA9IHgucmUgKi4geS5yZSAtLiB4LmltICouIHkuaW07XG4gICAgICAgICAgICAgICAgaW0gPSB4LnJlICouIHkuaW0gKy4geC5pbSAqLiB5LnJlIH1cblxubGV0IGRpdiB4IHkgPVxuICBpZiBhYnNfZmxvYXQgeS5yZSA+PSBhYnNfZmxvYXQgeS5pbSB0aGVuXG4gICAgbGV0IHIgPSB5LmltIC8uIHkucmUgaW5cbiAgICBsZXQgZCA9IHkucmUgKy4gciAqLiB5LmltIGluXG4gICAgeyByZSA9ICh4LnJlICsuIHIgKi4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHguaW0gLS4gciAqLiB4LnJlKSAvLiBkIH1cbiAgZWxzZVxuICAgIGxldCByID0geS5yZSAvLiB5LmltIGluXG4gICAgbGV0IGQgPSB5LmltICsuIHIgKi4geS5yZSBpblxuICAgIHsgcmUgPSAociAqLiB4LnJlICsuIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9IChyICouIHguaW0gLS4geC5yZSkgLy4gZCB9XG5cbmxldCBpbnYgeCA9IGRpdiBvbmUgeFxuXG5sZXQgbm9ybTIgeCA9IHgucmUgKi4geC5yZSArLiB4LmltICouIHguaW1cblxubGV0IG5vcm0geCA9XG4gICgqIFdhdGNoIG91dCBmb3Igb3ZlcmZsb3cgaW4gY29tcHV0aW5nIHJlXjIgKyBpbV4yICopXG4gIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICBpZiByID0gMC4wIHRoZW4gaVxuICBlbHNlIGlmIGkgPSAwLjAgdGhlbiByXG4gIGVsc2UgaWYgciA+PSBpIHRoZW5cbiAgICBsZXQgcSA9IGkgLy4gciBpbiByICouIHNxcnQoMS4wICsuIHEgKi4gcSlcbiAgZWxzZVxuICAgIGxldCBxID0gciAvLiBpIGluIGkgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuXG5sZXQgYXJnIHggPSBhdGFuMiB4LmltIHgucmVcblxubGV0IHBvbGFyIG4gYSA9IHsgcmUgPSBjb3MgYSAqLiBuOyBpbSA9IHNpbiBhICouIG4gfVxuXG5sZXQgc3FydCB4ID1cbiAgaWYgeC5yZSA9IDAuMCAmJiB4LmltID0gMC4wIHRoZW4geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gICAgbGV0IHcgPVxuICAgICAgaWYgciA+PSBpIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHEgPSBpIC8uIHIgaW5cbiAgICAgICAgc3FydChyKSAqLiBzcXJ0KDAuNSAqLiAoMS4wICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IHEgPSByIC8uIGkgaW5cbiAgICAgICAgc3FydChpKSAqLiBzcXJ0KDAuNSAqLiAocSArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBpblxuICAgIGlmIHgucmUgPj0gMC4wXG4gICAgdGhlbiB7IHJlID0gdzsgIGltID0gMC41ICouIHguaW0gLy4gdyB9XG4gICAgZWxzZSB7IHJlID0gMC41ICouIGkgLy4gdzsgIGltID0gaWYgeC5pbSA+PSAwLjAgdGhlbiB3IGVsc2UgLS4gdyB9XG4gIGVuZFxuXG5sZXQgZXhwIHggPVxuICBsZXQgZSA9IGV4cCB4LnJlIGluIHsgcmUgPSBlICouIGNvcyB4LmltOyBpbSA9IGUgKi4gc2luIHguaW0gfVxuXG5sZXQgbG9nIHggPSB7IHJlID0gbG9nIChub3JtIHgpOyBpbSA9IGF0YW4yIHguaW0geC5yZSB9XG5cbmxldCBwb3cgeCB5ID0gZXhwIChtdWwgeSAobG9nIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAgICAgICAoKiAgJSNkIHwgJSNpIHwgJSN1ICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2ZsYWdfY29udiA9XG4gIHwgRmxvYXRfZmxhZ18gICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19wICAgICAgICAgICAgICAgICAgICgqICUrW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcyAgICAgICAgICAgICAgICAgICAoKiAlIFtmZUVnR0ZoSF0gKilcbnR5cGUgZmxvYXRfa2luZF9jb252ID1cbiAgfCBGbG9hdF9mICAgICAgICAgICAgICAgICAgICAgICAgKCogICVmIHwgJStmIHwgJSBmICAqKVxuICB8IEZsb2F0X2UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWUgfCAlK2UgfCAlIGUgICopXG4gIHwgRmxvYXRfRSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRSB8ICUrRSB8ICUgRSAgKilcbiAgfCBGbG9hdF9nICAgICAgICAgICAgICAgICAgICAgICAgKCogICVnIHwgJStnIHwgJSBnICAqKVxuICB8IEZsb2F0X0cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUcgfCAlK0cgfCAlIEcgICopXG4gIHwgRmxvYXRfRiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRiB8ICUrRiB8ICUgRiAgKilcbiAgfCBGbG9hdF9oICAgICAgICAgICAgICAgICAgICAgICAgKCogICVoIHwgJStoIHwgJSBoICAqKVxuICB8IEZsb2F0X0ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUggfCAlK0ggfCAlIEggICopXG4gIHwgRmxvYXRfQ0YgICAgICAgICAgICAgICAgICAgICAgICgqICAlI0Z8ICUrI0Z8ICUgI0YgKilcbnR5cGUgZmxvYXRfY29udiA9IGZsb2F0X2ZsYWdfY29udiAqIGZsb2F0X2tpbmRfY29udlxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4Y2VwdGlvbnMgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICAoKiBmb3IgcnVudGltZS9mYWlsX25hdC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxuXG5sZXQgZmFpbHdpdGggcyA9IHJhaXNlKEZhaWx1cmUgcylcbmxldCBpbnZhbGlkX2FyZyBzID0gcmFpc2UoSW52YWxpZF9hcmd1bWVudCBzKVxuXG5leGNlcHRpb24gRXhpdFxuZXhjZXB0aW9uIE1hdGNoX2ZhaWx1cmUgPSBNYXRjaF9mYWlsdXJlXG5leGNlcHRpb24gQXNzZXJ0X2ZhaWx1cmUgPSBBc3NlcnRfZmFpbHVyZVxuZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgPSBJbnZhbGlkX2FyZ3VtZW50XG5leGNlcHRpb24gRmFpbHVyZSA9IEZhaWx1cmVcbmV4Y2VwdGlvbiBOb3RfZm91bmQgPSBOb3RfZm91bmRcbmV4Y2VwdGlvbiBPdXRfb2ZfbWVtb3J5ID0gT3V0X29mX21lbW9yeVxuZXhjZXB0aW9uIFN0YWNrX292ZXJmbG93ID0gU3RhY2tfb3ZlcmZsb3dcbmV4Y2VwdGlvbiBTeXNfZXJyb3IgPSBTeXNfZXJyb3JcbmV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSA9IEVuZF9vZl9maWxlXG5leGNlcHRpb24gRGl2aXNpb25fYnlfemVybyA9IERpdmlzaW9uX2J5X3plcm9cbmV4Y2VwdGlvbiBTeXNfYmxvY2tlZF9pbyA9IFN5c19ibG9ja2VkX2lvXG5leGNlcHRpb24gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgPSBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuXG4oKiBDb21wb3NpdGlvbiBvcGVyYXRvcnMgKilcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbigqIERlYnVnZ2luZyAqKVxuXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IHJlZiBmbHVzaF9hbGxcblxubGV0IGF0X2V4aXQgZiA9XG4gIGxldCBnID0gIWV4aXRfZnVuY3Rpb24gaW5cbiAgKCogTVBSIzcyNTMsIE1QUiM3Nzk2OiBtYWtlIHN1cmUgXCJmXCIgaXMgZXhlY3V0ZWQgb25seSBvbmNlICopXG4gIGxldCBmX2FscmVhZHlfcmFuID0gcmVmIGZhbHNlIGluXG4gIGV4aXRfZnVuY3Rpb24gOj1cbiAgICAoZnVuICgpIC0+XG4gICAgICBpZiBub3QgIWZfYWxyZWFkeV9yYW4gdGhlbiBiZWdpbiBmX2FscmVhZHlfcmFuIDo9IHRydWU7IGYoKSBlbmQ7XG4gICAgICBnKCkpXG5cbmxldCBkb19hdF9leGl0ICgpID0gKCFleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQmlnYXJyYXkgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCb29sICAgICAgICAgPSBCb29sXG5tb2R1bGUgQnVmZmVyICAgICAgID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgICAgICAgID0gQnl0ZXNcbm1vZHVsZSBCeXRlc0xhYmVscyAgPSBCeXRlc0xhYmVsc1xubW9kdWxlIENhbGxiYWNrICAgICA9IENhbGxiYWNrXG5tb2R1bGUgQ2hhciAgICAgICAgID0gQ2hhclxubW9kdWxlIENvbXBsZXggICAgICA9IENvbXBsZXhcbm1vZHVsZSBEaWdlc3QgICAgICAgPSBEaWdlc3Rcbm1vZHVsZSBFcGhlbWVyb24gICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgPSBGaWxlbmFtZVxubW9kdWxlIEZsb2F0ICAgICAgICA9IEZsb2F0XG5tb2R1bGUgRm9ybWF0ICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgID0gRnVuXG5tb2R1bGUgR2MgICAgICAgICAgID0gR2Ncbm1vZHVsZSBHZW5sZXggICAgICAgPSBHZW5sZXhcbm1vZHVsZSBIYXNodGJsICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW50ICAgICAgICAgID0gSW50XG5tb2R1bGUgSW50MzIgICAgICAgID0gSW50MzJcbm1vZHVsZSBJbnQ2NCAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICA9IExhenlcbm1vZHVsZSBMZXhpbmcgICAgICAgPSBMZXhpbmdcbm1vZHVsZSBMaXN0ICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgID0gTGlzdExhYmVsc1xubW9kdWxlIE1hcCAgICAgICAgICA9IE1hcFxubW9kdWxlIE1hcnNoYWwgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgPSBNb3JlTGFiZWxzXG5tb2R1bGUgTmF0aXZlaW50ICAgID0gTmF0aXZlaW50XG5tb2R1bGUgT2JqICAgICAgICAgID0gT2JqXG5tb2R1bGUgT28gICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgPSBPcHRpb25cbm1vZHVsZSBQYXJzaW5nICAgICAgPSBQYXJzaW5nXG5tb2R1bGUgUGVydmFzaXZlcyAgID0gUGVydmFzaXZlc1xubW9kdWxlIFByaW50ZXhjICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgID0gUHJpbnRmXG5tb2R1bGUgUXVldWUgICAgICAgID0gUXVldWVcbm1vZHVsZSBSYW5kb20gICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgPSBSZXN1bHRcbm1vZHVsZSBTY2FuZiAgICAgICAgPSBTY2FuZlxubW9kdWxlIFNlcSAgICAgICAgICA9IFNlcVxubW9kdWxlIFNldCAgICAgICAgICA9IFNldFxubW9kdWxlIFNwYWNldGltZSAgICA9IFNwYWNldGltZVxubW9kdWxlIFN0YWNrICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgID0gU3RkTGFiZWxzXG5tb2R1bGUgU3RyZWFtICAgICAgID0gU3RyZWFtXG5tb2R1bGUgU3RyaW5nICAgICAgID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nTGFiZWxzID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgID0gU3lzXG5tb2R1bGUgVWNoYXIgICAgICAgID0gVWNoYXJcbm1vZHVsZSBVbml0ICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgID0gV2Vha1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICBOaWNvbGFzIE9qZWRhIEJhciwgTGV4aUZpICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBuZWcgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsIGFkZCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgc3ViIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCBtdWwgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsIGRpdiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgcmVtIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbWEgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbWFfZmxvYXRcIiBcImNhbWxfZm1hXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFicyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuXG5sZXQgemVybyA9IDAuXG5sZXQgb25lID0gMS5cbmxldCBtaW51c19vbmUgPSAtMS5cbmxldCBpbmZpbml0eSA9IFN0ZGxpYi5pbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IFN0ZGxpYi5uZWdfaW5maW5pdHlcbmxldCBuYW4gPSBTdGRsaWIubmFuXG5sZXQgaXNfZmluaXRlICh4OiBmbG9hdCkgPSB4IC0uIHggPSAwLlxubGV0IGlzX2luZmluaXRlICh4OiBmbG9hdCkgPSAxLiAvLiB4ID0gMC5cbmxldCBpc19uYW4gKHg6IGZsb2F0KSA9IHggPD4geFxuXG5sZXQgcGkgPSAweDEuOTIxZmI1NDQ0MmQxOHArMVxubGV0IG1heF9mbG9hdCA9IFN0ZGxpYi5tYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBTdGRsaWIubWluX2Zsb2F0XG5sZXQgZXBzaWxvbiA9IFN0ZGxpYi5lcHNpbG9uX2Zsb2F0XG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nX29wdCA9IFN0ZGxpYi5mbG9hdF9vZl9zdHJpbmdfb3B0XG5sZXQgdG9fc3RyaW5nID0gU3RkbGliLnN0cmluZ19vZl9mbG9hdFxudHlwZSBmcGNsYXNzID0gU3RkbGliLmZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHBvdyA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgID0gXCJjYW1sX2h5cG90X2Zsb2F0XCIgXCJjYW1sX2h5cG90XCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvc2ggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NoX2Zsb2F0XCIgXCJjb3NoXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRydW5jIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdHJ1bmNfZmxvYXRcIiBcImNhbWxfdHJ1bmNcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcm91bmQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9yb3VuZF9mbG9hdFwiIFwiY2FtbF9yb3VuZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG5bQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgaXNfaW50ZWdlciB4ID0geCA9IHRydW5jIHggJiYgaXNfZmluaXRlIHhcblxuZXh0ZXJuYWwgbmV4dF9hZnRlciA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gID0gXCJjYW1sX25leHRhZnRlcl9mbG9hdFwiIFwiY2FtbF9uZXh0YWZ0ZXJcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgc3VjYyB4ID0gbmV4dF9hZnRlciB4IGluZmluaXR5XG5sZXQgcHJlZCB4ID0gbmV4dF9hZnRlciB4IG5lZ19pbmZpbml0eVxuXG5leHRlcm5hbCBjb3B5X3NpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpZ25fYml0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGJvb2xcbiAgPSBcImNhbWxfc2lnbmJpdF9mbG9hdFwiIFwiY2FtbF9zaWduYml0XCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbnR5cGUgdCA9IGZsb2F0XG5leHRlcm5hbCBjb21wYXJlIDogZmxvYXQgLT4gZmxvYXQgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgZXF1YWwgeCB5ID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldFtAaW5saW5lXSBtaW4gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heCAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB8fCBpc19uYW4geSB0aGVuIChuYW4sIG5hbilcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgsIHkpIGVsc2UgKHksIHgpXG5cbmxldFtAaW5saW5lXSBtaW5fbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiBpc19uYW4geCB0aGVuICh5LHkpXG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiAoeCx4KVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCx5KSBlbHNlICh5LHgpXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiBpbnQgLT4gZmxvYXQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5cbm1vZHVsZSBBcnJheSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IGZsb2F0YXJyYXlcblxuICBleHRlcm5hbCBsZW5ndGggOiB0IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcblxuICBsZXQgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHYgPVxuICAgIGZvciBpID0gb2ZzIHRvIG9mcyArIGxlbiAtIDEgZG8gdW5zYWZlX3NldCBhIGkgdiBkb25lXG5cbiAgbGV0IHVuc2FmZV9ibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlbiA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgZHN0IChkb2ZzICsgaSkgKHVuc2FmZV9nZXQgc3JjIChzb2ZzICsgaSkpXG4gICAgZG9uZVxuXG4gIGxldCBjaGVjayBhIG9mcyBsZW4gbXNnID1cbiAgICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzICsgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPiBsZW5ndGggYSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBsZXQgbWFrZSBuIHYgPVxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbiBpblxuICAgIHVuc2FmZV9maWxsIHJlc3VsdCAwIG4gdjtcbiAgICByZXN1bHRcblxuICBsZXQgaW5pdCBsIGYgPVxuICAgIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pbml0XCJcbiAgICBlbHNlXG4gICAgICBsZXQgcmVzID0gY3JlYXRlIGwgaW5cbiAgICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICAgICBkb25lO1xuICAgICAgcmVzXG5cbiAgbGV0IGFwcGVuZCBhMSBhMiA9XG4gICAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gICAgbGV0IGwyID0gbGVuZ3RoIGEyIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgICB1bnNhZmVfYmxpdCBhMSAwIHJlc3VsdCAwIGwxO1xuICAgIHVuc2FmZV9ibGl0IGEyIDAgcmVzdWx0IGwxIGwyO1xuICAgIHJlc3VsdFxuXG4gICgqIG5leHQgMyBmdW5jdGlvbnM6IG1vZGlmaWVkIGNvcHkgb2YgY29kZSBmcm9tIHN0cmluZy5tbCAqKVxuICBsZXQgZW5zdXJlX2dlICh4OmludCkgeSA9XG4gICAgaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuY29uY2F0XCJcblxuICBsZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIGFjYykgYWNjKSB0bFxuXG4gIGxldCBjb25jYXQgbCA9XG4gICAgbGV0IGxlbiA9IHN1bV9sZW5ndGhzIDAgbCBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGwgaSA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IChpID0gbGVuKVxuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBsZXQgaGxlbiA9IGxlbmd0aCBoZCBpblxuICAgICAgICB1bnNhZmVfYmxpdCBoZCAwIHJlc3VsdCBpIGhsZW47XG4gICAgICAgIGxvb3AgdGwgKGkgKyBobGVuKVxuICAgIGluXG4gICAgbG9vcCBsIDA7XG4gICAgcmVzdWx0XG5cbiAgbGV0IHN1YiBhIG9mcyBsZW4gPVxuICAgIGNoZWNrIGEgb2ZzIGxlbiBcIkZsb2F0LkFycmF5LnN1YlwiO1xuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgYSBvZnMgcmVzdWx0IDAgbGVuO1xuICAgIHJlc3VsdFxuXG4gIGxldCBjb3B5IGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIGwgaW5cbiAgICB1bnNhZmVfYmxpdCBhIDAgcmVzdWx0IDAgbDtcbiAgICByZXN1bHRcblxuICBsZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuZmlsbFwiO1xuICAgIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbiAgbGV0IGJsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuID1cbiAgICBjaGVjayBzcmMgc29mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgY2hlY2sgZHN0IGRvZnMgbGVuIFwiRmxvYXQuYXJyYXkuYmxpdFwiO1xuICAgIHVuc2FmZV9ibGl0IHNyYyBzb2ZzIGRzdCBkb2ZzIGxlblxuXG4gIGxldCB0b19saXN0IGEgPVxuICAgIExpc3QuaW5pdCAobGVuZ3RoIGEpICh1bnNhZmVfZ2V0IGEpXG5cbiAgbGV0IG9mX2xpc3QgbCA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSAoTGlzdC5sZW5ndGggbCkgaW5cbiAgICBsZXQgcmVjIGZpbGwgaSBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiByZXN1bHRcbiAgICAgIHwgaCA6OiB0IC0+IHVuc2FmZV9zZXQgcmVzdWx0IGkgaDsgZmlsbCAoaSArIDEpIHRcbiAgICBpblxuICAgIGZpbGwgMCBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyIGYgYSA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcjIgZiBhIGIgPVxuICAgIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxuICBsZXQgbWFwIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgbGV0IG1hcDIgZiBhIGIgPVxuICAgIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgaXRlcmkgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuICBsZXQgbWFwaSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICAgIGxldCByID0gcmVmIHggaW5cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICAgIGxldCByID0gcmVmIHggaW5cbiAgICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgICBkb25lO1xuICAgICFyXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBleGlzdHMgcCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKSBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9yX2FsbCBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoaSArIDEpXG4gICAgICBlbHNlIGZhbHNlIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBtZW0geCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEgaSkgeCA9IDAgdGhlbiB0cnVlXG4gICAgICBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cbiAgKCogbW9zdGx5IGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgYnV0IHNsaWdodGx5IGRpZmZlcmVudCAqKVxuICBsZXQgbWVtX2llZWUgeCBhID1cbiAgICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgICAgZWxzZSBpZiB4ID0gKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbiAgbGV0IHNvcnQgY21wIGEgPVxuICAgIGxldCBtYXhzb24gbCBpID1cbiAgICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgICBsZXQgeCA9IHJlZiBpMzEgaW5cbiAgICAgIGlmIGkzMSsyIDwgbCB0aGVuIGJlZ2luXG4gICAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgICAgaWYgY21wIChnZXQgYSAheCkgKGdldCBhIChpMzErMikpIDwgMCB0aGVuIHggOj0gaTMxKzI7XG4gICAgICAgICF4XG4gICAgICBlbmQgZWxzZVxuICAgICAgICBpZiBpMzErMSA8IGwgJiYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDBcbiAgICAgICAgdGhlbiBpMzErMVxuICAgICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gICAgaW5cbiAgICBsZXQgcmVjIHRyaWNrbGVkb3duIGwgaSBlID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgaWYgY21wIChnZXQgYSBqKSBlID4gMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBhIGkgZTtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCB0cmlja2xlIGwgaSBlID0gdHJ5IHRyaWNrbGVkb3duIGwgaSBlIHdpdGggQm90dG9tIGkgLT4gc2V0IGEgaSBlIGluXG4gICAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGopO1xuICAgICAgYnViYmxlZG93biBsIGpcbiAgICBpblxuICAgIGxldCBidWJibGUgbCBpID0gdHJ5IGJ1YmJsZWRvd24gbCBpIHdpdGggQm90dG9tIGkgLT4gaSBpblxuICAgIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgICBsZXQgZmF0aGVyID0gKGkgLSAxKSAvIDMgaW5cbiAgICAgIGFzc2VydCAoaSA8PiBmYXRoZXIpO1xuICAgICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgZmF0aGVyKTtcbiAgICAgICAgaWYgZmF0aGVyID4gMCB0aGVuIHRyaWNrbGV1cCBmYXRoZXIgZSBlbHNlIHNldCBhIDAgZTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldCBhIGkgZTtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBmb3IgaSA9IChsICsgMSkgLyAzIC0gMSBkb3dudG8gMCBkbyB0cmlja2xlIGwgaSAoZ2V0IGEgaSk7IGRvbmU7XG4gICAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgICAgbGV0IGUgPSAoZ2V0IGEgaSkgaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIDApO1xuICAgICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICAgIGRvbmU7XG4gICAgaWYgbCA+IDEgdGhlbiAobGV0IGUgPSAoZ2V0IGEgMSkgaW4gc2V0IGEgMSAoZ2V0IGEgMCk7IHNldCBhIDAgZSlcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwsIGV4Y2VwdCBmb3IgdGhlIGNhbGwgdG8gW2NyZWF0ZV0gKilcbiAgbGV0IGN1dG9mZiA9IDVcbiAgbGV0IHN0YWJsZV9zb3J0IGNtcCBhID1cbiAgICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgICAgbGV0IHNyYzFyID0gc3JjMW9mcyArIHNyYzFsZW4gYW5kIHNyYzJyID0gc3JjMm9mcyArIHNyYzJsZW4gaW5cbiAgICAgIGxldCByZWMgbG9vcCBpMSBzMSBpMiBzMiBkID1cbiAgICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICAgIHNldCBkc3QgZCBzMTtcbiAgICAgICAgICBsZXQgaTEgPSBpMSArIDEgaW5cbiAgICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICAgIGxvb3AgaTEgKGdldCBhIGkxKSBpMiBzMiAoZCArIDEpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgIHNldCBkc3QgZCBzMjtcbiAgICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgICBpZiBpMiA8IHNyYzJyIHRoZW5cbiAgICAgICAgICAgIGxvb3AgaTEgczEgaTIgKGdldCBzcmMyIGkyKSAoZCArIDEpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYmxpdCBhIGkxIGRzdCAoZCArIDEpIChzcmMxciAtIGkxKVxuICAgICAgICBlbmRcbiAgICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICAgIGluXG4gICAgbGV0IGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGxldCBlID0gKGdldCBhIChzcmNvZnMgKyBpKSkgaW5cbiAgICAgICAgbGV0IGogPSByZWYgKGRzdG9mcyArIGkgLSAxKSBpblxuICAgICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgICAgc2V0IGRzdCAoIWogKyAxKSAoZ2V0IGRzdCAhaik7XG4gICAgICAgICAgZGVjciBqO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXQgZHN0ICghaiArIDEpIGU7XG4gICAgICBkb25lO1xuICAgIGluXG4gICAgbGV0IHJlYyBzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICAgIGlmIGxlbiA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiBlbHNlIGJlZ2luXG4gICAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgICAgbGV0IGwyID0gbGVuIC0gbDEgaW5cbiAgICAgICAgc29ydHRvIChzcmNvZnMgKyBsMSkgZHN0IChkc3RvZnMgKyBsMSkgbDI7XG4gICAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgICBtZXJnZSAoc3Jjb2ZzICsgbDIpIGwxIGRzdCAoZHN0b2ZzICsgbDEpIGwyIGRzdCBkc3RvZnM7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgaWYgbCA8PSBjdXRvZmYgdGhlbiBpc29ydHRvIDAgYSAwIGwgZWxzZSBiZWdpblxuICAgICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGwgLSBsMSBpblxuICAgICAgbGV0IHQgPSBjcmVhdGUgbDIgaW5cbiAgICAgIHNvcnR0byBsMSB0IDAgbDI7XG4gICAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgICAgbWVyZ2UgbDIgbDEgdCAwIGwyIGEgMDtcbiAgICBlbmRcblxuICBsZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcSBhID1cbiAgICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAgIGlmIGkgPCBsZW5ndGggYVxuICAgICAgdGhlblxuICAgICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gICAgICBlbHNlIFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCB0b19zZXFpIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgICBlbHNlIFNlcS5OaWxcbiAgICBpblxuICAgIGF1eCAwXG5cbiAgKCogbW9zdGx5IGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgb2ZfcmV2X2xpc3QgbCA9XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgIFtdIC0+IGFcbiAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgaW5cbiAgICBmaWxsIChsZW4tMSkgbFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgb2Zfc2VxIGkgPVxuICAgIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICAgIG9mX3Jldl9saXN0IGxcblxuXG4gIGxldCBtYXBfdG9fYXJyYXkgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgaWYgbCA9IDAgdGhlbiBbfCB8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IEFycmF5Lm1ha2UgbCAoZiAodW5zYWZlX2dldCBhIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuXG4gIGxldCBtYXBfZnJvbV9hcnJheSBmIGEgPVxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiAoQXJyYXkudW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuXG5lbmRcblxubW9kdWxlIEFycmF5TGFiZWxzID0gQXJyYXlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtOYXRpdmVpbnRdOiBwcm9jZXNzb3ItbmF0aXZlIGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZzogbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9uZWdcIlxuZXh0ZXJuYWwgYWRkOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hZGRcIlxuZXh0ZXJuYWwgc3ViOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9zdWJcIlxuZXh0ZXJuYWwgbXVsOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tdWxcIlxuZXh0ZXJuYWwgZGl2OiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9kaXZcIlxuZXh0ZXJuYWwgcmVtOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3I6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29yXCJcbmV4dGVybmFsIGxvZ3hvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQ6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzbFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWw6IG5hdGl2ZWludCAtPiBpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2xzclwiXG5leHRlcm5hbCBvZl9pbnQ6IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludDogbmF0aXZlaW50IC0+IGludCA9IFwiJW5hdGl2ZWludF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF9vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRvX2Zsb2F0IDogbmF0aXZlaW50IC0+IGZsb2F0XG4gID0gXCJjYW1sX25hdGl2ZWludF90b19mbG9hdFwiIFwiY2FtbF9uYXRpdmVpbnRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBvZl9pbnQzMjogaW50MzIgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyOiBuYXRpdmVpbnQgLT4gaW50MzIgPSBcIiVuYXRpdmVpbnRfdG9faW50MzJcIlxuXG5sZXQgemVybyA9IDBuXG5sZXQgb25lID0gMW5cbmxldCBtaW51c19vbmUgPSAtMW5cbmxldCBzdWNjIG4gPSBhZGQgbiAxblxubGV0IHByZWQgbiA9IHN1YiBuIDFuXG5sZXQgYWJzIG4gPSBpZiBuID49IDBuIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgc2l6ZSA9IFN5cy53b3JkX3NpemVcbmxldCBtaW5faW50ID0gc2hpZnRfbGVmdCAxbiAoc2l6ZSAtIDEpXG5sZXQgbWF4X2ludCA9IHN1YiBtaW5faW50IDFuXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFuKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZyA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmc6IHN0cmluZyAtPiBuYXRpdmVpbnQgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBuYXRpdmVpbnRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBsaXN0cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGxpc3QgPSBbXSB8ICg6Oikgb2YgJ2EgKiAnYSBsaXN0XG5cbigqIExpc3Qgb3BlcmF0aW9ucyAqKVxuXG5sZXQgcmVjIGxlbmd0aF9hdXggbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBsZW5cbiAgfCBfOjpsIC0+IGxlbmd0aF9hdXggKGxlbiArIDEpIGxcblxubGV0IGxlbmd0aCBsID0gbGVuZ3RoX2F1eCAwIGxcblxubGV0IGNvbnMgYSBsID0gYTo6bFxuXG5sZXQgaGQgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwiaGRcIlxuICB8IGE6Ol8gLT4gYVxuXG5sZXQgdGwgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhaWx3aXRoIFwidGxcIlxuICB8IF86OmwgLT4gbFxuXG5sZXQgbnRoIGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBmYWlsd2l0aCBcIm50aFwiXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgbnRoX29wdCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIFNvbWUgYSBlbHNlIG50aF9hdXggbCAobi0xKVxuICBpbiBudGhfYXV4IGwgblxuXG5sZXQgYXBwZW5kID0gKEApXG5cbmxldCByZWMgcmV2X2FwcGVuZCBsMSBsMiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgICBbXSAtPiBsMlxuICB8IGEgOjogbCAtPiByZXZfYXBwZW5kIGwgKGEgOjogbDIpXG5cbmxldCByZXYgbCA9IHJldl9hcHBlbmQgbCBbXVxuXG5sZXQgcmVjIGluaXRfdGFpbHJlY19hdXggYWNjIGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gYWNjXG4gIGVsc2UgaW5pdF90YWlscmVjX2F1eCAoZiBpIDo6IGFjYykgKGkrMSkgbiBmXG5cbmxldCByZWMgaW5pdF9hdXggaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBbXVxuICBlbHNlXG4gICAgbGV0IHIgPSBmIGkgaW5cbiAgICByIDo6IGluaXRfYXV4IChpKzEpIG4gZlxuXG5sZXQgcmV2X2luaXRfdGhyZXNob2xkID1cbiAgbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gIHwgU3lzLk5hdGl2ZSB8IFN5cy5CeXRlY29kZSAtPiAxMF8wMDBcbiAgKCogV2UgZG9uJ3Qga25vdyB0aGUgc2l6ZSBvZiB0aGUgc3RhY2ssIGJldHRlciBiZSBzYWZlIGFuZCBhc3N1bWUgaXQnc1xuICAgICBzbWFsbC4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuXG5sZXQgaW5pdCBsZW4gZiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QuaW5pdFwiIGVsc2VcbiAgaWYgbGVuID4gcmV2X2luaXRfdGhyZXNob2xkIHRoZW4gcmV2IChpbml0X3RhaWxyZWNfYXV4IFtdIDAgbGVuIGYpXG4gIGVsc2UgaW5pdF9hdXggMCBsZW4gZlxuXG5sZXQgcmVjIGZsYXR0ZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgbDo6ciAtPiBsIEAgZmxhdHRlbiByXG5cbmxldCBjb25jYXQgPSBmbGF0dGVuXG5cbmxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgYSBpbiByIDo6IG1hcCBmIGxcblxubGV0IHJlYyBtYXBpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBpIGEgaW4gciA6OiBtYXBpIChpICsgMSkgZiBsXG5cbmxldCBtYXBpIGYgbCA9IG1hcGkgMCBmIGxcblxubGV0IHJldl9tYXAgZiBsID1cbiAgbGV0IHJlYyBybWFwX2YgYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBhOjpsIC0+IHJtYXBfZiAoZiBhIDo6IGFjY3UpIGxcbiAgaW5cbiAgcm1hcF9mIFtdIGxcblxuXG5sZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgYTsgaXRlciBmIGxcblxubGV0IHJlYyBpdGVyaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGkgYTsgaXRlcmkgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpIGYgbCA9IGl0ZXJpIDAgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0IGYgYWNjdSBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZm9sZF9sZWZ0IGYgKGYgYWNjdSBhKSBsXG5cbmxldCByZWMgZm9sZF9yaWdodCBmIGwgYWNjdSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGYgYSAoZm9sZF9yaWdodCBmIGwgYWNjdSlcblxubGV0IHJlYyBtYXAyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gW11cbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGxldCByID0gZiBhMSBhMiBpbiByIDo6IG1hcDIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QubWFwMlwiXG5cbmxldCByZXZfbWFwMiBmIGwxIGwyID1cbiAgbGV0IHJlYyBybWFwMl9mIGFjY3UgbDEgbDIgPVxuICAgIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICB8IChbXSwgW10pIC0+IGFjY3VcbiAgICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcm1hcDJfZiAoZiBhMSBhMiA6OiBhY2N1KSBsMSBsMlxuICAgIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZXZfbWFwMlwiXG4gIGluXG4gIHJtYXAyX2YgW10gbDEgbDJcblxuXG5sZXQgcmVjIGl0ZXIyIGYgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gKClcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTI7IGl0ZXIyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lml0ZXIyXCJcblxubGV0IHJlYyBmb2xkX2xlZnQyIGYgYWNjdSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmb2xkX2xlZnQyIGYgKGYgYWNjdSBhMSBhMikgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfbGVmdDJcIlxuXG5sZXQgcmVjIGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBhY2N1XG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyIChmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UpXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX3JpZ2h0MlwiXG5cbmxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiB0cnVlXG4gIHwgYTo6bCAtPiBwIGEgJiYgZm9yX2FsbCBwIGxcblxubGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IHAgYSB8fCBleGlzdHMgcCBsXG5cbmxldCByZWMgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiB0cnVlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyICYmIGZvcl9hbGwyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvcl9hbGwyXCJcblxubGV0IHJlYyBleGlzdHMyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gZmFsc2VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgfHwgZXhpc3RzMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5leGlzdHMyXCJcblxubGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW0geCBsXG5cbmxldCByZWMgbWVtcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gYSA9PSB4IHx8IG1lbXEgeCBsXG5cbmxldCByZWMgYXNzb2MgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gYiBlbHNlIGFzc29jIHggbFxuXG5sZXQgcmVjIGFzc29jX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gU29tZSBiIGVsc2UgYXNzb2Nfb3B0IHggbFxuXG5sZXQgcmVjIGFzc3EgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gYiBlbHNlIGFzc3EgeCBsXG5cbmxldCByZWMgYXNzcV9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIFNvbWUgYiBlbHNlIGFzc3Ffb3B0IHggbFxuXG5sZXQgcmVjIG1lbV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGNvbXBhcmUgYSB4ID0gMCB8fCBtZW1fYXNzb2MgeCBsXG5cbmxldCByZWMgbWVtX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBhID09IHggfHwgbWVtX2Fzc3EgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPlxuICAgICAgaWYgY29tcGFyZSBhIHggPSAwIHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc29jIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IFtdXG4gIHwgKGEsIF8gYXMgcGFpcikgOjogbCAtPiBpZiBhID09IHggdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzcSB4IGxcblxubGV0IHJlYyBmaW5kIHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiB4IGVsc2UgZmluZCBwIGxcblxubGV0IHJlYyBmaW5kX29wdCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIFNvbWUgeCBlbHNlIGZpbmRfb3B0IHAgbFxuXG5sZXQgcmVjIGZpbmRfbWFwIGYgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZiB4IHdpdGhcbiAgICAgICB8IFNvbWUgXyBhcyByZXN1bHQgLT4gcmVzdWx0XG4gICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIGYgbFxuICAgICBlbmRcblxubGV0IGZpbmRfYWxsIHAgPVxuICBsZXQgcmVjIGZpbmQgYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY3VcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gZmluZCAoeCA6OiBhY2N1KSBsIGVsc2UgZmluZCBhY2N1IGwgaW5cbiAgZmluZCBbXVxuXG5sZXQgZmlsdGVyID0gZmluZF9hbGxcblxubGV0IGZpbHRlcl9tYXAgZiA9XG4gIGxldCByZWMgYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gYXV4IGFjY3UgbFxuICAgICAgICB8IFNvbWUgdiAtPiBhdXggKHYgOjogYWNjdSkgbFxuICBpblxuICBhdXggW11cblxubGV0IGNvbmNhdF9tYXAgZiBsID1cbiAgbGV0IHJlYyBhdXggZiBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgbGV0IHhzID0gZiB4IGluXG4gICAgICAgYXV4IGYgKHJldl9hcHBlbmQgeHMgYWNjKSBsXG4gIGluIGF1eCBmIFtdIGxcblxubGV0IHBhcnRpdGlvbiBwIGwgPVxuICBsZXQgcmVjIHBhcnQgeWVzIG5vID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IHllcywgcmV2IG5vKVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBwYXJ0ICh4IDo6IHllcykgbm8gbCBlbHNlIHBhcnQgeWVzICh4IDo6IG5vKSBsIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcmVjIHNwbGl0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoW10sIFtdKVxuICB8ICh4LHkpOjpsIC0+XG4gICAgICBsZXQgKHJ4LCByeSkgPSBzcGxpdCBsIGluICh4OjpyeCwgeTo6cnkpXG5cbmxldCByZWMgY29tYmluZSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gKGExLCBhMikgOjogY29tYmluZSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuY29tYmluZVwiXG5cbigqKiBzb3J0aW5nICopXG5cbmxldCByZWMgbWVyZ2UgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbDIgLT4gbDJcbiAgfCBsMSwgW10gLT4gbDFcbiAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICB0aGVuIGgxIDo6IG1lcmdlIGNtcCB0MSBsMlxuICAgICAgZWxzZSBoMiA6OiBtZXJnZSBjbXAgbDEgdDJcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgc29ydCA9IHN0YWJsZV9zb3J0XG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCogTm90ZTogb24gYSBsaXN0IG9mIGxlbmd0aCBiZXR3ZWVuIGFib3V0IDEwMDAwMCAoZGVwZW5kaW5nIG9uIHRoZSBtaW5vclxuICAgaGVhcCBzaXplIGFuZCB0aGUgdHlwZSBvZiB0aGUgbGlzdCkgYW5kIFN5cy5tYXhfYXJyYXlfc2l6ZSwgaXQgaXNcbiAgIGFjdHVhbGx5IGZhc3RlciB0byB1c2UgdGhlIGZvbGxvd2luZywgYnV0IGl0IG1pZ2h0IGFsc28gdXNlIG1vcmUgbWVtb3J5XG4gICBiZWNhdXNlIHRoZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBkZWFsbG9jYXRlZCBpbmNyZW1lbnRhbGx5LlxuXG4gICBBbHNvLCB0aGVyZSBzZWVtcyB0byBiZSBhIGJ1ZyBpbiB0aGlzIGNvZGUgb3IgaW4gdGhlXG4gICBpbXBsZW1lbnRhdGlvbiBvZiBvYmpfdHJ1bmNhdGUuXG5cbmV4dGVybmFsIG9ial90cnVuY2F0ZSA6ICdhIGFycmF5IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5cbmxldCBhcnJheV90b19saXN0X2luX3BsYWNlIGEgPVxuICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBhY2N1IG4gcCA9XG4gICAgaWYgcCA8PSAwIHRoZW4gYWNjdSBlbHNlIGJlZ2luXG4gICAgICBpZiBwID0gbiB0aGVuIGJlZ2luXG4gICAgICAgIG9ial90cnVuY2F0ZSBhIHA7XG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgKG4tMTAwMCkgKHAtMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgbiAocC0xKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgW10gKGwtMTAwMCkgbFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCBhID0gQXJyYXkub2ZfbGlzdCBsIGluXG4gIEFycmF5LnN0YWJsZV9zb3J0IGNtcCBhO1xuICBhcnJheV90b19saXN0X2luX3BsYWNlIGFcblxuKilcblxuXG4oKiogc29ydGluZyArIHJlbW92aW5nIGR1cGxpY2F0ZXMgKilcblxubGV0IHNvcnRfdW5pcSBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZSB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGwgPVxuICBsZXQgcmVjIGF1eCBsICgpID0gbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBTZXEuTmlsXG4gICAgfCB4IDo6IHRhaWwgLT4gU2VxLkNvbnMgKHgsIGF1eCB0YWlsKVxuICBpblxuICBhdXggbFxuXG5sZXQgb2Zfc2VxIHNlcSA9XG4gIGxldCByZWMgZGlyZWN0IGRlcHRoIHNlcSA6IF8gbGlzdCA9XG4gICAgaWYgZGVwdGg9MFxuICAgIHRoZW5cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBhY2MgeCAtPiB4OjphY2MpIFtdIHNlcVxuICAgICAgfD4gcmV2ICgqIHRhaWxyZWMgKilcbiAgICBlbHNlIG1hdGNoIHNlcSgpIHdpdGhcbiAgICAgIHwgU2VxLk5pbCAtPiBbXVxuICAgICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT4geCA6OiBkaXJlY3QgKGRlcHRoLTEpIG5leHRcbiAgaW5cbiAgZGlyZWN0IDUwMCBzZXFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICBTaW1vbiBDcnVhbmVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtTZXFdOiBmdW5jdGlvbmFsIGl0ZXJhdG9ycyAqKVxuXG50eXBlICsnYSBub2RlID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZVxuXG5sZXQgZW1wdHkgKCkgPSBOaWxcblxubGV0IHJldHVybiB4ICgpID0gQ29ucyAoeCwgZW1wdHkpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zIChmIHgsIG1hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyX21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgICB8IFNvbWUgeSAtPiBDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXIgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBpZiBmIHhcbiAgICAgIHRoZW4gQ29ucyAoeCwgZmlsdGVyIGYgbmV4dClcbiAgICAgIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbigqIHRoaXMgaXMgW2FwcGVuZCBzZXEgKGZsYXRfbWFwIGYgdGFpbCldICopXG5hbmQgZmxhdF9tYXBfYXBwIGYgc2VxIHRhaWwgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBmbGF0X21hcCBmIHRhaWwgKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIENvbnMgKHgsIGZsYXRfbWFwX2FwcCBmIG5leHQgdGFpbClcblxubGV0IGZvbGRfbGVmdCBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+IGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBvcHRpb24gPSBOb25lIHwgU29tZSBvZiAnYVxuXG5sZXQgbm9uZSA9IE5vbmVcbmxldCBzb21lIHYgPSBTb21lIHZcbmxldCB2YWx1ZSBvIH5kZWZhdWx0ID0gbWF0Y2ggbyB3aXRoIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBkZWZhdWx0XG5sZXQgZ2V0ID0gZnVuY3Rpb24gU29tZSB2IC0+IHYgfCBOb25lIC0+IGludmFsaWRfYXJnIFwib3B0aW9uIGlzIE5vbmVcIlxubGV0IGJpbmQgbyBmID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBmIHZcbmxldCBqb2luID0gZnVuY3Rpb24gU29tZSBvIC0+IG8gfCBOb25lIC0+IE5vbmVcbmxldCBtYXAgZiBvID0gbWF0Y2ggbyB3aXRoIE5vbmUgLT4gTm9uZSB8IFNvbWUgdiAtPiBTb21lIChmIHYpXG5sZXQgZm9sZCB+bm9uZSB+c29tZSA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBzb21lIHYgfCBOb25lIC0+IG5vbmVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBTb21lIHYgLT4gZiB2IHwgTm9uZSAtPiAoKVxubGV0IGlzX25vbmUgPSBmdW5jdGlvbiBOb25lIC0+IHRydWUgfCBTb21lIF8gLT4gZmFsc2VcbmxldCBpc19zb21lID0gZnVuY3Rpb24gTm9uZSAtPiBmYWxzZSB8IFNvbWUgXyAtPiB0cnVlXG5cbmxldCBlcXVhbCBlcSBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gZXEgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiB0cnVlXG58IF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgY21wIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBjbXAgdjAgdjFcbnwgTm9uZSwgTm9uZSAtPiAwXG58IE5vbmUsIFNvbWUgXyAtPiAtMVxufCBTb21lIF8sIE5vbmUgLT4gMVxuXG5sZXQgdG9fcmVzdWx0IH5ub25lID0gZnVuY3Rpb24gTm9uZSAtPiBFcnJvciBub25lIHwgU29tZSB2IC0+IE9rIHZcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gTm9uZSAtPiBbXSB8IFNvbWUgdiAtPiBbdl1cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBOb25lIC0+IFNlcS5lbXB0eSB8IFNvbWUgdiAtPiBTZXEucmV0dXJuIHZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSkgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnZVxuXG5sZXQgb2sgdiA9IE9rIHZcbmxldCBlcnJvciBlID0gRXJyb3IgZVxubGV0IHZhbHVlIHIgfmRlZmF1bHQgPSBtYXRjaCByIHdpdGggT2sgdiAtPiB2IHwgRXJyb3IgXyAtPiBkZWZhdWx0XG5sZXQgZ2V0X29rID0gZnVuY3Rpb24gT2sgdiAtPiB2IHwgRXJyb3IgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBFcnJvciBfXCJcbmxldCBnZXRfZXJyb3IgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGUgfCBPayBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIE9rIF9cIlxubGV0IGJpbmQgciBmID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBqb2luID0gZnVuY3Rpb24gT2sgciAtPiByIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXAgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gT2sgKGYgdikgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcF9lcnJvciBmID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBFcnJvciAoZiBlKSB8IE9rIF8gYXMgdiAtPiB2XG5sZXQgZm9sZCB+b2sgfmVycm9yID0gZnVuY3Rpb24gT2sgdiAtPiBvayB2IHwgRXJyb3IgZSAtPiBlcnJvciBlXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gT2sgdiAtPiBmIHYgfCBFcnJvciBfIC0+ICgpXG5sZXQgaXRlcl9lcnJvciBmID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBmIGUgfCBPayBfIC0+ICgpXG5sZXQgaXNfb2sgPSBmdW5jdGlvbiBPayBfIC0+IHRydWUgfCBFcnJvciBfIC0+IGZhbHNlXG5sZXQgaXNfZXJyb3IgPSBmdW5jdGlvbiBFcnJvciBfIC0+IHRydWUgfCBPayBfIC0+IGZhbHNlXG5cbmxldCBlcXVhbCB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBfLCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IE9rIF8sIEVycm9yIF8gLT4gLTFcbnwgRXJyb3IgXywgT2sgXyAtPiAxXG5cbmxldCB0b19vcHRpb24gPSBmdW5jdGlvbiBPayB2IC0+IFNvbWUgdiB8IEVycm9yIF8gLT4gTm9uZVxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBPayB2IC0+IFt2XSB8IEVycm9yIF8gLT4gW11cbmxldCB0b19zZXEgPSBmdW5jdGlvbiBPayB2IC0+IFNlcS5yZXR1cm4gdiB8IEVycm9yIF8gLT4gU2VxLmVtcHR5XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGJvb2wgPSBmYWxzZSB8IHRydWVcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxubGV0IGVxdWFsIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBib29sIC0+IGJvb2wgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCB0b19pbnQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwIHwgdHJ1ZSAtPiAxXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwLiB8IHRydWUgLT4gMS5cblxuKCpcbmxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxufCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxufCBcInRydWVcIiAtPiBTb21lIHRydWVcbnwgXyAtPiBOb25lXG4qKVxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb24gZmFsc2UgLT4gXCJmYWxzZVwiIHwgdHJ1ZSAtPiBcInRydWVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSBjID1cbiAgaWYgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKVxuICB8fCAoYyA+PSAnXFwxOTInICYmIGMgPD0gJ1xcMjE0JylcbiAgfHwgKGMgPj0gJ1xcMjE2JyAmJiBjIDw9ICdcXDIyMicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2UgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgfHwgKGMgPj0gJ1xcMjI0JyAmJiBjIDw9ICdcXDI0NicpXG4gIHx8IChjID49ICdcXDI0OCcgJiYgYyA8PSAnXFwyNTQnKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIGVsc2UgY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpIGMgPVxuICBpZiAoYyA+PSAnQScgJiYgYyA8PSAnWicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgZWxzZSBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgYyA9XG4gIGlmIChjID49ICdhJyAmJiBjIDw9ICd6JylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICBlbHNlIGNcblxudHlwZSB0ID0gY2hhclxuXG5sZXQgY29tcGFyZSBjMSBjMiA9IGNvZGUgYzEgLSBjb2RlIGMyXG5sZXQgZXF1YWwgKGMxOiB0KSAoYzI6IHQpID0gY29tcGFyZSBjMSBjMiA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gc3RyaW5nLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gYnl0ZXMgPSBcIiVieXRlc19vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubGV0IG1ha2UgbiBjID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICB1bnNhZmVfZmlsbCBzIDAgbiBjO1xuICBzXG5cbmxldCBpbml0IG4gZiA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCBzIGkgKGYgaSlcbiAgZG9uZTtcbiAgc1xuXG5sZXQgZW1wdHkgPSBjcmVhdGUgMFxuXG5sZXQgY29weSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICB1bnNhZmVfYmxpdCBzIDAgciAwIGxlbjtcbiAgclxuXG5sZXQgdG9fc3RyaW5nIGIgPSB1bnNhZmVfdG9fc3RyaW5nIChjb3B5IGIpXG5sZXQgb2Zfc3RyaW5nIHMgPSBjb3B5ICh1bnNhZmVfb2Zfc3RyaW5nIHMpXG5cbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuc3ViIC8gQnl0ZXMuc3ViXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGxlbiBpblxuICAgIHVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gICAgclxuICBlbmRcblxubGV0IHN1Yl9zdHJpbmcgYiBvZnMgbGVuID0gdW5zYWZlX3RvX3N0cmluZyAoc3ViIGIgb2ZzIGxlbilcblxuKCogYWRkaXRpb24gd2l0aCBhbiBvdmVyZmxvdyBjaGVjayAqKVxubGV0ICgrKykgYSBiID1cbiAgbGV0IGMgPSBhICsgYiBpblxuICBtYXRjaCBhIDwgMCwgYiA8IDAsIGMgPCAwIHdpdGhcbiAgfCB0cnVlICwgdHJ1ZSAsIGZhbHNlXG4gIHwgZmFsc2UsIGZhbHNlLCB0cnVlICAtPiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmV4dGVuZFwiICgqIG92ZXJmbG93ICopXG4gIHwgXyAtPiBjXG5cbmxldCBleHRlbmQgcyBsZWZ0IHJpZ2h0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzICsrIGxlZnQgKysgcmlnaHQgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIGxldCAoc3Jjb2ZmLCBkc3RvZmYpID0gaWYgbGVmdCA8IDAgdGhlbiAtbGVmdCwgMCBlbHNlIDAsIGxlZnQgaW5cbiAgbGV0IGNweWxlbiA9IG1pbiAobGVuZ3RoIHMgLSBzcmNvZmYpIChsZW4gLSBkc3RvZmYpIGluXG4gIGlmIGNweWxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCBzIHNyY29mZiByIGRzdG9mZiBjcHlsZW47XG4gIHJcblxubGV0IGZpbGwgcyBvZnMgbGVuIGMgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5maWxsIC8gQnl0ZXMuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgcyBvZnMgbGVuIGNcblxubGV0IGJsaXQgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ5dGVzLmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IHMxIG9mczEgczIgb2ZzMiBsZW5cblxubGV0IGJsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBzdHJpbmdfbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmJsaXQgLyBCeXRlcy5ibGl0X3N0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX2JsaXRfc3RyaW5nIHMxIG9mczEgczIgb2ZzMiBsZW5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIkJ5dGVzLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZW1wdHlcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbmxldCBjYXQgczEgczIgPVxuICBsZXQgbDEgPSBsZW5ndGggczEgaW5cbiAgbGV0IGwyID0gbGVuZ3RoIHMyIGluXG4gIGxldCByID0gY3JlYXRlIChsMSArIGwyKSBpblxuICB1bnNhZmVfYmxpdCBzMSAwIHIgMCBsMTtcbiAgdW5zYWZlX2JsaXQgczIgMCByIGwxIGwyO1xuICByXG5cblxuZXh0ZXJuYWwgY2hhcl9jb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGNoYXJfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICBsZXQgaiA9IHJlZiAobGVuIC0gMSkgaW5cbiAgd2hpbGUgIWogPj0gIWkgJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaikgZG9cbiAgICBkZWNyIGpcbiAgZG9uZTtcbiAgaWYgIWogPj0gIWkgdGhlblxuICAgIHN1YiBzICFpICghaiAtICFpICsgMSlcbiAgZWxzZVxuICAgIGVtcHR5XG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICBuIDo9ICFuICtcbiAgICAgIChtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgfCAnICcgLi4gJ34nIC0+IDFcbiAgICAgICB8IF8gLT4gNClcbiAgZG9uZTtcbiAgaWYgIW4gPSBsZW5ndGggcyB0aGVuIGNvcHkgcyBlbHNlIGJlZ2luXG4gICAgbGV0IHMnID0gY3JlYXRlICFuIGluXG4gICAgbiA6PSAwO1xuICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgIGJlZ2luIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdyJ1xuICAgICAgfCAnXFxiJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICB8ICgnICcgLi4gJ34nKSBhcyBjIC0+IHVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgfCBjIC0+XG4gICAgICAgICAgbGV0IGEgPSBjaGFyX2NvZGUgYyBpblxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIC8gMTAwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIChhIC8gMTApIG1vZCAxMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyBhIG1vZCAxMCkpO1xuICAgICAgZW5kO1xuICAgICAgaW5jciBuXG4gICAgZG9uZTtcbiAgICBzJ1xuICBlbmRcblxubGV0IG1hcCBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXBpIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IGFwcGx5MSBmIHMgPVxuICBpZiBsZW5ndGggcyA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNvcHkgcyBpblxuICAgIHVuc2FmZV9zZXQgciAwIChmKHVuc2FmZV9nZXQgcyAwKSk7XG4gICAgclxuICBlbmRcblxubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5leHRlcm5hbCBlcXVhbCA6IHQgLT4gdCAtPiBib29sID0gXCJjYW1sX2J5dGVzX2VxdWFsXCIgW0BAbm9hbGxvY11cblxuKCogRGVwcmVjYXRlZCBmdW5jdGlvbnMgaW1wbGVtZW50ZWQgdmlhIG90aGVyIGRlcHJlY2F0ZWQgZnVuY3Rpb25zICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5sZXQgdXBwZXJjYXNlIHMgPSBtYXAgQ2hhci51cHBlcmNhc2Ugc1xubGV0IGxvd2VyY2FzZSBzID0gbWFwIENoYXIubG93ZXJjYXNlIHNcblxubGV0IGNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgdW5jYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci5sb3dlcmNhc2Ugc1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgbGV0IGJ1ZiA9IHJlZiAobWFrZSAyNTYgJ1xcMDAwJykgaW5cbiAgbGV0IHJlc2l6ZSAoKSA9XG4gICAgKCogcmVzaXplICopXG4gICAgbGV0IG5ld19sZW4gPSBtaW4gKDIgKiBsZW5ndGggIWJ1ZikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgaWYgbGVuZ3RoICFidWYgPSBuZXdfbGVuIHRoZW4gZmFpbHdpdGggXCJCeXRlcy5vZl9zZXE6IGNhbm5vdCBncm93IGJ5dGVzXCI7XG4gICAgbGV0IG5ld19idWYgPSBtYWtlIG5ld19sZW4gJ1xcMDAwJyBpblxuICAgIGJsaXQgIWJ1ZiAwIG5ld19idWYgMCAhbjtcbiAgICBidWYgOj0gbmV3X2J1ZlxuICBpblxuICBTZXEuaXRlclxuICAgIChmdW4gYyAtPlxuICAgICAgIGlmICFuID0gbGVuZ3RoICFidWYgdGhlbiByZXNpemUoKTtcbiAgICAgICBzZXQgIWJ1ZiAhbiBjO1xuICAgICAgIGluY3IgbilcbiAgICBpO1xuICBzdWIgIWJ1ZiAwICFuXG5cbigqKiB7NiBCaW5hcnkgZW5jb2RpbmcvZGVjb2Rpbmcgb2YgaW50ZWdlcnN9ICopXG5cbmV4dGVybmFsIGdldF91aW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBnZXRfdWludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWNhbWxfYnl0ZXNfZ2V0MTZcIlxuZXh0ZXJuYWwgZ2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyID0gXCIlY2FtbF9ieXRlc19nZXQzMlwiXG5leHRlcm5hbCBnZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0XCJcbmV4dGVybmFsIHNldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgc2V0X2ludDE2X25lIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNlwiXG5leHRlcm5hbCBzZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MzJcIlxuZXh0ZXJuYWwgc2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0XCJcbmV4dGVybmFsIHN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcbmV4dGVybmFsIHN3YXAzMiA6IGludDMyIC0+IGludDMyID0gXCIlYnN3YXBfaW50MzJcIlxuZXh0ZXJuYWwgc3dhcDY0IDogaW50NjQgLT4gaW50NjQgPSBcIiVic3dhcF9pbnQ2NFwiXG5cbmxldCBnZXRfaW50OCBiIGkgPVxuICAoKGdldF91aW50OCBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gOCkpIGFzciAoU3lzLmludF9zaXplIC0gOClcblxubGV0IGdldF91aW50MTZfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfdWludDE2X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF9pbnQxNl9uZSBiIGkgPVxuICAoKGdldF91aW50MTZfbmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9sZSBiIGkgPVxuICAoKGdldF91aW50MTZfbGUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQxNl9iZSBiIGkgPVxuICAoKGdldF91aW50MTZfYmUgYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDE2KSkgYXNyIChTeXMuaW50X3NpemUgLSAxNilcblxubGV0IGdldF9pbnQzMl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50MzJfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IHNldF9pbnQxNl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MTZfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9sZSBiIGkgeCA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfYmUgYiBpIHggPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF91aW50OCA9IHNldF9pbnQ4XG5sZXQgc2V0X3VpbnQxNl9uZSA9IHNldF9pbnQxNl9uZVxubGV0IHNldF91aW50MTZfYmUgPSBzZXRfaW50MTZfYmVcbmxldCBzZXRfdWludDE2X2xlID0gc2V0X2ludDE2X2xlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBHYWxsaXVtLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFN0cmluZyBvcGVyYXRpb25zLCBiYXNlZCBvbiBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIGJ5dGVzLm1sLlxuICAgVGhlc2UgZnVuY3Rpb25zIGhhdmUgYSBcImR1cGxpY2F0ZWRcIiBjb21tZW50IGFib3ZlIHRoZWlyIGRlZmluaXRpb24uXG4qKVxuXG5leHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6IHN0cmluZyAtPiBpbnQgLT4gIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5tb2R1bGUgQiA9IEJ5dGVzXG5cbmxldCBidHMgPSBCLnVuc2FmZV90b19zdHJpbmdcbmxldCBib3MgPSBCLnVuc2FmZV9vZl9zdHJpbmdcblxubGV0IG1ha2UgbiBjID1cbiAgQi5tYWtlIG4gYyB8PiBidHNcbmxldCBpbml0IG4gZiA9XG4gIEIuaW5pdCBuIGYgfD4gYnRzXG5sZXQgY29weSBzID1cbiAgQi5jb3B5IChib3MgcykgfD4gYnRzXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIEIuc3ViIChib3Mgcykgb2ZzIGxlbiB8PiBidHNcbmxldCBmaWxsID1cbiAgQi5maWxsXG5sZXQgYmxpdCA9XG4gIEIuYmxpdF9zdHJpbmdcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBcIlwiXG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpbiBidHMgQEBcbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChCLmNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlciBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyaSBmIHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxubGV0IG1hcCBmIHMgPVxuICBCLm1hcCBmIChib3MgcykgfD4gYnRzXG5sZXQgbWFwaSBmIHMgPVxuICBCLm1hcGkgZiAoYm9zIHMpIHw+IGJ0c1xuXG4oKiBCZXdhcmU6IHdlIGNhbm5vdCB1c2UgQi50cmltIG9yIEIuZXNjYXBlIGJlY2F1c2UgdGhleSBhbHdheXMgbWFrZSBhXG4gICBjb3B5LCBidXQgU3RyaW5nLm1saSBzcGVsbHMgb3V0IHNvbWUgY2FzZXMgd2hlcmUgd2UgYXJlIG5vdCBhbGxvd2VkXG4gICB0byBtYWtlIGEgY29weS4gKilcblxubGV0IGlzX3NwYWNlID0gZnVuY3Rpb25cbiAgfCAnICcgfCAnXFwwMTInIHwgJ1xcbicgfCAnXFxyJyB8ICdcXHQnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cbmxldCB0cmltIHMgPVxuICBpZiBzID0gXCJcIiB0aGVuIHNcbiAgZWxzZSBpZiBpc19zcGFjZSAodW5zYWZlX2dldCBzIDApIHx8IGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgKGxlbmd0aCBzIC0gMSkpXG4gICAgdGhlbiBidHMgKEIudHJpbSAoYm9zIHMpKVxuICBlbHNlIHNcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCByZWMgZXNjYXBlX2lmX25lZWRlZCBzIG4gaSA9XG4gICAgaWYgaSA+PSBuIHRoZW4gcyBlbHNlXG4gICAgICBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXDAwMCcuLidcXDAzMScgfCAnXFwxMjcnLi4gJ1xcMjU1JyAtPlxuICAgICAgICAgIGJ0cyAoQi5lc2NhcGVkIChib3MgcykpXG4gICAgICB8IF8gLT4gZXNjYXBlX2lmX25lZWRlZCBzIG4gKGkrMSlcbiAgaW5cbiAgZXNjYXBlX2lmX25lZWRlZCBzIChsZW5ndGggcykgMFxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIGluZGV4X3JlY19vcHQgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgaW5kZXhfcmVjX29wdCBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gICAgaW5kZXhfcmVjIHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9XG4gIEIudXBwZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPVxuICBCLmxvd2VyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi51bmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N0cmluZ19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9XG4gIEIudXBwZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlIHMgPVxuICBCLmxvd2VyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemUgcyA9XG4gIEIuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZSBzID1cbiAgQi51bmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gYm9zIHMgfD4gQi50b19zZXFcblxubGV0IHRvX3NlcWkgcyA9IGJvcyBzIHw+IEIudG9fc2VxaVxuXG5sZXQgb2Zfc2VxIGcgPSBCLm9mX3NlcSBnIHw+IGJ0c1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSB1bml0ID0gKClcblxubGV0IGVxdWFsICgpICgpID0gdHJ1ZVxubGV0IGNvbXBhcmUgKCkgKCkgPSAwXG5sZXQgdG9fc3RyaW5nICgpID0gXCIoKVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgZXh0ZXJuX2ZsYWdzID1cbiAgICBOb19zaGFyaW5nXG4gIHwgQ2xvc3VyZXNcbiAgfCBDb21wYXRfMzJcbigqIG5vdGU6IHRoaXMgdHlwZSBkZWZpbml0aW9uIGlzIHVzZWQgaW4gJ3J1bnRpbWUvZGVidWdnZXIuYycgKilcblxuZXh0ZXJuYWwgdG9fY2hhbm5lbDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gdW5pdFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5leHRlcm5hbCB0b19ieXRlczogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gYnl0ZXNcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXNcIlxuZXh0ZXJuYWwgdG9fc3RyaW5nOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBzdHJpbmdcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHRvX2J1ZmZlcl91bnNhZmU6XG4gICAgICBieXRlcyAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGludFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcIlxuXG5sZXQgdG9fYnVmZmVyIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLnRvX2J1ZmZlcjogc3Vic3RyaW5nIG91dCBvZiBib3VuZHNcIlxuICBlbHNlIHRvX2J1ZmZlcl91bnNhZmUgYnVmZiBvZnMgbGVuIHYgZmxhZ3NcblxuKCogVGhlIGZ1bmN0aW9ucyBiZWxvdyB1c2UgYnl0ZSBzZXF1ZW5jZXMgYXMgaW5wdXQsIG5ldmVyIHVzaW5nIGFueVxuICAgbXV0YXRpb24uIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBub24tbXV0YXRlZCBbYnl0ZXNdIHJhdGhlciB0aGFuXG4gICBbc3RyaW5nXSwgYmVjYXVzZSB3ZSByZWFsbHkgd29yayB3aXRoIHNlcXVlbmNlcyBvZiBieXRlcywgbm90XG4gICBhIHRleHQgcmVwcmVzZW50YXRpb24uXG4qKVxuXG5leHRlcm5hbCBmcm9tX2NoYW5uZWw6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZnJvbV9ieXRlc191bnNhZmU6IGJ5dGVzIC0+IGludCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzXCJcbmV4dGVybmFsIGRhdGFfc2l6ZV91bnNhZmU6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcImNhbWxfbWFyc2hhbF9kYXRhX3NpemVcIlxuXG5sZXQgaGVhZGVyX3NpemUgPSAyMFxubGV0IGRhdGFfc2l6ZSBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5kYXRhX3NpemVcIlxuICBlbHNlIGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnNcbmxldCB0b3RhbF9zaXplIGJ1ZmYgb2ZzID0gaGVhZGVyX3NpemUgKyBkYXRhX3NpemUgYnVmZiBvZnNcblxubGV0IGZyb21fYnl0ZXMgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbGVuID0gZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mcyBpblxuICAgIGlmIG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gKGhlYWRlcl9zaXplICsgbGVuKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICAgIGVsc2UgZnJvbV9ieXRlc191bnNhZmUgYnVmZiBvZnNcbiAgZW5kXG5cbmxldCBmcm9tX3N0cmluZyBidWZmIG9mcyA9XG4gICgqIEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgaXMgc2FmZSBoZXJlLCBhcyB0aGUgcHJvZHVjZWQgYnl0ZVxuICAgICBzZXF1ZW5jZSBpcyBuZXZlciBtdXRhdGVkICopXG4gIGZyb21fYnl0ZXMgKEJ5dGVzLnVuc2FmZV9vZl9zdHJpbmcgYnVmZikgb2ZzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE9wZXJhdGlvbnMgb24gaW50ZXJuYWwgcmVwcmVzZW50YXRpb25zIG9mIHZhbHVlcyAqKVxuXG50eXBlIHRcblxuZXh0ZXJuYWwgcmVwciA6ICdhIC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBvYmogOiB0IC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbWFnaWMgOiAnYSAtPiAnYiA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGlzX2ludCA6IHQgLT4gYm9vbCA9IFwiJW9ial9pc19pbnRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gaXNfYmxvY2sgYSA9IG5vdCAoaXNfaW50IGEpXG5leHRlcm5hbCB0YWcgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfdGFnXCJcbmV4dGVybmFsIHNldF90YWcgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial9zZXRfdGFnXCJcbmV4dGVybmFsIHNpemUgOiB0IC0+IGludCA9IFwiJW9ial9zaXplXCJcbmV4dGVybmFsIHJlYWNoYWJsZV93b3JkcyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial9yZWFjaGFibGVfd29yZHNcIlxuZXh0ZXJuYWwgZmllbGQgOiB0IC0+IGludCAtPiB0ID0gXCIlb2JqX2ZpZWxkXCJcbmV4dGVybmFsIHNldF9maWVsZCA6IHQgLT4gaW50IC0+IHQgLT4gdW5pdCA9IFwiJW9ial9zZXRfZmllbGRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdGFycmF5X2dldFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X3NldCA6XG4gICAgZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiY2FtbF9mbG9hdGFycmF5X3NldFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBkb3VibGVfZmllbGQgeCBpID0gZmxvYXRhcnJheV9nZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaVxubGV0IFtAaW5saW5lIGFsd2F5c10gc2V0X2RvdWJsZV9maWVsZCB4IGkgdiA9XG4gIGZsb2F0YXJyYXlfc2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGkgdlxuZXh0ZXJuYWwgbmV3X2Jsb2NrIDogaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX29ial9ibG9ja1wiXG5leHRlcm5hbCBkdXAgOiB0IC0+IHQgPSBcImNhbWxfb2JqX2R1cFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcbmV4dGVybmFsIGFkZF9vZmZzZXQgOiB0IC0+IEludDMyLnQgLT4gdCA9IFwiY2FtbF9vYmpfYWRkX29mZnNldFwiXG5leHRlcm5hbCB3aXRoX3RhZyA6IGludCAtPiB0IC0+IHQgPSBcImNhbWxfb2JqX3dpdGhfdGFnXCJcblxubGV0IG1hcnNoYWwgKG9iaiA6IHQpID1cbiAgTWFyc2hhbC50b19ieXRlcyBvYmogW11cbmxldCB1bm1hcnNoYWwgc3RyIHBvcyA9XG4gIChNYXJzaGFsLmZyb21fYnl0ZXMgc3RyIHBvcywgcG9zICsgTWFyc2hhbC50b3RhbF9zaXplIHN0ciBwb3MpXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbm1vZHVsZSBFeHRlbnNpb25fY29uc3RydWN0b3IgPVxuc3RydWN0XG4gIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuICBsZXQgb2ZfdmFsIHggPVxuICAgIGxldCB4ID0gcmVwciB4IGluXG4gICAgbGV0IHNsb3QgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHgpICYmICh0YWcgeCkgPD4gb2JqZWN0X3RhZyAmJiAoc2l6ZSB4KSA+PSAxIHRoZW4gZmllbGQgeCAwXG4gICAgICBlbHNlIHhcbiAgICBpblxuICAgIGxldCBuYW1lID1cbiAgICAgIGlmIChpc19ibG9jayBzbG90KSAmJiAodGFnIHNsb3QpID0gb2JqZWN0X3RhZyB0aGVuIGZpZWxkIHNsb3QgMFxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuICAgIGluXG4gICAgICBpZiAodGFnIG5hbWUpID0gc3RyaW5nX3RhZyB0aGVuIChvYmogc2xvdCA6IHQpXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gbmFtZSAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAwKSA6IHN0cmluZylcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBpZCAoc2xvdCA6IHQpID1cbiAgICAob2JqIChmaWVsZCAocmVwciBzbG90KSAxKSA6IGludClcbmVuZFxuXG5sZXQgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbFxubGV0IGV4dGVuc2lvbl9uYW1lID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm5hbWVcbmxldCBleHRlbnNpb25faWQgPSBFeHRlbnNpb25fY29uc3RydWN0b3IuaWRcblxubW9kdWxlIEVwaGVtZXJvbiA9IHN0cnVjdFxuICB0eXBlIG9ial90ID0gdFxuXG4gIHR5cGUgdCAoKiogZXBoZW1lcm9uICopXG5cbiAgICgqKiBUbyBjaGFuZ2UgaW4gc3luYyB3aXRoIHdlYWsuaCAqKVxuICBsZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG4gIGxldCBtYXhfZXBoZV9sZW5ndGggPSBTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZXBoZV9jcmVhdGVcIjs7XG4gIGxldCBjcmVhdGUgbCA9XG4gICAgaWYgbm90ICgwIDw9IGwgJiYgbCA8PSBtYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5jcmVhdGVcIjtcbiAgICBjcmVhdGUgbFxuXG4gIGxldCBsZW5ndGggeCA9IHNpemUocmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbiAgbGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICAgIGlmIG5vdCAoMCA8PSBvICYmIG8gPCBsZW5ndGggZSkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgbXNnXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleVwiXG4gIGxldCBnZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5XCI7XG4gICAgZ2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBnZXRfa2V5X2NvcHk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlfY29weVwiXG4gIGxldCBnZXRfa2V5X2NvcHkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlfY29weVwiO1xuICAgIGdldF9rZXlfY29weSBlIG9cblxuICBleHRlcm5hbCBzZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG4gIGxldCBzZXRfa2V5IGUgbyB4ID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnNldF9rZXlcIjtcbiAgICBzZXRfa2V5IGUgbyB4XG5cbiAgZXh0ZXJuYWwgdW5zZXRfa2V5OiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbiAgbGV0IHVuc2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24udW5zZXRfa2V5XCI7XG4gICAgdW5zZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGNoZWNrX2tleTogdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2tleVwiXG4gIGxldCBjaGVja19rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmNoZWNrX2tleVwiO1xuICAgIGNoZWNrX2tleSBlIG9cblxuICBleHRlcm5hbCBibGl0X2tleSA6IHQgLT4gaW50IC0+IHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgPSBcImNhbWxfZXBoZV9ibGl0X2tleVwiXG5cbiAgbGV0IGJsaXRfa2V5IGUxIG8xIGUyIG8yIGwgPVxuICAgIGlmIGwgPCAwIHx8IG8xIDwgMCB8fCBvMSA+IGxlbmd0aCBlMSAtIGxcbiAgICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uYmxpdF9rZXlcIlxuICAgIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdF9rZXkgZTEgbzEgZTIgbzIgbFxuXG4gIGV4dGVybmFsIGdldF9kYXRhOiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhXCJcbiAgZXh0ZXJuYWwgZ2V0X2RhdGFfY29weTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5XCJcbiAgZXh0ZXJuYWwgc2V0X2RhdGE6IHQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9kYXRhXCJcbiAgZXh0ZXJuYWwgdW5zZXRfZGF0YTogdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfZGF0YVwiXG4gIGV4dGVybmFsIGNoZWNrX2RhdGE6IHQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2RhdGFcIlxuICBleHRlcm5hbCBibGl0X2RhdGEgOiB0IC0+IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX2JsaXRfZGF0YVwiXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgYXJyYXlzLiAqKVxudHlwZSAnYSB0ID0gJ2EgYXJyYXlcblxuKCogQXJyYXkgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBsZW5ndGggOiAnYSBhcnJheSAtPiBpbnQgPSBcIiVhcnJheV9sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgbWFrZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCBjcmVhdGU6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgdW5zYWZlX3N1YiA6ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfc3ViXCJcbmV4dGVybmFsIGFwcGVuZF9wcmltIDogJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfYXBwZW5kXCJcbmV4dGVybmFsIGNvbmNhdCA6ICdhIGFycmF5IGxpc3QgLT4gJ2EgYXJyYXkgPSBcImNhbWxfYXJyYXlfY29uY2F0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+ICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9ibGl0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2ZpbGxcIlxuZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0OiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbmxldCBtYWtlX2Zsb2F0ID0gY3JlYXRlX2Zsb2F0XG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBmb3IgeCA9IDAgdG8gcHJlZCBzeCBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIHggKGNyZWF0ZSBzeSBpbml0KVxuICBkb25lO1xuICByZXNcblxubGV0IGNyZWF0ZV9tYXRyaXggPSBtYWtlX21hdHJpeFxuXG5sZXQgY29weSBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpbiBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSB1bnNhZmVfc3ViIGEgMCBsXG5cbmxldCBhcHBlbmQgYTEgYTIgPVxuICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgaWYgbDEgPSAwIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGxlbmd0aCBhMiA9IDAgdGhlbiB1bnNhZmVfc3ViIGExIDAgbDFcbiAgZWxzZSBhcHBlbmRfcHJpbSBhMSBhMlxuXG5sZXQgc3ViIGEgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuc3ViXCJcbiAgZWxzZSB1bnNhZmVfc3ViIGEgb2ZzIGxlblxuXG5sZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZmlsbFwiXG4gIGVsc2UgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxubGV0IGJsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBhMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggYTIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IGExIG9mczEgYTIgb2ZzMiBsZW5cblxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBpdGVyMiBmIGEgYiA9XG4gIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2VcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxubGV0IG1hcCBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZih1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZih1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwMiBmIGEgYiA9XG4gIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gIGlmIGxhIDw+IGxiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZSBiZWdpblxuICAgIGlmIGxhID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgKGYgKHVuc2FmZV9nZXQgYSAwKSAodW5zYWZlX2dldCBiIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuICBlbmRcblxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZiAwICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdG9fbGlzdCBhID1cbiAgbGV0IHJlYyB0b2xpc3QgaSByZXMgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmVzIGVsc2UgdG9saXN0IChpIC0gMSkgKHVuc2FmZV9nZXQgYSBpIDo6IHJlcykgaW5cbiAgdG9saXN0IChsZW5ndGggYSAtIDEpIFtdXG5cbigqIENhbm5vdCB1c2UgTGlzdC5sZW5ndGggaGVyZSBiZWNhdXNlIHRoZSBMaXN0IG1vZHVsZSBkZXBlbmRzIG9uIEFycmF5LiAqKVxubGV0IHJlYyBsaXN0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2N1XG4gIHwgXzo6dCAtPiBsaXN0X2xlbmd0aCAoc3VjYyBhY2N1KSB0XG5cbmxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBhID0gY3JlYXRlIChsaXN0X2xlbmd0aCAwIGwpIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaSsxKSB0bCBpblxuICAgICAgZmlsbCAxIHRsXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9yZXZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgbGVuID0gbGlzdF9sZW5ndGggMCBsIGluXG4gICAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgICBpblxuICAgICAgZmlsbCAobGVuLTIpIHRsXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICBvZl9yZXZfbGlzdCBsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcbmV4dGVybmFsIG5lZyA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgYWRkIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgc3ViIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgbXVsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgZGl2IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgcmVtIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuZXh0ZXJuYWwgbG9nYW5kIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsIGxvZ3hvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsb2dub3QgeCA9IGxvZ3hvciB4ICgtMSlcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5leHRlcm5hbCB0b19mbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcblxuKCpcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZyBzID0gdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcykgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxubGV0IHRvX3N0cmluZyB4ID0gZm9ybWF0X2ludCBcIiVkXCIgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT5cbiAgICAgIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gICAgICBmdW4gbiAtPlxuICAgICAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgTm9uZVxuICB8IDY0IC0+XG4gICAgICAoKiBTbyB0aGF0IGl0IGNvbXBpbGVzIGluIDMyLWJpdCAqKVxuICAgICAgbGV0IG1vdmUgPSBpbnRfb2Zfc3RyaW5nIFwiMHgxXzAwMDBfMDAwMFwiIGluXG4gICAgICBmdW4gbiAtPiBsZXQgaSA9IHRvX2ludCBuIGluIFNvbWUgKGlmIGkgPCAwIHRoZW4gaSArIG1vdmUgZWxzZSBpKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcblxudHlwZSBwYXJzZV90YWJsZXMgPVxuICB7IGFjdGlvbnMgOiAocGFyc2VyX2VudiAtPiBPYmoudCkgYXJyYXk7XG4gICAgdHJhbnNsX2NvbnN0IDogaW50IGFycmF5O1xuICAgIHRyYW5zbF9ibG9jayA6IGludCBhcnJheTtcbiAgICBsaHMgOiBzdHJpbmc7XG4gICAgbGVuIDogc3RyaW5nO1xuICAgIGRlZnJlZCA6IHN0cmluZztcbiAgICBkZ290byA6IHN0cmluZztcbiAgICBzaW5kZXggOiBzdHJpbmc7XG4gICAgcmluZGV4IDogc3RyaW5nO1xuICAgIGdpbmRleCA6IHN0cmluZztcbiAgICB0YWJsZXNpemUgOiBpbnQ7XG4gICAgdGFibGUgOiBzdHJpbmc7XG4gICAgY2hlY2sgOiBzdHJpbmc7XG4gICAgZXJyb3JfZnVuY3Rpb24gOiBzdHJpbmcgLT4gdW5pdDtcbiAgICBuYW1lc19jb25zdCA6IHN0cmluZztcbiAgICBuYW1lc19ibG9jayA6IHN0cmluZyB9XG5cbmV4Y2VwdGlvbiBZWWV4aXQgb2YgT2JqLnRcbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIHBhcnNlcl9pbnB1dCA9XG4gICAgU3RhcnRcbiAgfCBUb2tlbl9yZWFkXG4gIHwgU3RhY2tzX2dyb3duXzFcbiAgfCBTdGFja3NfZ3Jvd25fMlxuICB8IFNlbWFudGljX2FjdGlvbl9jb21wdXRlZFxuICB8IEVycm9yX2RldGVjdGVkXG5cbnR5cGUgcGFyc2VyX291dHB1dCA9XG4gICAgUmVhZF90b2tlblxuICB8IFJhaXNlX3BhcnNlX2Vycm9yXG4gIHwgR3Jvd19zdGFja3NfMVxuICB8IEdyb3dfc3RhY2tzXzJcbiAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvblxuICB8IENhbGxfZXJyb3JfZnVuY3Rpb25cblxuKCogdG8gYXZvaWQgd2FybmluZ3MgKilcbmxldCBfID0gW1JlYWRfdG9rZW47IFJhaXNlX3BhcnNlX2Vycm9yOyBHcm93X3N0YWNrc18xOyBHcm93X3N0YWNrc18yO1xuICAgICAgICAgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb247IENhbGxfZXJyb3JfZnVuY3Rpb25dXG5cbmV4dGVybmFsIHBhcnNlX2VuZ2luZSA6XG4gICAgcGFyc2VfdGFibGVzIC0+IHBhcnNlcl9lbnYgLT4gcGFyc2VyX2lucHV0IC0+IE9iai50IC0+IHBhcnNlcl9vdXRwdXRcbiAgICA9IFwiY2FtbF9wYXJzZV9lbmdpbmVcIlxuXG5leHRlcm5hbCBzZXRfdHJhY2U6IGJvb2wgLT4gYm9vbFxuICAgID0gXCJjYW1sX3NldF9wYXJzZXJfdHJhY2VcIlxuXG5sZXQgZW52ID1cbiAgeyBzX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgMDtcbiAgICB2X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgKE9iai5yZXByICgpKTtcbiAgICBzeW1iX3N0YXJ0X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN0YWNrc2l6ZSA9IDEwMDtcbiAgICBzdGFja2Jhc2UgPSAwO1xuICAgIGN1cnJfY2hhciA9IDA7XG4gICAgbHZhbCA9IE9iai5yZXByICgpO1xuICAgIHN5bWJfc3RhcnQgPSBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmQgPSBkdW1teV9wb3M7XG4gICAgYXNwID0gMDtcbiAgICBydWxlX2xlbiA9IDA7XG4gICAgcnVsZV9udW1iZXIgPSAwO1xuICAgIHNwID0gMDtcbiAgICBzdGF0ZSA9IDA7XG4gICAgZXJyZmxhZyA9IDAgfVxuXG5sZXQgZ3Jvd19zdGFja3MoKSA9XG4gIGxldCBvbGRzaXplID0gZW52LnN0YWNrc2l6ZSBpblxuICBsZXQgbmV3c2l6ZSA9IG9sZHNpemUgKiAyIGluXG4gIGxldCBuZXdfcyA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAwXG4gIGFuZCBuZXdfdiA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAoT2JqLnJlcHIgKCkpXG4gIGFuZCBuZXdfc3RhcnQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zXG4gIGFuZCBuZXdfZW5kID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3BvcyBpblxuICAgIEFycmF5LmJsaXQgZW52LnNfc3RhY2sgMCBuZXdfcyAwIG9sZHNpemU7XG4gICAgZW52LnNfc3RhY2sgPC0gbmV3X3M7XG4gICAgQXJyYXkuYmxpdCBlbnYudl9zdGFjayAwIG5ld192IDAgb2xkc2l6ZTtcbiAgICBlbnYudl9zdGFjayA8LSBuZXdfdjtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX3N0YXJ0X3N0YWNrIDAgbmV3X3N0YXJ0IDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9zdGFydF9zdGFjayA8LSBuZXdfc3RhcnQ7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9lbmRfc3RhY2sgMCBuZXdfZW5kIDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9lbmRfc3RhY2sgPC0gbmV3X2VuZDtcbiAgICBlbnYuc3RhY2tzaXplIDwtIG5ld3NpemVcblxubGV0IGNsZWFyX3BhcnNlcigpID1cbiAgQXJyYXkuZmlsbCBlbnYudl9zdGFjayAwIGVudi5zdGFja3NpemUgKE9iai5yZXByICgpKTtcbiAgZW52Lmx2YWwgPC0gT2JqLnJlcHIgKClcblxubGV0IGN1cnJlbnRfbG9va2FoZWFkX2Z1biA9IHJlZiAoZnVuIChfIDogT2JqLnQpIC0+IGZhbHNlKVxuXG5sZXQgeXlwYXJzZSB0YWJsZXMgc3RhcnQgbGV4ZXIgbGV4YnVmID1cbiAgbGV0IHJlYyBsb29wIGNtZCBhcmcgPVxuICAgIG1hdGNoIHBhcnNlX2VuZ2luZSB0YWJsZXMgZW52IGNtZCBhcmcgd2l0aFxuICAgICAgUmVhZF90b2tlbiAtPlxuICAgICAgICBsZXQgdCA9IE9iai5yZXByKGxleGVyIGxleGJ1ZikgaW5cbiAgICAgICAgZW52LnN5bWJfc3RhcnQgPC0gbGV4YnVmLmxleF9zdGFydF9wO1xuICAgICAgICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gICAgICAgIGxvb3AgVG9rZW5fcmVhZCB0XG4gICAgfCBSYWlzZV9wYXJzZV9lcnJvciAtPlxuICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb24gLT5cbiAgICAgICAgbGV0IChhY3Rpb24sIHZhbHVlKSA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAoU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkLCB0YWJsZXMuYWN0aW9ucy4oZW52LnJ1bGVfbnVtYmVyKSBlbnYpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAtPlxuICAgICAgICAgICAgKEVycm9yX2RldGVjdGVkLCBPYmoucmVwciAoKSkgaW5cbiAgICAgICAgbG9vcCBhY3Rpb24gdmFsdWVcbiAgICB8IEdyb3dfc3RhY2tzXzEgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMSAoT2JqLnJlcHIgKCkpXG4gICAgfCBHcm93X3N0YWNrc18yIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzIgKE9iai5yZXByICgpKVxuICAgIHwgQ2FsbF9lcnJvcl9mdW5jdGlvbiAtPlxuICAgICAgICB0YWJsZXMuZXJyb3JfZnVuY3Rpb24gXCJzeW50YXggZXJyb3JcIjtcbiAgICAgICAgbG9vcCBFcnJvcl9kZXRlY3RlZCAoT2JqLnJlcHIgKCkpIGluXG4gIGxldCBpbml0X2FzcCA9IGVudi5hc3BcbiAgYW5kIGluaXRfc3AgPSBlbnYuc3BcbiAgYW5kIGluaXRfc3RhY2tiYXNlID0gZW52LnN0YWNrYmFzZVxuICBhbmQgaW5pdF9zdGF0ZSA9IGVudi5zdGF0ZVxuICBhbmQgaW5pdF9jdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyXG4gIGFuZCBpbml0X2x2YWwgPSBlbnYubHZhbFxuICBhbmQgaW5pdF9lcnJmbGFnID0gZW52LmVycmZsYWcgaW5cbiAgZW52LnN0YWNrYmFzZSA8LSBlbnYuc3AgKyAxO1xuICBlbnYuY3Vycl9jaGFyIDwtIHN0YXJ0O1xuICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gIHRyeVxuICAgIGxvb3AgU3RhcnQgKE9iai5yZXByICgpKVxuICB3aXRoIGV4biAtPlxuICAgIGxldCBjdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyIGluXG4gICAgZW52LmFzcCA8LSBpbml0X2FzcDtcbiAgICBlbnYuc3AgPC0gaW5pdF9zcDtcbiAgICBlbnYuc3RhY2tiYXNlIDwtIGluaXRfc3RhY2tiYXNlO1xuICAgIGVudi5zdGF0ZSA8LSBpbml0X3N0YXRlO1xuICAgIGVudi5jdXJyX2NoYXIgPC0gaW5pdF9jdXJyX2NoYXI7XG4gICAgZW52Lmx2YWwgPC0gaW5pdF9sdmFsO1xuICAgIGVudi5lcnJmbGFnIDwtIGluaXRfZXJyZmxhZztcbiAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgWVlleGl0IHYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHZcbiAgICB8IF8gLT5cbiAgICAgICAgY3VycmVudF9sb29rYWhlYWRfZnVuIDo9XG4gICAgICAgICAgKGZ1biB0b2sgLT5cbiAgICAgICAgICAgIGlmIE9iai5pc19ibG9jayB0b2tcbiAgICAgICAgICAgIHRoZW4gdGFibGVzLnRyYW5zbF9ibG9jay4oT2JqLnRhZyB0b2spID0gY3Vycl9jaGFyXG4gICAgICAgICAgICBlbHNlIHRhYmxlcy50cmFuc2xfY29uc3QuKE9iai5tYWdpYyB0b2spID0gY3Vycl9jaGFyKTtcbiAgICAgICAgcmFpc2UgZXhuXG5cbmxldCBwZWVrX3ZhbCBlbnYgbiA9XG4gIE9iai5tYWdpYyBlbnYudl9zdGFjay4oZW52LmFzcCAtIG4pXG5cbmxldCBzeW1ib2xfc3RhcnRfcG9zICgpID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPD0gMCB0aGVuIGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgc3QgPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgbGV0IGVuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBpZiBzdCA8PiBlbiB0aGVuIHN0IGVsc2UgbG9vcCAoaSAtIDEpXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgZW52LnJ1bGVfbGVuXG5cbmxldCBzeW1ib2xfZW5kX3BvcyAoKSA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbmxldCByaHNfc3RhcnRfcG9zIG4gPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcbmxldCByaHNfZW5kX3BvcyBuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxuXG5sZXQgc3ltYm9sX3N0YXJ0ICgpID0gKHN5bWJvbF9zdGFydF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgc3ltYm9sX2VuZCAoKSA9IChzeW1ib2xfZW5kX3BvcyAoKSkucG9zX2NudW1cbmxldCByaHNfc3RhcnQgbiA9IChyaHNfc3RhcnRfcG9zIG4pLnBvc19jbnVtXG5sZXQgcmhzX2VuZCBuID0gKHJoc19lbmRfcG9zIG4pLnBvc19jbnVtXG5cbmxldCBpc19jdXJyZW50X2xvb2thaGVhZCB0b2sgPVxuICAoIWN1cnJlbnRfbG9va2FoZWFkX2Z1bikoT2JqLnJlcHIgdG9rKVxuXG5sZXQgcGFyc2VfZXJyb3IgKF8gOiBzdHJpbmcpID0gKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUgZWx0XG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBlbHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCBzaW5nbGV0b246IGVsdCAtPiB0XG4gICAgdmFsIHJlbW92ZTogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgICB2YWwgaW50ZXI6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGRpc2pvaW50OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBkaWZmOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBzdWJzZXQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChlbHQgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gICAgdmFsIG1hcDogKGVsdCAtPiBlbHQpIC0+IHQgLT4gdFxuICAgIHZhbCBmb2xkOiAoZWx0IC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gICAgdmFsIGZvcl9hbGw6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdFxuICAgIHZhbCBwYXJ0aXRpb246IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0ICogdFxuICAgIHZhbCBjYXJkaW5hbDogdCAtPiBpbnRcbiAgICB2YWwgZWxlbWVudHM6IHQgLT4gZWx0IGxpc3RcbiAgICB2YWwgbWluX2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWluX2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBtYXhfZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtYXhfZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGNob29zZTogdCAtPiBlbHRcbiAgICB2YWwgY2hvb3NlX29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBlbHQgLT4gdCAtPiB0ICogYm9vbCAqIHRcbiAgICB2YWwgZmluZDogZWx0IC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfb3B0OiBlbHQgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBvZl9saXN0OiBlbHQgbGlzdCAtPiB0XG4gICAgdmFsIHRvX3NlcV9mcm9tIDogZWx0IC0+IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIHRvX3NlcSA6IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiBlbHQgU2VxLnQgLT4gdCAtPiB0XG4gICAgdmFsIG9mX3NlcSA6IGVsdCBTZXEudCAtPiB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgZWx0ID0gT3JkLnRcbiAgICB0eXBlIHQgPSBFbXB0eSB8IE5vZGUgb2Yge2w6dDsgdjplbHQ7IHI6dDsgaDppbnR9XG5cbiAgICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZVxuICAgICAgIGNoaWxkcmVuIGRpZmZlciBieSBhdCBtb3N0IDIgKilcblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgICgqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGxlZnQgc29uIGwsIHZhbHVlIHYgYW5kIHJpZ2h0IHNvbiByLlxuICAgICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBoZWlnaHQgZm9yIGJldHRlciBzcGVlZC4gKilcblxuICAgIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgICAgQXNzdW1lcyBsIGFuZCByIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAzLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgY3JlYXRlIGZvciBiZXR0ZXIgc3BlZWQgaW4gdGhlIG1vc3QgZnJlcXVlbnQgY2FzZVxuICAgICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gICAgbGV0IGJhbCBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsbCkgcmx2IChjcmVhdGUgcmxyIHJ2IHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gICAgbGV0IHJlYyBhZGQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB0IGVsc2VcbiAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdCBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdCBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCBzaW5nbGV0b24geCA9IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIHYgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQgZWxlbWVudHMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkgZWxlbWVudC5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2VsZW1lbnQgeCBsKSB2IHJcblxuICAgIGxldCByZWMgYWRkX21heF9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgbCB2IChhZGRfbWF4X2VsZW1lbnQgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fZWxlbWVudCB2IHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2VsZW1lbnQgdiBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBybCkgcnYgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgclxuXG4gICAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcblxuICAgIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0IGxcblxuICAgIGxldCByZWMgbWluX2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdF9vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHQgclxuXG4gICAgbGV0IHJlYyBtYXhfZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0X29wdCByXG5cbiAgICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGJhbCB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBqb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBTcGxpdHRpbmcuICBzcGxpdCB4IHMgcmV0dXJucyBhIHRyaXBsZSAobCwgcHJlc2VudCwgcikgd2hlcmVcbiAgICAgICAgLSBsIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA8IHhcbiAgICAgICAgLSByIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA+IHhcbiAgICAgICAgLSBwcmVzZW50IGlzIGZhbHNlIGlmIHMgY29udGFpbnMgbm8gZWxlbWVudCBlcXVhbCB0byB4LFxuICAgICAgICAgIG9yIHRydWUgaWYgcyBjb250YWlucyBhbiBlbGVtZW50IGVxdWFsIHRvIHguICopXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgZmFsc2UsIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCB0cnVlLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBsciwgcHJlcywgcnIpXG5cbiAgICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9IGFzIHQpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpblxuICAgICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpblxuICAgICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCByZWMgdW5pb24gczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIHQyKSAtPiB0MlxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxOyBoPWgxfSwgTm9kZXtsPWwyOyB2PXYyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDEgdGhlbiBhZGQgdjIgczEgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwyLCBfLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgaDEgPSAxIHRoZW4gYWRkIHYxIHMyIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMSwgXywgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYyICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBpbnRlciBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpXG5cbiAgICAoKiBTYW1lIGFzIHNwbGl0LCBidXQgY29tcHV0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXNcbiAgICAgICBvbmx5IGlmIHRoZSBwaXZvdCBlbGVtZW50IGlzIG5vdCBpbiB0aGUgc2V0LiAgVGhlIHJpZ2h0IHN1YnRyZWVcbiAgICAgICBpcyBjb21wdXRlZCBvbiBkZW1hbmQuICopXG5cbiAgICB0eXBlIHNwbGl0X2JpcyA9XG4gICAgICB8IEZvdW5kXG4gICAgICB8IE5vdEZvdW5kIG9mIHQgKiAodW5pdCAtPiB0KVxuXG4gICAgbGV0IHJlYyBzcGxpdF9iaXMgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm90Rm91bmQgKEVtcHR5LCAoZnVuICgpIC0+IEVtcHR5KSlcbiAgICAgIHwgTm9kZXtsOyB2OyByOyBffSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBGb3VuZFxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggbCB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsbCwgcmwpIC0+IE5vdEZvdW5kIChsbCwgKGZ1biAoKSAtPiBqb2luIChybCAoKSkgdiByKSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCByIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxyLCBycikgLT4gTm90Rm91bmQgKGpvaW4gbCB2IGxyLCBycilcblxuICAgIGxldCByZWMgZGlzam9pbnQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIHwgKF8sIEVtcHR5KSAtPiB0cnVlXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBpZiBzMSA9PSBzMiB0aGVuIGZhbHNlXG4gICAgICAgICAgZWxzZSBtYXRjaCBzcGxpdF9iaXMgdjEgdDIgd2l0aFxuICAgICAgICAgICAgICBOb3RGb3VuZChsMiwgcjIpIC0+IGRpc2pvaW50IGwxIGwyICYmIGRpc2pvaW50IHIxIChyMiAoKSlcbiAgICAgICAgICAgIHwgRm91bmQgLT4gZmFsc2VcblxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpXG5cbiAgICB0eXBlIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBlbHQgKiB0ICogZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIHIsIGUpKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICB8IChNb3JlKHYxLCByMSwgZTEpLCBNb3JlKHYyLCByMiwgZTIpKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG5cbiAgICBsZXQgY29tcGFyZSBzMSBzMiA9XG4gICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHMxIEVuZCkgKGNvbnNfZW51bSBzMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgczEgczIgPVxuICAgICAgY29tcGFyZSBzMSBzMiA9IDBcblxuICAgIGxldCByZWMgc3Vic2V0IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgRW1wdHksIF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bD1sMTsgdj12MTsgcj1yMX0sIChOb2RlIHtsPWwyOyB2PXYyOyByPXIyfSBhcyB0MikgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IGwxIGwyICYmIHN1YnNldCByMSByMlxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPWwxOyB2PXYxOyByPUVtcHR5OyBoPTB9KSBsMiAmJiBzdWJzZXQgcjEgdDJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9RW1wdHk7IHY9djE7IHI9cjE7IGg9MH0pIHIyICYmIHN1YnNldCBsMSB0MlxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGl0ZXIgZiBsOyBmIHY7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIGZvbGQgZiBzIGFjY3UgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBmb2xkIGYgciAoZiB2IChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2IHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9KSBhcyB0IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2IHRoZW5cbiAgICAgICAgICAgIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gdCBlbHNlIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdlxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IHJmKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZXtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBlbGVtZW50cyBzID1cbiAgICAgIGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2VsdFxuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fZWx0X29wdFxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB2XG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSB2XG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHRyeV9qb2luIGwgdiByID1cbiAgICAgICgqIFtqb2luIGwgdiByXSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiAoZWxlbWVudHMgb2YgbCA8IHYgPFxuICAgICAgICAgZWxlbWVudHMgb2Ygcik7IHVzZSBbdHJ5X2pvaW4gbCB2IHJdIHdoZW4gdGhpcyBwcm9wZXJ0eSBtYXlcbiAgICAgICAgIG5vdCBob2xkLCBidXQgeW91IGhvcGUgaXQgZG9lcyBob2xkIGluIHRoZSBjb21tb24gY2FzZSAqKVxuICAgICAgaWYgKGwgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSAobWF4X2VsdCBsKSB2IDwgMClcbiAgICAgICYmIChyID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgdiAobWluX2VsdCByKSA8IDApXG4gICAgICB0aGVuIGpvaW4gbCB2IHJcbiAgICAgIGVsc2UgdW5pb24gbCAoYWRkIHYgcilcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuXG4gICAgbGV0IG9mX3NvcnRlZF9saXN0IGwgPVxuICAgICAgbGV0IHJlYyBzdWIgbiBsID1cbiAgICAgICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgICAgIHwgMCwgbCAtPiBFbXB0eSwgbFxuICAgICAgICB8IDEsIHgwIDo6IGwgLT4gTm9kZSB7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfSwgbFxuICAgICAgICB8IDIsIHgwIDo6IHgxIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7IHI9RW1wdHk7IGg9Mn0sIGxcbiAgICAgICAgfCAzLCB4MCA6OiB4MSA6OiB4MiA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxO1xuICAgICAgICAgICAgICAgICByPU5vZGV7bD1FbXB0eTsgdj14Mjsgcj1FbXB0eTsgaD0xfTsgaD0yfSwgbFxuICAgICAgICB8IG4sIGwgLT5cbiAgICAgICAgICBsZXQgbmwgPSBuIC8gMiBpblxuICAgICAgICAgIGxldCBsZWZ0LCBsID0gc3ViIG5sIGwgaW5cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgbWlkIDo6IGwgLT5cbiAgICAgICAgICAgIGxldCByaWdodCwgbCA9IHN1YiAobiAtIG5sIC0gMSkgbCBpblxuICAgICAgICAgICAgY3JlYXRlIGxlZnQgbWlkIHJpZ2h0LCBsXG4gICAgICBpblxuICAgICAgZnN0IChzdWIgKExpc3QubGVuZ3RoIGwpIGwpXG5cbiAgICBsZXQgb2ZfbGlzdCBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBlbXB0eVxuICAgICAgfCBbeDBdIC0+IHNpbmdsZXRvbiB4MFxuICAgICAgfCBbeDA7IHgxXSAtPiBhZGQgeDEgKHNpbmdsZXRvbiB4MClcbiAgICAgIHwgW3gwOyB4MTsgeDJdIC0+IGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDNdIC0+IGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDM7IHg0XSAtPiBhZGQgeDQgKGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKSlcbiAgICAgIHwgXyAtPiBvZl9zb3J0ZWRfbGlzdCAoTGlzdC5zb3J0X3VuaXEgT3JkLmNvbXBhcmUgbClcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gcyB4IC0+IGFkZCB4IHMpIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBjID0gc2VxX29mX2VudW1fIChjb25zX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IHMgPVxuICAgICAgbGV0IHJlYyBhdXggbG93IHMgYyA9IG1hdGNoIHMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyByOyB2OyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IHMgRW5kKVxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSArJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgcGFydGl0aW9uOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAqICdhIHRcbiAgICB2YWwgY2FyZGluYWw6ICdhIHQgLT4gaW50XG4gICAgdmFsIGJpbmRpbmdzOiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICAgIHZhbCBtaW5fYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1pbl9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXhfYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1heF9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBjaG9vc2U6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBjaG9vc2Vfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBrZXkgLT4gJ2EgdCAtPiAnYSB0ICogJ2Egb3B0aW9uICogJ2EgdFxuICAgIHZhbCBmaW5kOiBrZXkgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDoga2V5IC0+ICdhIHQgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIG1hcGk6IChrZXkgLT4gJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBrZXkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaXRlciBmIGw7IGYgdiBkOyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgbWFwaSBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcGkgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXBpIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgZm9sZCBmIG0gYWNjdSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGZvbGQgZiByIChmIHYgZCAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgayBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBrZXlzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGtleS5cblxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2JpbmRpbmcgayB4IGwpIHYgZCByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgZCAoYWRkX21heF9iaW5kaW5nIGsgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgZCByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9iaW5kaW5nIHYgZCByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9iaW5kaW5nIHYgZCBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHI7IGg9bGh9LFxuICAgICAgICAgTm9kZXtsPXJsOyB2PXJ2OyBkPXJkOyByPXJyOyBoPXJofSkgLT5cbiAgICAgICAgICBpZiBsaCA+IHJoICsgMiB0aGVuIGJhbCBsbCBsdiBsZCAoam9pbiBsciB2IGQgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBkIHJsKSBydiByZCByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiBkIHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG5cbiAgICBsZXQgY29uY2F0IHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBqb2luIHQxIHggZCAocmVtb3ZlX21pbl9iaW5kaW5nIHQyKVxuXG4gICAgbGV0IGNvbmNhdF9vcl9qb2luIHQxIHYgZCB0MiA9XG4gICAgICBtYXRjaCBkIHdpdGhcbiAgICAgIHwgU29tZSBkIC0+IGpvaW4gdDEgdiBkIHQyXG4gICAgICB8IE5vbmUgLT4gY29uY2F0IHQxIHQyXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgTm9uZSwgRW1wdHkpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCBTb21lIGQsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgZCByKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobHIsIHByZXMsIHJyKSA9IHNwbGl0IHggciBpbiAoam9pbiBsIHYgZCBsciwgcHJlcywgcnIpXG5cbiAgICBsZXQgcmVjIG1lcmdlIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sIF8pIHdoZW4gaDEgPj0gaGVpZ2h0IHMyIC0+XG4gICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgY29uY2F0X29yX2pvaW4gKG1lcmdlIGYgbDEgbDIpIHYxIChmIHYxIChTb21lIGQxKSBkMikgKG1lcmdlIGYgcjEgcjIpXG4gICAgICB8IChfLCBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyfSkgLT5cbiAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjIgKGYgdjIgZDEgKFNvbWUgZDIpKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgbGV0IHJlYyB1bmlvbiBmIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgIHwgKEVtcHR5LCBzKSB8IChzLCBFbXB0eSkgLT4gc1xuICAgICAgfCAoTm9kZSB7bD1sMTsgdj12MTsgZD1kMTsgcj1yMTsgaD1oMX0sXG4gICAgICAgICBOb2RlIHtsPWwyOyB2PXYyOyBkPWQyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQyIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjEgZDEgclxuICAgICAgICAgICAgfCBTb21lIGQyIC0+IGNvbmNhdF9vcl9qb2luIGwgdjEgKGYgdjEgZDEgZDIpIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGwxLCBkMSwgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgIGxldCBsID0gdW5pb24gZiBsMSBsMiBhbmQgciA9IHVuaW9uIGYgcjEgcjIgaW5cbiAgICAgICAgICAgIG1hdGNoIGQxIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBqb2luIGwgdjIgZDIgclxuICAgICAgICAgICAgfCBTb21lIGQxIC0+IGNvbmNhdF9vcl9qb2luIGwgdjIgKGYgdjIgZDEgZDIpIHJcblxuICAgIGxldCByZWMgZmlsdGVyIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSBhcyBtIC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ZCA9IHAgdiBkIGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2ZCB0aGVuIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gbSBlbHNlIGpvaW4gbCcgdiBkIHInXG4gICAgICAgICAgZWxzZSBjb25jYXQgbCcgcidcblxuICAgIGxldCByZWMgcGFydGl0aW9uIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoRW1wdHksIEVtcHR5KVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdmRcbiAgICAgICAgICB0aGVuIChqb2luIGx0IHYgZCBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IGQgcmYpXG5cbiAgICB0eXBlICdhIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBrZXkgKiAnYSAqICdhIHQgKiAnYSBlbnVtZXJhdGlvblxuXG4gICAgbGV0IHJlYyBjb25zX2VudW0gbSBlID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIGQsIHIsIGUpKVxuXG4gICAgbGV0IGNvbXBhcmUgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgY29tcGFyZV9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IDBcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gLTFcbiAgICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICAgIHwgKE1vcmUodjEsIGQxLCByMSwgZTEpLCBNb3JlKHYyLCBkMiwgcjIsIGUyKSkgLT5cbiAgICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgbGV0IGMgPSBjbXAgZDEgZDIgaW5cbiAgICAgICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICAgICAgY29tcGFyZV9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGNvbXBhcmVfYXV4IChjb25zX2VudW0gbTEgRW5kKSAoY29uc19lbnVtIG0yIEVuZClcblxuICAgIGxldCBlcXVhbCBjbXAgbTEgbTIgPVxuICAgICAgbGV0IHJlYyBlcXVhbF9hdXggZTEgZTIgPVxuICAgICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgICAoRW5kLCBFbmQpIC0+IHRydWVcbiAgICAgICAgfCAoRW5kLCBfKSAgLT4gZmFsc2VcbiAgICAgICAgfCAoXywgRW5kKSAtPiBmYWxzZVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBPcmQuY29tcGFyZSB2MSB2MiA9IDAgJiYgY21wIGQxIGQyICYmXG4gICAgICAgICAgICBlcXVhbF9hdXggKGNvbnNfZW51bSByMSBlMSkgKGNvbnNfZW51bSByMiBlMilcbiAgICAgIGluIGVxdWFsX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgcmVjIGNhcmRpbmFsID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgYmluZGluZ3NfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJpbmRpbmdzX2F1eCAoKHYsIGQpIDo6IGJpbmRpbmdzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBiaW5kaW5ncyBzID1cbiAgICAgIGJpbmRpbmdzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2JpbmRpbmdcblxuICAgIGxldCBjaG9vc2Vfb3B0ID0gbWluX2JpbmRpbmdfb3B0XG5cbiAgICBsZXQgYWRkX3NlcSBpIG0gPVxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIG0gKGssdikgLT4gYWRkIGsgdiBtKSBtIGlcblxuICAgIGxldCBvZl9zZXEgaSA9IGFkZF9zZXEgaSBlbXB0eVxuXG4gICAgbGV0IHJlYyBzZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPiBTZXEuQ29ucyAoKGssdiksIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fc2VxIG0gPVxuICAgICAgc2VxX29mX2VudW1fIChjb25zX2VudW0gbSBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IG0gPVxuICAgICAgbGV0IHJlYyBhdXggbG93IG0gYyA9IG1hdGNoIG0gd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgZCwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIGQsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IG0gRW5kKVxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9IHsgbXV0YWJsZSBjIDogJ2EgbGlzdDsgbXV0YWJsZSBsZW4gOiBpbnQ7IH1cblxuZXhjZXB0aW9uIEVtcHR5XG5cbmxldCBjcmVhdGUgKCkgPSB7IGMgPSBbXTsgbGVuID0gMDsgfVxuXG5sZXQgY2xlYXIgcyA9IHMuYyA8LSBbXTsgcy5sZW4gPC0gMFxuXG5sZXQgY29weSBzID0geyBjID0gcy5jOyBsZW4gPSBzLmxlbjsgfVxuXG5sZXQgcHVzaCB4IHMgPSBzLmMgPC0geCA6OiBzLmM7IHMubGVuIDwtIHMubGVuICsgMVxuXG5sZXQgcG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgaGRcbiAgfCBbXSAgICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHBvcF9vcHQgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBTb21lIGhkXG4gIHwgW10gICAgIC0+IE5vbmVcblxubGV0IHRvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBoZFxuICB8IFtdICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCB0b3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IFNvbWUgaGRcbiAgfCBbXSAgICAtPiBOb25lXG5cbmxldCBpc19lbXB0eSBzID0gKHMuYyA9IFtdKVxuXG5sZXQgbGVuZ3RoIHMgPSBzLmxlblxuXG5sZXQgaXRlciBmIHMgPSBMaXN0Lml0ZXIgZiBzLmNcblxubGV0IGZvbGQgZiBhY2MgcyA9IExpc3QuZm9sZF9sZWZ0IGYgYWNjIHMuY1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBMaXN0LnRvX3NlcSBzLmNcblxubGV0IGFkZF9zZXEgcSBpID0gU2VxLml0ZXIgKGZ1biB4IC0+IHB1c2ggeCBxKSBpXG5cbmxldCBvZl9zZXEgZyA9XG4gIGxldCBzID0gY3JlYXRlKCkgaW5cbiAgYWRkX3NlcSBzIGc7XG4gIHNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRnJhbmNvaXMgUG90dGllciwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXhjZXB0aW9uIEVtcHR5XG5cbnR5cGUgJ2EgY2VsbCA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiB7IGNvbnRlbnQ6ICdhOyBtdXRhYmxlIG5leHQ6ICdhIGNlbGwgfVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgbGVuZ3RoOiBpbnQ7XG4gIG11dGFibGUgZmlyc3Q6ICdhIGNlbGw7XG4gIG11dGFibGUgbGFzdDogJ2EgY2VsbFxufVxuXG5sZXQgY3JlYXRlICgpID0ge1xuICBsZW5ndGggPSAwO1xuICBmaXJzdCA9IE5pbDtcbiAgbGFzdCA9IE5pbFxufVxuXG5sZXQgY2xlYXIgcSA9XG4gIHEubGVuZ3RoIDwtIDA7XG4gIHEuZmlyc3QgPC0gTmlsO1xuICBxLmxhc3QgPC0gTmlsXG5cbmxldCBhZGQgeCBxID1cbiAgbGV0IGNlbGwgPSBDb25zIHtcbiAgICBjb250ZW50ID0geDtcbiAgICBuZXh0ID0gTmlsXG4gIH0gaW5cbiAgbWF0Y2ggcS5sYXN0IHdpdGhcbiAgfCBOaWwgLT5cbiAgICBxLmxlbmd0aCA8LSAxO1xuICAgIHEuZmlyc3QgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuICB8IENvbnMgbGFzdCAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoICsgMTtcbiAgICBsYXN0Lm5leHQgPC0gY2VsbDtcbiAgICBxLmxhc3QgPC0gY2VsbFxuXG5sZXQgcHVzaCA9XG4gIGFkZFxuXG5sZXQgcGVlayBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBjb250ZW50XG5cbmxldCBwZWVrX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudCB9IC0+IFNvbWUgY29udGVudFxuXG5sZXQgdG9wID1cbiAgcGVla1xuXG5sZXQgdGFrZSBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IHJhaXNlIEVtcHR5XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIGNvbnRlbnRcblxubGV0IHRha2Vfb3B0IHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gTm9uZVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIFNvbWUgY29udGVudFxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCAtIDE7XG4gICAgcS5maXJzdCA8LSBuZXh0O1xuICAgIFNvbWUgY29udGVudFxuXG5sZXQgcG9wID1cbiAgdGFrZVxuXG5sZXQgY29weSA9XG4gIGxldCByZWMgY29weSBxX3JlcyBwcmV2IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IHFfcmVzLmxhc3QgPC0gcHJldjsgcV9yZXNcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCByZXMgPSBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IGluXG4gICAgICBiZWdpbiBtYXRjaCBwcmV2IHdpdGhcbiAgICAgIHwgTmlsIC0+IHFfcmVzLmZpcnN0IDwtIHJlc1xuICAgICAgfCBDb25zIHAgLT4gcC5uZXh0IDwtIHJlc1xuICAgICAgZW5kO1xuICAgICAgY29weSBxX3JlcyByZXMgbmV4dFxuICBpblxuICBmdW4gcSAtPiBjb3B5IHsgbGVuZ3RoID0gcS5sZW5ndGg7IGZpcnN0ID0gTmlsOyBsYXN0ID0gTmlsIH0gTmlsIHEuZmlyc3RcblxubGV0IGlzX2VtcHR5IHEgPVxuICBxLmxlbmd0aCA9IDBcblxubGV0IGxlbmd0aCBxID1cbiAgcS5sZW5ndGhcblxubGV0IGl0ZXIgPVxuICBsZXQgcmVjIGl0ZXIgZiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgZiBjb250ZW50O1xuICAgICAgaXRlciBmIG5leHRcbiAgaW5cbiAgZnVuIGYgcSAtPiBpdGVyIGYgcS5maXJzdFxuXG5sZXQgZm9sZCA9XG4gIGxldCByZWMgZm9sZCBmIGFjY3UgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gYWNjdVxuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IGFjY3UgPSBmIGFjY3UgY29udGVudCBpblxuICAgICAgZm9sZCBmIGFjY3UgbmV4dFxuICBpblxuICBmdW4gZiBhY2N1IHEgLT4gZm9sZCBmIGFjY3UgcS5maXJzdFxuXG5sZXQgdHJhbnNmZXIgcTEgcTIgPVxuICBpZiBxMS5sZW5ndGggPiAwIHRoZW5cbiAgICBtYXRjaCBxMi5sYXN0IHdpdGhcbiAgICB8IE5pbCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHExLmxlbmd0aDtcbiAgICAgIHEyLmZpcnN0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcbiAgICB8IENvbnMgbGFzdCAtPlxuICAgICAgcTIubGVuZ3RoIDwtIHEyLmxlbmd0aCArIHExLmxlbmd0aDtcbiAgICAgIGxhc3QubmV4dCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcSA9XG4gIGxldCByZWMgYXV4IGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICB8IE5pbCAtPiBTZXEuTmlsXG4gICAgfCBDb25zIHsgY29udGVudD14OyBuZXh0OyB9IC0+IFNlcS5Db25zICh4LCBhdXggbmV4dClcbiAgaW5cbiAgYXV4IHEuZmlyc3RcblxubGV0IGFkZF9zZXEgcSBpID0gU2VxLml0ZXIgKGZ1biB4IC0+IHB1c2ggeCBxKSBpXG5cbmxldCBvZl9zZXEgZyA9XG4gIGxldCBxID0gY3JlYXRlKCkgaW5cbiAgYWRkX3NlcSBxIGc7XG4gIHFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSW50ZXJuYWxzIG9mIGZvcmNpbmcgbGF6eSB2YWx1ZXMuICopXG5cbnR5cGUgJ2EgdCA9ICdhIGxhenlfdFxuXG5leGNlcHRpb24gVW5kZWZpbmVkXG5cbmxldCByYWlzZV91bmRlZmluZWQgPSBPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIFVuZGVmaW5lZClcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogT2JqLnQgLT4gT2JqLnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkXCJcblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgdHJ5XG4gICAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgICBtYWtlX2ZvcndhcmQgKE9iai5yZXByIGJsaykgKE9iai5yZXByIHJlc3VsdCk7XG4gICAgcmVzdWx0XG4gIHdpdGggZSAtPlxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBlKSk7XG4gICAgcmFpc2UgZVxuXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV92YWxfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICBtYWtlX2ZvcndhcmQgKE9iai5yZXByIGJsaykgKE9iai5yZXByIHJlc3VsdCk7XG4gIHJlc3VsdFxuXG5cbigqIFtmb3JjZV0gaXMgbm90IHVzZWQsIHNpbmNlIFtMYXp5LmZvcmNlXSBpcyBkZWNsYXJlZCBhcyBhIHByaW1pdGl2ZVxuICAgd2hvc2UgY29kZSBpbmxpbmVzIHRoZSB0YWcgdGVzdHMgb2YgaXRzIGFyZ3VtZW50LiAgVGhpcyBmdW5jdGlvbiBpc1xuICAgaGVyZSBmb3IgdGhlIHNha2Ugb2YgY29tcGxldGVuZXNzLCBhbmQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlLiAqKVxuXG5sZXQgZm9yY2UgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfbGF6eV9ibG9jayBsenZcblxuXG5sZXQgZm9yY2VfdmFsIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIGx6dlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0xhenldOiBkZWZlcnJlZCBjb21wdXRhdGlvbnMgKilcblxuXG4oKlxuICAgV0FSTklORzogc29tZSBwdXJwbGUgbWFnaWMgaXMgZ29pbmcgb24gaGVyZS4gIERvIG5vdCB0YWtlIHRoaXMgZmlsZVxuICAgYXMgYW4gZXhhbXBsZSBvZiBob3cgdG8gcHJvZ3JhbSBpbiBPQ2FtbC5cbiopXG5cblxuKCogV2UgbWFrZSB1c2Ugb2YgdHdvIHNwZWNpYWwgdGFncyBwcm92aWRlZCBieSB0aGUgcnVudGltZTpcbiAgIFtsYXp5X3RhZ10gYW5kIFtmb3J3YXJkX3RhZ10uXG5cbiAgIEEgdmFsdWUgb2YgdHlwZSBbJ2EgTGF6eS50XSBjYW4gYmUgb25lIG9mIHRocmVlIHRoaW5nczpcbiAgIDEuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtsYXp5X3RhZ10uICBJdHMgZmllbGQgaXMgYSBjbG9zdXJlIG9mXG4gICAgICB0eXBlIFt1bml0IC0+ICdhXSB0aGF0IGNvbXB1dGVzIHRoZSB2YWx1ZS5cbiAgIDIuIEEgYmxvY2sgb2Ygc2l6ZSAxIHdpdGggdGFnIFtmb3J3YXJkX3RhZ10uICBJdHMgZmllbGQgaXMgdGhlIHZhbHVlXG4gICAgICBvZiB0eXBlIFsnYV0gdGhhdCB3YXMgY29tcHV0ZWQuXG4gICAzLiBBbnl0aGluZyBlbHNlIGV4Y2VwdCBhIGZsb2F0LiAgVGhpcyBoYXMgdHlwZSBbJ2FdIGFuZCBpcyB0aGUgdmFsdWVcbiAgICAgIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgRXhjZXB0aW9ucyBhcmUgc3RvcmVkIGluIGZvcm1hdCAoMSkuXG4gICBUaGUgR0Mgd2lsbCBtYWdpY2FsbHkgY2hhbmdlIHRoaW5ncyBmcm9tICgyKSB0byAoMykgYWNjb3JkaW5nIHRvIGl0c1xuICAgZmFuY3kuXG5cbiAgIElmIE9DYW1sIHdhcyBjb25maWd1cmVkIHdpdGggdGhlIC1mbGF0LWZsb2F0LWFycmF5IG9wdGlvbiAod2hpY2ggaXNcbiAgIGN1cnJlbnRseSB0aGUgZGVmYXVsdCksIHRoZSBmb2xsb3dpbmcgaXMgYWxzbyB0cnVlOlxuICAgV2UgY2Fubm90IHVzZSByZXByZXNlbnRhdGlvbiAoMykgZm9yIGEgW2Zsb2F0IExhenkudF0gYmVjYXVzZVxuICAgW2NhbWxfbWFrZV9hcnJheV0gYXNzdW1lcyB0aGF0IG9ubHkgYSBbZmxvYXRdIHZhbHVlIGNhbiBoYXZlIHRhZ1xuICAgW0RvdWJsZV90YWddLlxuXG4gICBXZSBoYXZlIHRvIHVzZSB0aGUgYnVpbHQtaW4gdHlwZSBjb25zdHJ1Y3RvciBbbGF6eV90XSB0b1xuICAgbGV0IHRoZSBjb21waWxlciBpbXBsZW1lbnQgdGhlIHNwZWNpYWwgdHlwaW5nIGFuZCBjb21waWxhdGlvblxuICAgcnVsZXMgZm9yIHRoZSBbbGF6eV0ga2V5d29yZC5cbiopXG5cbnR5cGUgJ2EgdCA9ICdhIENhbWxpbnRlcm5hbExhenkudFxuXG5leGNlcHRpb24gVW5kZWZpbmVkID0gQ2FtbGludGVybmFsTGF6eS5VbmRlZmluZWRcblxuZXh0ZXJuYWwgbWFrZV9mb3J3YXJkIDogJ2EgLT4gJ2EgbGF6eV90ID0gXCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkXCJcblxuZXh0ZXJuYWwgZm9yY2UgOiAnYSB0IC0+ICdhID0gXCIlbGF6eV9mb3JjZVwiXG5cbigqIGxldCBmb3JjZSA9IGZvcmNlICopXG5cbmxldCBmb3JjZV92YWwgPSBDYW1saW50ZXJuYWxMYXp5LmZvcmNlX3ZhbFxuXG5sZXQgZnJvbV9mdW4gKGYgOiB1bml0IC0+ICdhcmcpID1cbiAgbGV0IHggPSBPYmoubmV3X2Jsb2NrIE9iai5sYXp5X3RhZyAxIGluXG4gIE9iai5zZXRfZmllbGQgeCAwIChPYmoucmVwciBmKTtcbiAgKE9iai5vYmogeCA6ICdhcmcgdClcblxuXG5sZXQgZnJvbV92YWwgKHYgOiAnYXJnKSA9XG4gIGxldCB0ID0gT2JqLnRhZyAoT2JqLnJlcHIgdikgaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB8fCB0ID0gT2JqLmxhenlfdGFnIHx8IHQgPSBPYmouZG91YmxlX3RhZyB0aGVuIGJlZ2luXG4gICAgbWFrZV9mb3J3YXJkIHZcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICAoT2JqLm1hZ2ljIHYgOiAnYXJnIHQpXG4gIGVuZFxuXG5cbmxldCBpc192YWwgKGwgOiAnYXJnIHQpID0gT2JqLnRhZyAoT2JqLnJlcHIgbCkgPD4gT2JqLmxhenlfdGFnXG5cbmxldCBsYXp5X2Zyb21fZnVuID0gZnJvbV9mdW5cblxubGV0IGxhenlfZnJvbV92YWwgPSBmcm9tX3ZhbFxuXG5sZXQgbGF6eV9pc192YWwgPSBpc192YWxcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgRGFuaWVsIGRlIFJhdWdsYXVkcmUsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2EgY2VsbCBvcHRpb25cbmFuZCAnYSBjZWxsID0geyBtdXRhYmxlIGNvdW50IDogaW50OyBtdXRhYmxlIGRhdGEgOiAnYSBkYXRhIH1cbmFuZCAnYSBkYXRhID1cbiAgICBTZW1wdHlcbiAgfCBTY29ucyBvZiAnYSAqICdhIGRhdGFcbiAgfCBTYXBwIG9mICdhIGRhdGEgKiAnYSBkYXRhXG4gIHwgU2xhenkgb2YgJ2EgZGF0YSBMYXp5LnRcbiAgfCBTZ2VuIG9mICdhIGdlblxuICB8IFNidWZmaW8gOiBidWZmaW8gLT4gY2hhciBkYXRhXG5hbmQgJ2EgZ2VuID0geyBtdXRhYmxlIGN1cnIgOiAnYSBvcHRpb24gb3B0aW9uOyBmdW5jIDogaW50IC0+ICdhIG9wdGlvbiB9XG5hbmQgYnVmZmlvID1cbiAgeyBpYyA6IGluX2NoYW5uZWw7IGJ1ZmYgOiBieXRlczsgbXV0YWJsZSBsZW4gOiBpbnQ7IG11dGFibGUgaW5kIDogaW50IH1cblxuZXhjZXB0aW9uIEZhaWx1cmVcbmV4Y2VwdGlvbiBFcnJvciBvZiBzdHJpbmdcblxubGV0IGNvdW50ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIHsgY291bnQgfSAtPiBjb3VudFxubGV0IGRhdGEgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gU2VtcHR5XG4gIHwgU29tZSB7IGRhdGEgfSAtPiBkYXRhXG5cbmxldCBmaWxsX2J1ZmYgYiA9XG4gIGIubGVuIDwtIGlucHV0IGIuaWMgYi5idWZmIDAgKEJ5dGVzLmxlbmd0aCBiLmJ1ZmYpOyBiLmluZCA8LSAwXG5cblxubGV0IHJlYyBnZXRfZGF0YSA6IHR5cGUgdi4gaW50IC0+IHYgZGF0YSAtPiB2IGRhdGEgPSBmdW4gY291bnQgZCAtPiBtYXRjaCBkIHdpdGhcbiAoKiBSZXR1cm5zIGVpdGhlciBTZW1wdHkgb3IgU2NvbnMoYSwgXykgZXZlbiB3aGVuIGQgaXMgYSBnZW5lcmF0b3JcbiAgICBvciBhIGJ1ZmZlci4gSW4gdGhvc2UgY2FzZXMsIHRoZSBpdGVtIGEgaXMgc2VlbiBhcyBleHRyYWN0ZWQgZnJvbVxuIHRoZSBnZW5lcmF0b3IvYnVmZmVyLlxuIFRoZSBjb3VudCBwYXJhbWV0ZXIgaXMgdXNlZCBmb3IgY2FsbGluZyBgU2dlbi1mdW5jdGlvbnMnLiAgKilcbiAgIFNlbXB0eSB8IFNjb25zIChfLCBfKSAtPiBkXG4gfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIGNvdW50IGQxIHdpdGhcbiAgICAgICBTY29ucyAoYSwgZDExKSAtPiBTY29ucyAoYSwgU2FwcCAoZDExLCBkMikpXG4gICAgIHwgU2VtcHR5IC0+IGdldF9kYXRhIGNvdW50IGQyXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBOb25lfSAtPiBTZW1wdHlcbiB8IFNnZW4gKHtjdXJyID0gU29tZShTb21lIGEpfSBhcyBnKSAtPlxuICAgICBnLmN1cnIgPC0gTm9uZTsgU2NvbnMoYSwgZClcbiB8IFNnZW4gZyAtPlxuICAgICBiZWdpbiBtYXRjaCBnLmZ1bmMgY291bnQgd2l0aFxuICAgICAgIE5vbmUgLT4gZy5jdXJyIDwtIFNvbWUoTm9uZSk7IFNlbXB0eVxuICAgICB8IFNvbWUgYSAtPiBTY29ucyhhLCBkKVxuICAgICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgIGVuZFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBTZW1wdHkgZWxzZVxuICAgICAgIGxldCByID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQgaW5cbiAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgICBiLmluZCA8LSBzdWNjIGIuaW5kOyBTY29ucyhyLCBkKVxuIHwgU2xhenkgZiAtPiBnZXRfZGF0YSBjb3VudCAoTGF6eS5mb3JjZSBmKVxuXG5cbmxldCByZWMgcGVla19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdiBvcHRpb24gPSBmdW4gcyAtPlxuICgqIGNvbnN1bHQgdGhlIGZpcnN0IGl0ZW0gb2YgcyAqKVxuIG1hdGNoIHMuZGF0YSB3aXRoXG4gICBTZW1wdHkgLT4gTm9uZVxuIHwgU2NvbnMgKGEsIF8pIC0+IFNvbWUgYVxuIHwgU2FwcCAoXywgXykgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgcy5jb3VudCBzLmRhdGEgd2l0aFxuICAgICAgIFNjb25zKGEsIF8pIGFzIGQgLT4gcy5kYXRhIDwtIGQ7IFNvbWUgYVxuICAgICB8IFNlbXB0eSAtPiBOb25lXG4gICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgZW5kXG4gfCBTbGF6eSBmIC0+IHMuZGF0YSA8LSAoTGF6eS5mb3JjZSBmKTsgcGVla19kYXRhIHNcbiB8IFNnZW4ge2N1cnIgPSBTb21lIGF9IC0+IGFcbiB8IFNnZW4gZyAtPiBsZXQgeCA9IGcuZnVuYyBzLmNvdW50IGluIGcuY3VyciA8LSBTb21lIHg7IHhcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gYmVnaW4gcy5kYXRhIDwtIFNlbXB0eTsgTm9uZSBlbmRcbiAgICAgZWxzZSBTb21lIChCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZClcblxuXG5sZXQgcGVlayA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzIC0+IHBlZWtfZGF0YSBzXG5cblxubGV0IHJlYyBqdW5rX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB1bml0ID0gZnVuIHMgLT5cbiAgbWF0Y2ggcy5kYXRhIHdpdGhcbiAgICBTY29ucyAoXywgZCkgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgcy5kYXRhIDwtIGRcbiAgfCBTZ2VuICh7Y3VyciA9IFNvbWUgX30gYXMgZykgLT4gcy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgZy5jdXJyIDwtIE5vbmVcbiAgfCBTYnVmZmlvIGIgLT5cbiAgICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gcy5kYXRhIDwtIFNlbXB0eVxuICAgICAgZWxzZSAocy5jb3VudCA8LSAoc3VjYyBzLmNvdW50KTsgYi5pbmQgPC0gc3VjYyBiLmluZClcbiAgfCBfIC0+XG4gICAgICBtYXRjaCBwZWVrX2RhdGEgcyB3aXRoXG4gICAgICAgIE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIC0+IGp1bmtfZGF0YSBzXG5cblxubGV0IGp1bmsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGRhdGEgLT4ganVua19kYXRhIGRhdGFcblxubGV0IHJlYyBuZ2V0X2RhdGEgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW4gW10sIHMuZGF0YSwgMFxuICBlbHNlXG4gICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgU29tZSBhIC0+XG4gICAgICAgIGp1bmtfZGF0YSBzO1xuICAgICAgICBsZXQgKGFsLCBkLCBrKSA9IG5nZXRfZGF0YSAocHJlZCBuKSBzIGluIGEgOjogYWwsIFNjb25zIChhLCBkKSwgc3VjYyBrXG4gICAgfCBOb25lIC0+IFtdLCBzLmRhdGEsIDBcblxuXG5sZXQgbnBlZWtfZGF0YSBuIHMgPVxuICBsZXQgKGFsLCBkLCBsZW4pID0gbmdldF9kYXRhIG4gcyBpblxuICBzLmNvdW50IDwtIChzLmNvdW50IC0gbGVuKTtcbiAgcy5kYXRhIDwtIGQ7XG4gIGFsXG5cblxubGV0IG5wZWVrIG4gPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gW11cbiAgfCBTb21lIGQgLT4gbnBlZWtfZGF0YSBuIGRcblxubGV0IG5leHQgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBhIC0+IGp1bmsgczsgYVxuICB8IE5vbmUgLT4gcmFpc2UgRmFpbHVyZVxuXG5cbmxldCBlbXB0eSBzID1cbiAgbWF0Y2ggcGVlayBzIHdpdGhcbiAgICBTb21lIF8gLT4gcmFpc2UgRmFpbHVyZVxuICB8IE5vbmUgLT4gKClcblxuXG5sZXQgaXRlciBmIHN0cm0gPVxuICBsZXQgcmVjIGRvX3JlYyAoKSA9XG4gICAgbWF0Y2ggcGVlayBzdHJtIHdpdGhcbiAgICAgIFNvbWUgYSAtPiBqdW5rIHN0cm07IGlnbm9yZShmIGEpOyBkb19yZWMgKClcbiAgICB8IE5vbmUgLT4gKClcbiAgaW5cbiAgZG9fcmVjICgpXG5cblxuKCogU3RyZWFtIGJ1aWxkaW5nIGZ1bmN0aW9ucyAqKVxuXG5sZXQgZnJvbSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2dlbiB7Y3VyciA9IE5vbmU7IGZ1bmMgPSBmfX1cblxubGV0IG9mX2xpc3QgbCA9XG4gIFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IExpc3QuZm9sZF9yaWdodCAoZnVuIHggbCAtPiBTY29ucyAoeCwgbCkpIGwgU2VtcHR5fVxuXG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgKCogV2UgY2Fubm90IHVzZSB0aGUgaW5kZXggcGFzc2VkIGJ5IHRoZSBbZnJvbV0gZnVuY3Rpb24gZGlyZWN0bHlcbiAgICAgICBiZWNhdXNlIGl0IHJldHVybnMgdGhlIGN1cnJlbnQgc3RyZWFtIGNvdW50LCB3aXRoIGFic29sdXRlbHkgbm9cbiAgICAgICBndWFyYW50ZWUgdGhhdCBpdCB3aWxsIHN0YXJ0IGZyb20gMC4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlXG4gICAgICAgb2YgW1N0cmVhbS5pY29ucyAnYycgKFN0cmVhbS5mcm9tX3N0cmluZyBcImFiXCIpXSwgdGhlIGZpcnN0XG4gICAgICAgYWNjZXNzIHRvIHRoZSBzdHJpbmcgd2lsbCBiZSBtYWRlIHdpdGggY291bnQgWzFdIGFscmVhZHkuXG4gICAgKilcbiAgICBsZXQgYyA9ICFjb3VudCBpblxuICAgIGlmIGMgPCBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIHMuW2NdKVxuICAgIGVsc2UgTm9uZSlcblxuXG5sZXQgb2ZfYnl0ZXMgcyA9XG4gIGxldCBjb3VudCA9IHJlZiAwIGluXG4gIGZyb20gKGZ1biBfIC0+XG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgQnl0ZXMubGVuZ3RoIHNcbiAgICB0aGVuIChpbmNyIGNvdW50OyBTb21lIChCeXRlcy5nZXQgcyBjKSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2NoYW5uZWwgaWMgPVxuICBTb21lIHtjb3VudCA9IDA7XG4gICAgICAgIGRhdGEgPSBTYnVmZmlvIHtpYyA9IGljOyBidWZmID0gQnl0ZXMuY3JlYXRlIDQwOTY7IGxlbiA9IDA7IGluZCA9IDB9fVxuXG5cbigqIFN0cmVhbSBleHByZXNzaW9ucyBidWlsZGVycyAqKVxuXG5sZXQgaWFwcCBpIHMgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTYXBwIChkYXRhIGksIGRhdGEgcyl9XG5sZXQgaWNvbnMgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2NvbnMgKGksIGRhdGEgcyl9XG5sZXQgaXNpbmcgaSA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBTZW1wdHkpfVxuXG5sZXQgbGFwcCBmIHMgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTbGF6eSAobGF6eShTYXBwIChkYXRhIChmICgpKSwgZGF0YSBzKSkpfVxuXG5sZXQgbGNvbnMgZiBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIGRhdGEgcykpKX1cbmxldCBsc2luZyBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2NvbnMgKGYgKCksIFNlbXB0eSkpKX1cblxubGV0IHNlbXB0eSA9IE5vbmVcbmxldCBzbGF6eSBmID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoZGF0YSAoZiAoKSkpKX1cblxuKCogRm9yIGRlYnVnZ2luZyB1c2UgKilcblxubGV0IHJlYyBkdW1wIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IHQgLT4gdW5pdCA9IGZ1biBmIHMgLT5cbiAgcHJpbnRfc3RyaW5nIFwie2NvdW50ID0gXCI7XG4gIHByaW50X2ludCAoY291bnQgcyk7XG4gIHByaW50X3N0cmluZyBcIjsgZGF0YSA9IFwiO1xuICBkdW1wX2RhdGEgZiAoZGF0YSBzKTtcbiAgcHJpbnRfc3RyaW5nIFwifVwiO1xuICBwcmludF9uZXdsaW5lICgpXG5hbmQgZHVtcF9kYXRhIDogdHlwZSB2LiAodiAtPiB1bml0KSAtPiB2IGRhdGEgLT4gdW5pdCA9IGZ1biBmIC0+XG4gIGZ1bmN0aW9uXG4gICAgU2VtcHR5IC0+IHByaW50X3N0cmluZyBcIlNlbXB0eVwiXG4gIHwgU2NvbnMgKGEsIGQpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTY29ucyAoXCI7XG4gICAgICBmIGE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDtcbiAgICAgIHByaW50X3N0cmluZyBcIilcIlxuICB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgIHByaW50X3N0cmluZyBcIlNhcHAgKFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDE7XG4gICAgICBwcmludF9zdHJpbmcgXCIsIFwiO1xuICAgICAgZHVtcF9kYXRhIGYgZDI7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTbGF6eSBfIC0+IHByaW50X3N0cmluZyBcIlNsYXp5XCJcbiAgfCBTZ2VuIF8gLT4gcHJpbnRfc3RyaW5nIFwiU2dlblwiXG4gIHwgU2J1ZmZpbyBfIC0+IHByaW50X3N0cmluZyBcIlNidWZmaW9cIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgUGllcnJlIFdlaXMgYW5kIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5OSBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFeHRlbnNpYmxlIGJ1ZmZlcnMgKilcblxudHlwZSB0ID1cbiB7bXV0YWJsZSBidWZmZXIgOiBieXRlcztcbiAgbXV0YWJsZSBwb3NpdGlvbiA6IGludDtcbiAgbXV0YWJsZSBsZW5ndGggOiBpbnQ7XG4gIGluaXRpYWxfYnVmZmVyIDogYnl0ZXN9XG4oKiBJbnZhcmlhbnRzOiBhbGwgcGFydHMgb2YgdGhlIGNvZGUgcHJlc2VydmUgdGhlIGludmFyaWFudHMgdGhhdDpcbiAgIC0gWzAgPD0gYi5wb3NpdGlvbiA8PSBiLmxlbmd0aF1cbiAgIC0gW2IubGVuZ3RoID0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXVxuXG4gICBOb3RlIGluIHBhcnRpY3VsYXIgdGhhdCBbYi5wb3NpdGlvbiA9IGIubGVuZ3RoXSBpcyBsZWdhbCxcbiAgIGl0IG1lYW5zIHRoYXQgdGhlIGJ1ZmZlciBpcyBmdWxsIGFuZCB3aWxsIGhhdmUgdG8gYmUgZXh0ZW5kZWRcbiAgIGJlZm9yZSBhbnkgZnVydGhlciBhZGRpdGlvbi4gKilcblxubGV0IGNyZWF0ZSBuID1cbiBsZXQgbiA9IGlmIG4gPCAxIHRoZW4gMSBlbHNlIG4gaW5cbiBsZXQgbiA9IGlmIG4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBTeXMubWF4X3N0cmluZ19sZW5ndGggZWxzZSBuIGluXG4gbGV0IHMgPSBCeXRlcy5jcmVhdGUgbiBpblxuIHtidWZmZXIgPSBzOyBwb3NpdGlvbiA9IDA7IGxlbmd0aCA9IG47IGluaXRpYWxfYnVmZmVyID0gc31cblxubGV0IGNvbnRlbnRzIGIgPSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxubGV0IHRvX2J5dGVzIGIgPSBCeXRlcy5zdWIgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBzdWIgYiBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGIucG9zaXRpb24gLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5zdWJcIlxuICBlbHNlIEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgb2ZzIGxlblxuXG5cbmxldCBibGl0IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IHNyY29mZiA8IDAgfHwgc3Jjb2ZmID4gc3JjLnBvc2l0aW9uIC0gbGVuXG4gICAgICAgICAgICAgfHwgZHN0b2ZmIDwgMCB8fCBkc3RvZmYgPiAoQnl0ZXMubGVuZ3RoIGRzdCkgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5ibGl0XCJcbiAgZWxzZVxuICAgIEJ5dGVzLnVuc2FmZV9ibGl0IHNyYy5idWZmZXIgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuXG5cblxubGV0IG50aCBiIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID49IGIucG9zaXRpb24gdGhlblxuICAgaW52YWxpZF9hcmcgXCJCdWZmZXIubnRoXCJcbiAgZWxzZSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIG9mc1xuXG5cbmxldCBsZW5ndGggYiA9IGIucG9zaXRpb25cblxubGV0IGNsZWFyIGIgPSBiLnBvc2l0aW9uIDwtIDBcblxubGV0IHJlc2V0IGIgPVxuICBiLnBvc2l0aW9uIDwtIDA7XG4gIGIuYnVmZmVyIDwtIGIuaW5pdGlhbF9idWZmZXI7XG4gIGIubGVuZ3RoIDwtIEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlclxuXG4oKiBbcmVzaXplIGIgbW9yZV0gZW5zdXJlcyB0aGF0IFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gaG9sZHNcbiAgIGJ5IGR5bmFtaWNhbGx5IGV4dGVuZGluZyBbYi5idWZmZXJdIGlmIG5lY2Vzc2FyeSAtLSBhbmQgdGh1c1xuICAgaW5jcmVhc2luZyBbYi5sZW5ndGhdLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBhZnRlciBbcmVzaXplIGIgbW9yZV0gaXMgY2FsbGVkLCBhIGRpcmVjdCBhY2Nlc3Mgb2ZcbiAgIHNpemUgW21vcmVdIGF0IFtiLnBvc2l0aW9uXSB3aWxsIGFsd2F5cyBiZSBpbi1ib3VuZHMsIHNvIHRoYXRcbiAgICh1bnNhZmVfe2dldCxzZXR9KSBtYXkgYmUgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG4qKVxubGV0IHJlc2l6ZSBiIG1vcmUgPVxuICBsZXQgb2xkX3BvcyA9IGIucG9zaXRpb24gaW5cbiAgbGV0IG9sZF9sZW4gPSBiLmxlbmd0aCBpblxuICBsZXQgbmV3X2xlbiA9IHJlZiBvbGRfbGVuIGluXG4gIHdoaWxlIG9sZF9wb3MgKyBtb3JlID4gIW5ld19sZW4gZG8gbmV3X2xlbiA6PSAyICogIW5ld19sZW4gZG9uZTtcbiAgaWYgIW5ld19sZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiBiZWdpblxuICAgIGlmIG9sZF9wb3MgKyBtb3JlIDw9IFN5cy5tYXhfc3RyaW5nX2xlbmd0aFxuICAgIHRoZW4gbmV3X2xlbiA6PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICBlbHNlIGZhaWx3aXRoIFwiQnVmZmVyLmFkZDogY2Fubm90IGdyb3cgYnVmZmVyXCJcbiAgZW5kO1xuICBsZXQgbmV3X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAhbmV3X2xlbiBpblxuICAoKiBQUiM2MTQ4OiBsZXQncyBrZWVwIHVzaW5nIFtibGl0XSByYXRoZXIgdGhhbiBbdW5zYWZlX2JsaXRdIGluXG4gICAgIHRoaXMgdHJpY2t5IGZ1bmN0aW9uIHRoYXQgaXMgc2xvdyBhbnl3YXkuICopXG4gIEJ5dGVzLmJsaXQgYi5idWZmZXIgMCBuZXdfYnVmZmVyIDAgYi5wb3NpdGlvbjtcbiAgYi5idWZmZXIgPC0gbmV3X2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gIW5ld19sZW47XG4gIGFzc2VydCAoYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGgpO1xuICBhc3NlcnQgKG9sZF9wb3MgKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgKClcbiAgKCogTm90ZTogdGhlcmUgYXJlIHZhcmlvdXMgc2l0dWF0aW9ucyAocHJlZW1wdGl2ZSB0aHJlYWRzLCBzaWduYWxzIGFuZFxuICAgICBnYyBmaW5hbGl6ZXJzKSB3aGVyZSBPQ2FtbCBjb2RlIG1heSBiZSBydW4gYXN5bmNocm9ub3VzbHk7IGluXG4gICAgIHBhcnRpY3VsYXIsIHRoZXJlIG1heSBiZSBhIHJhY2Ugd2l0aCBhbm90aGVyIHVzZXIgb2YgW2JdLCBjaGFuZ2luZ1xuICAgICBpdHMgbXV0YWJsZSBmaWVsZHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgW3Jlc2l6ZV0gY2FsbC4gVGhlIEJ1ZmZlclxuICAgICBtb2R1bGUgZG9lcyBub3QgcHJvdmlkZSBhbnkgY29ycmVjdG5lc3MgZ3VhcmFudGVlIGlmIHRoYXQgaGFwcGVucyxcbiAgICAgYnV0IHdlIG11c3Qgc3RpbGwgZW5zdXJlIHRoYXQgdGhlIGRhdGFzdHJ1Y3R1cmUgaW52YXJpYW50cyBob2xkIGZvclxuICAgICBtZW1vcnktc2FmZXR5IC0tIGFzIHdlIHBsYW4gdG8gdXNlIFt1bnNhZmVfe2dldCxzZXR9XS5cblxuICAgICBUaGVyZSBhcmUgdHdvIHBvdGVudGlhbCBhbGxvY2F0aW9uIHBvaW50cyBpbiB0aGlzIGZ1bmN0aW9uLFxuICAgICBbcmVmXSBhbmQgW0J5dGVzLmNyZWF0ZV0sIGJ1dCBhbGwgcmVhZHMgYW5kIHdyaXRlcyB0byB0aGUgZmllbGRzXG4gICAgIG9mIFtiXSBoYXBwZW4gYmVmb3JlIGJvdGggb2YgdGhlbSBvciBhZnRlciBib3RoIG9mIHRoZW0uXG5cbiAgICAgV2UgdGhlcmVmb3JlIGFzc3VtZSB0aGF0IFtiLnBvc2l0aW9uXSBtYXkgY2hhbmdlIGF0IHRoZXNlIGFsbG9jYXRpb25zLFxuICAgICBhbmQgY2hlY2sgdGhhdCB0aGUgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBwb3N0Y29uZGl0aW9uXG4gICAgIGhvbGRzIGZvciBib3RoIHZhbHVlcyBvZiBbYi5wb3NpdGlvbl0sIGJlZm9yZSBvciBhZnRlciB0aGUgZnVuY3Rpb25cbiAgICAgaXMgY2FsbGVkLiBNb3JlIHByZWNpc2VseSwgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzIG11c3QgaG9sZCBpZiB0aGVcbiAgICAgZnVuY3Rpb24gcmV0dXJucyBjb3JyZWN0bHksIGluIGFkZGl0aW9uIHRvIHRoZSB1c3VhbCBidWZmZXIgaW52YXJpYW50czpcbiAgICAgLSBbb2xkKGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtuZXcoYi5wb3NpdGlvbikgKyBtb3JlIDw9IG5ldyhiLmxlbmd0aCldXG4gICAgIC0gW29sZChiLmxlbmd0aCkgPD0gbmV3KGIubGVuZ3RoKV1cblxuICAgICBOb3RlOiBbYi5wb3NpdGlvbiArIG1vcmUgPD0gb2xkKGIubGVuZ3RoKV0gZG9lcyAqbm90KlxuICAgICBob2xkIGluIGdlbmVyYWwsIGFzIGl0IGlzIHByZWNpc2VseSB0aGUgY2FzZSB3aGVyZSB5b3UgbmVlZFxuICAgICB0byBjYWxsIFtyZXNpemVdIHRvIGluY3JlYXNlIFtiLmxlbmd0aF0uXG5cbiAgICAgTm90ZTogW2Fzc2VydF0gYWJvdmUgZG9lcyBub3QgbWVhbiB0aGF0IHdlIGtub3cgdGhlIGNvbmRpdGlvbnNcbiAgICAgYWx3YXlzIGhvbGQsIGJ1dCB0aGF0IHRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGNvcnJlY3RseVxuICAgICBvbmx5IGlmIHRoZXkgaG9sZC5cblxuICAgICBOb3RlOiB0aGUgb3RoZXIgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGRvZXMgbm90IG5lZWRcbiAgICAgdG8gYmUgY2hlY2tlZCB3aXRoIHRoaXMgbGV2ZWwgb2Ygc2NydXRpbnksIGdpdmVuIHRoYXQgdGhleVxuICAgICByZWFkL3dyaXRlIHRoZSBidWZmZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgY2hlY2tpbmcgdGhhdFxuICAgICBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGQgb3IgY2FsbGluZyBbcmVzaXplXS5cbiAgKilcblxubGV0IGFkZF9jaGFyIGIgYyA9XG4gIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gIGlmIHBvcyA+PSBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDE7XG4gIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgcG9zIGM7XG4gIGIucG9zaXRpb24gPC0gcG9zICsgMVxuXG4gbGV0IGFkZF91dGZfOF91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweDAwN0YgLT5cbiAgICAgYWRkX2NoYXIgYiAoQ2hhci51bnNhZmVfY2hyIHUpXG4gfCB1IHdoZW4gdSA8PSAweDA3RkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEMwIGxvciAodSBsc3IgNikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDMgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDM7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhFMCBsb3IgKHUgbHNyIDEyKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAzXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RjAgbG9yICh1IGxzciAxOCkpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDEyKSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciA2KSBsYW5kIDB4M0YpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmJlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKHUgbGFuZCAweEZGKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMykgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuIGxldCBhZGRfdXRmXzE2bGVfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKHUgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpIChDaGFyLnVuc2FmZV9jaHIgKHUgbHNyIDgpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyAyXG4gfCB1IHdoZW4gdSA8PSAweDEwRkZGRiAtPlxuICAgICBsZXQgdScgPSB1IC0gMHgxMDAwMCBpblxuICAgICBsZXQgaGkgPSAweEQ4MDAgbG9yICh1JyBsc3IgMTApIGluXG4gICAgIGxldCBsbyA9IDB4REMwMCBsb3IgKHUnIGxhbmQgMHgzRkYpIGluXG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDQgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApIChDaGFyLnVuc2FmZV9jaHIgKGhpIGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKSAoQ2hhci51bnNhZmVfY2hyIChsbyBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMykgKENoYXIudW5zYWZlX2NociAobG8gbHNyIDgpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgYWRkX3N1YnN0cmluZyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGlmIG9mZnNldCA8IDAgfHwgbGVuIDwgMCB8fCBvZmZzZXQgPiBTdHJpbmcubGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfc3Vic3RyaW5nL2FkZF9zdWJieXRlc1wiO1xuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgb2Zmc2V0IGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX3N1YmJ5dGVzIGIgcyBvZmZzZXQgbGVuID1cbiAgYWRkX3N1YnN0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpIG9mZnNldCBsZW5cblxubGV0IGFkZF9zdHJpbmcgYiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMudW5zYWZlX2JsaXRfc3RyaW5nIHMgMCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9ieXRlcyBiIHMgPSBhZGRfc3RyaW5nIGIgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcylcblxubGV0IGFkZF9idWZmZXIgYiBicyA9XG4gIGFkZF9zdWJieXRlcyBiIGJzLmJ1ZmZlciAwIGJzLnBvc2l0aW9uXG5cbigqIHRoaXMgKHByaXZhdGUpIGZ1bmN0aW9uIGNvdWxkIG1vdmUgaW50byB0aGUgc3RhbmRhcmQgbGlicmFyeSAqKVxubGV0IHJlYWxseV9pbnB1dF91cF90byBpYyBidWYgb2ZzIGxlbiA9XG4gIGxldCByZWMgbG9vcCBpYyBidWYgfmFscmVhZHlfcmVhZCB+b2ZzIH50b19yZWFkID1cbiAgICBpZiB0b19yZWFkID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gaW5wdXQgaWMgYnVmIG9mcyB0b19yZWFkIGluXG4gICAgICBpZiByID0gMCB0aGVuIGFscmVhZHlfcmVhZFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBsZXQgYWxyZWFkeV9yZWFkID0gYWxyZWFkeV9yZWFkICsgciBpblxuICAgICAgICBsZXQgb2ZzID0gb2ZzICsgciBpblxuICAgICAgICBsZXQgdG9fcmVhZCA9IHRvX3JlYWQgLSByIGluXG4gICAgICAgIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZFxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQ6MCB+b2ZzIH50b19yZWFkOmxlblxuXG5cbmxldCB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gPVxuICBpZiBiLnBvc2l0aW9uICsgbGVuID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIGxldCBuID0gcmVhbGx5X2lucHV0X3VwX3RvIGljIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuIGluXG4gICgqIFRoZSBhc3NlcnRpb24gYmVsb3cgbWF5IGZhaWwgaW4gd2VpcmQgc2NlbmFyaW8gd2hlcmVcbiAgICAgdGhyZWFkZWQvZmluYWxpemVyIGNvZGUsIHJ1biBhc3luY2hyb25vdXNseSBkdXJpbmcgdGhlXG4gICAgIFtyZWFsbHlfaW5wdXRfdXBfdG9dIGNhbGwsIHJhY2VzIG9uIHRoZSBidWZmZXI7IHdlIGRvbid0IGVuc3VyZVxuICAgICBjb3JyZWN0bmVzcyBpbiB0aGlzIGNhc2UsIGJ1dCBuZWVkIHRvIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIGZvclxuICAgICBtZW1vcnktc2FmZXR5IChzZWUgZGlzY3Vzc2lvbiBvZiBbcmVzaXplXSkuICopXG4gIGFzc2VydCAoYi5wb3NpdGlvbiArIG4gPD0gYi5sZW5ndGgpO1xuICBiLnBvc2l0aW9uIDwtIGIucG9zaXRpb24gKyBuO1xuICBuXG5cbmxldCBhZGRfY2hhbm5lbCBiIGljIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gICAoKiBQUiM1MDA0ICopXG4gICAgaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX2NoYW5uZWxcIjtcbiAgbGV0IG4gPSB1bnNhZmVfYWRkX2NoYW5uZWxfdXBfdG8gYiBpYyBsZW4gaW5cbiAgKCogSXQgaXMgaW50ZW50aW9uYWwgdGhhdCBhIGNvbnN1bWVyIGNhdGNoaW5nIEVuZF9vZl9maWxlXG4gICAgIHdpbGwgc2VlIHRoZSBkYXRhIHdyaXR0ZW4gKHNlZSAjNjcxOSwgIzcxMzYpLiAqKVxuICBpZiBuIDwgbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICgpXG5cbmxldCBvdXRwdXRfYnVmZmVyIG9jIGIgPVxuICBvdXRwdXQgb2MgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5cbmxldCBjbG9zaW5nID0gZnVuY3Rpb25cbiAgfCAnKCcgLT4gJyknXG4gIHwgJ3snIC0+ICd9J1xuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbigqIG9wZW5pbmcgYW5kIGNsb3Npbmc6IG9wZW4gYW5kIGNsb3NlIGNoYXJhY3RlcnMsIHR5cGljYWxseSAoIGFuZCApXG4gICBrOiBiYWxhbmNlIG9mIG9wZW5pbmcgYW5kIGNsb3NpbmcgY2hhcnNcbiAgIHM6IHRoZSBzdHJpbmcgd2hlcmUgd2UgYXJlIHNlYXJjaGluZ1xuICAgc3RhcnQ6IHRoZSBpbmRleCB3aGVyZSB3ZSBzdGFydCB0aGUgc2VhcmNoLiAqKVxubGV0IGFkdmFuY2VfdG9fY2xvc2luZyBvcGVuaW5nIGNsb3NpbmcgayBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGsgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgICBpZiBzLltpXSA9IG9wZW5pbmcgdGhlbiBhZHZhbmNlIChrICsgMSkgKGkgKyAxKSBsaW0gZWxzZVxuICAgIGlmIHMuW2ldID0gY2xvc2luZyB0aGVuXG4gICAgICBpZiBrID0gMCB0aGVuIGkgZWxzZSBhZHZhbmNlIChrIC0gMSkgKGkgKyAxKSBsaW1cbiAgICBlbHNlIGFkdmFuY2UgayAoaSArIDEpIGxpbSBpblxuICBhZHZhbmNlIGsgc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxubGV0IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgc3RhcnQgPVxuICBsZXQgcmVjIGFkdmFuY2UgaSBsaW0gPVxuICAgIGlmIGkgPj0gbGltIHRoZW4gbGltIGVsc2VcbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgfCAnXycgLT4gYWR2YW5jZSAoaSArIDEpIGxpbVxuICAgIHwgXyAtPiBpIGluXG4gIGFkdmFuY2Ugc3RhcnQgKFN0cmluZy5sZW5ndGggcylcblxuKCogV2UgYXJlIGp1c3QgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBpZGVudCBpbiBzLCBzdGFydGluZyBhdCBzdGFydC4gKilcbmxldCBmaW5kX2lkZW50IHMgc3RhcnQgbGltID1cbiAgaWYgc3RhcnQgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgbWF0Y2ggcy5bc3RhcnRdIHdpdGhcbiAgKCogUGFyZW50aGVzaXplZCBpZGVudCA/ICopXG4gIHwgJygnIHwgJ3snIGFzIGMgLT5cbiAgICAgbGV0IG5ld19zdGFydCA9IHN0YXJ0ICsgMSBpblxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fY2xvc2luZyBjIChjbG9zaW5nIGMpIDAgcyBuZXdfc3RhcnQgaW5cbiAgICAgU3RyaW5nLnN1YiBzIG5ld19zdGFydCAoc3RvcCAtIHN0YXJ0IC0gMSksIHN0b3AgKyAxXG4gICgqIFJlZ3VsYXIgaWRlbnQgKilcbiAgfCBfIC0+XG4gICAgIGxldCBzdG9wID0gYWR2YW5jZV90b19ub25fYWxwaGEgcyAoc3RhcnQgKyAxKSBpblxuICAgICBTdHJpbmcuc3ViIHMgc3RhcnQgKHN0b3AgLSBzdGFydCksIHN0b3BcblxuKCogU3Vic3RpdHV0ZSAkaWRlbnQsICQoaWRlbnQpLCBvciAke2lkZW50fSBpbiBzLFxuICAgIGFjY29yZGluZyB0byB0aGUgZnVuY3Rpb24gbWFwcGluZyBmLiAqKVxubGV0IGFkZF9zdWJzdGl0dXRlIGIgZiBzID1cbiAgbGV0IGxpbSA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIHN1YnN0IHByZXZpb3VzIGkgPVxuICAgIGlmIGkgPCBsaW0gdGhlbiBiZWdpblxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnJCcgYXMgY3VycmVudCB3aGVuIHByZXZpb3VzID0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnJCcgLT5cbiAgICAgICAgIGxldCBqID0gaSArIDEgaW5cbiAgICAgICAgIGxldCBpZGVudCwgbmV4dF9pID0gZmluZF9pZGVudCBzIGogbGltIGluXG4gICAgICAgICBhZGRfc3RyaW5nIGIgKGYgaWRlbnQpO1xuICAgICAgICAgc3Vic3QgJyAnIG5leHRfaVxuICAgICAgfCBjdXJyZW50IHdoZW4gcHJldmlvdXMgPT0gJ1xcXFwnIC0+XG4gICAgICAgICBhZGRfY2hhciBiICdcXFxcJztcbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0ICcgJyAoaSArIDEpXG4gICAgICB8ICdcXFxcJyBhcyBjdXJyZW50IC0+XG4gICAgICAgICBzdWJzdCBjdXJyZW50IChpICsgMSlcbiAgICAgIHwgY3VycmVudCAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgZW5kIGVsc2VcbiAgICBpZiBwcmV2aW91cyA9ICdcXFxcJyB0aGVuIGFkZF9jaGFyIGIgcHJldmlvdXMgaW5cbiAgc3Vic3QgJyAnIDBcblxubGV0IHRydW5jYXRlIGIgbGVuID1cbiAgICBpZiBsZW4gPCAwIHx8IGxlbiA+IGxlbmd0aCBiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLnRydW5jYXRlXCJcbiAgICBlbHNlXG4gICAgICBiLnBvc2l0aW9uIDwtIGxlblxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGIgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICAoKiBOb3RlIHRoYXQgYi5wb3NpdGlvbiBpcyBub3QgYSBjb25zdGFudCBhbmQgY2Fubm90IGJlIGxpZnRlZCBvdXQgb2YgYXV4ICopXG4gICAgaWYgaSA+PSBiLnBvc2l0aW9uIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCBhZGRfc2VxIGIgc2VxID0gU2VxLml0ZXIgKGFkZF9jaGFyIGIpIHNlcVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgYiA9IGNyZWF0ZSAzMiBpblxuICBhZGRfc2VxIGIgaTtcbiAgYlxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXRfaW50MTYgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2dVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDMyIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMydVwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDY0IDogYnl0ZXMgLT4gaW50IC0+IGludDY0IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDY0dVwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5cbmxldCBhZGRfaW50OCBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDEgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICB1bnNhZmVfc2V0X2ludDggYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgMiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gIHVuc2FmZV9zZXRfaW50MTYgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDMyX25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgNCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDQ7XG4gIHVuc2FmZV9zZXRfaW50MzIgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDY0X25lIGIgeCA9XG4gIGxldCBuZXdfcG9zaXRpb24gPSBiLnBvc2l0aW9uICsgOCBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDg7XG4gIHVuc2FmZV9zZXRfaW50NjQgYi5idWZmZXIgYi5wb3NpdGlvbiB4O1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2ludDE2X2xlIGIgeCA9XG4gIGFkZF9pbnQxNl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQxNl9iZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDE2IHgpXG5cbmxldCBhZGRfaW50MzJfbGUgYiB4ID1cbiAgYWRkX2ludDMyX25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDMyX2JlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwMzIgeClcblxubGV0IGFkZF9pbnQ2NF9sZSBiIHggPVxuICBhZGRfaW50NjRfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50NjRfYmUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXA2NCB4KVxuXG5sZXQgYWRkX3VpbnQ4ID0gYWRkX2ludDhcbmxldCBhZGRfdWludDE2X25lID0gYWRkX2ludDE2X25lXG5sZXQgYWRkX3VpbnQxNl9sZSA9IGFkZF9pbnQxNl9sZVxubGV0IGFkZF91aW50MTZfYmUgPSBhZGRfaW50MTZfYmVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgWGF2aWVyIExlcm95IGFuZCBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbmxldCBrZnByaW50ZiBrIG8gKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIG8gYWNjOyBrIG8pIEVuZF9vZl9hY2MgZm10XG5sZXQga2JwcmludGYgayBiIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gYnVmcHV0X2FjYyBiIGFjYzsgayBiKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGlrZnByaW50ZiBrIG9jIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgb2MgZm10XG5cbmxldCBmcHJpbnRmIG9jIGZtdCA9IGtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBicHJpbnRmIGIgZm10ID0ga2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgaWZwcmludGYgb2MgZm10ID0gaWtmcHJpbnRmIGlnbm9yZSBvYyBmbXRcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRvdXQgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZGVyciBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgaycgYWNjID1cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSA2NCBpblxuICAgIHN0cnB1dF9hY2MgYnVmIGFjYztcbiAgICBrIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdFxuXG5sZXQgc3ByaW50ZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgLT4gcykgZm10XG5cbmxldCBrcHJpbnRmID0ga3NwcmludGZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBrZXkgPSBzdHJpbmdcbnR5cGUgZG9jID0gc3RyaW5nXG50eXBlIHVzYWdlX21zZyA9IHN0cmluZ1xudHlwZSBhbm9uX2Z1biA9IChzdHJpbmcgLT4gdW5pdClcblxudHlwZSBzcGVjID1cbiAgfCBVbml0IG9mICh1bml0IC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHVuaXQgYXJndW1lbnQgKilcbiAgfCBCb29sIG9mIChib29sIC0+IHVuaXQpICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgYm9vbCBhcmd1bWVudCAqKVxuICB8IFNldCBvZiBib29sIHJlZiAgICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRydWUgKilcbiAgfCBDbGVhciBvZiBib29sIHJlZiAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byBmYWxzZSAqKVxuICB8IFN0cmluZyBvZiAoc3RyaW5nIC0+IHVuaXQpICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBTZXRfc3RyaW5nIG9mIHN0cmluZyByZWYgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgSW50IG9mIChpbnQgLT4gdW5pdCkgICAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhbiBpbnQgYXJndW1lbnQgKilcbiAgfCBTZXRfaW50IG9mIGludCByZWYgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgaW50IGFyZ3VtZW50ICopXG4gIHwgRmxvYXQgb2YgKGZsb2F0IC0+IHVuaXQpICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgU2V0X2Zsb2F0IG9mIGZsb2F0IHJlZiAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGZsb2F0IGFyZ3VtZW50ICopXG4gIHwgVHVwbGUgb2Ygc3BlYyBsaXN0ICAgICAgICAgKCogVGFrZSBzZXZlcmFsIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlYyBsaXN0ICopXG4gIHwgU3ltYm9sIG9mIHN0cmluZyBsaXN0ICogKHN0cmluZyAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFRha2Ugb25lIG9mIHRoZSBzeW1ib2xzIGFzIGFyZ3VtZW50IGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHN5bWJvbC4gKilcbiAgfCBSZXN0IG9mIChzdHJpbmcgLT4gdW5pdCkgICAoKiBTdG9wIGludGVycHJldGluZyBrZXl3b3JkcyBhbmQgY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB3aXRoIGVhY2ggcmVtYWluaW5nIGFyZ3VtZW50ICopXG4gIHwgRXhwYW5kIG9mIChzdHJpbmcgLT4gc3RyaW5nIGFycmF5KSAoKiBJZiB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbXCItZm9vXCI7IFwiYXJnXCJdIEAgcmVzdF0gd2hlcmUgXCJmb29cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcmVnaXN0ZXJlZCBhcyBbRXhwYW5kIGZdLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzIFtmIFwiYXJnXCIgQCByZXN0XSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC4gT25seSBhbGxvd2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNdLiAqKVxuXG5leGNlcHRpb24gQmFkIG9mIHN0cmluZ1xuZXhjZXB0aW9uIEhlbHAgb2Ygc3RyaW5nXG5cbnR5cGUgZXJyb3IgPVxuICB8IFVua25vd24gb2Ygc3RyaW5nXG4gIHwgV3Jvbmcgb2Ygc3RyaW5nICogc3RyaW5nICogc3RyaW5nICAoKiBvcHRpb24sIGFjdHVhbCwgZXhwZWN0ZWQgKilcbiAgfCBNaXNzaW5nIG9mIHN0cmluZ1xuICB8IE1lc3NhZ2Ugb2Ygc3RyaW5nXG5cbmV4Y2VwdGlvbiBTdG9wIG9mIGVycm9yICgqIHVzZWQgaW50ZXJuYWxseSAqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcmVjIGFzc29jMyB4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoeTEsIHkyLCBfKSA6OiBfIHdoZW4geTEgPSB4IC0+IHkyXG4gIHwgXyA6OiB0IC0+IGFzc29jMyB4IHRcblxuXG5sZXQgc3BsaXQgcyA9XG4gIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJz0nIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgU3RyaW5nLnN1YiBzIDAgaSwgU3RyaW5nLnN1YiBzIChpKzEpIChsZW4tKGkrMSkpXG5cblxubGV0IG1ha2Vfc3ltbGlzdCBwcmVmaXggc2VwIHN1ZmZpeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gXCI8bm9uZT5cIlxuICB8IGg6OnQgLT4gKExpc3QuZm9sZF9sZWZ0IChmdW4geCB5IC0+IHggXiBzZXAgXiB5KSAocHJlZml4IF4gaCkgdCkgXiBzdWZmaXhcblxuXG5sZXQgcHJpbnRfc3BlYyBidWYgKGtleSwgc3BlYywgZG9jKSA9XG4gIGlmIFN0cmluZy5sZW5ndGggZG9jID4gMCB0aGVuXG4gICAgbWF0Y2ggc3BlYyB3aXRoXG4gICAgfCBTeW1ib2wgKGwsIF8pIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlcyVzXFxuXCIga2V5IChtYWtlX3N5bWxpc3QgXCJ7XCIgXCJ8XCIgXCJ9XCIgbCkgZG9jXG4gICAgfCBfIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlc1xcblwiIGtleSBkb2NcblxuXG5sZXQgaGVscF9hY3Rpb24gKCkgPSByYWlzZSAoU3RvcCAoVW5rbm93biBcIi1oZWxwXCIpKVxuXG5sZXQgYWRkX2hlbHAgc3BlY2xpc3QgPVxuICBsZXQgYWRkMSA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgYW5kIGFkZDIgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi0taGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLS1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgaW5cbiAgc3BlY2xpc3QgQCAoYWRkMSBAIGFkZDIpXG5cblxubGV0IHVzYWdlX2IgYnVmIHNwZWNsaXN0IGVycm1zZyA9XG4gIGJwcmludGYgYnVmIFwiJXNcXG5cIiBlcnJtc2c7XG4gIExpc3QuaXRlciAocHJpbnRfc3BlYyBidWYpIChhZGRfaGVscCBzcGVjbGlzdClcblxuXG5sZXQgdXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZyA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgdXNhZ2VfYiBiIHNwZWNsaXN0IGVycm1zZztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgdXNhZ2Ugc3BlY2xpc3QgZXJybXNnID1cbiAgZXByaW50ZiBcIiVzXCIgKHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cpXG5cblxubGV0IGN1cnJlbnQgPSByZWYgMFxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoYm9vbF9vZl9zdHJpbmcgeClcbiAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGFsbG93X2V4cGFuZCBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJtc2cgPVxuICBsZXQgaW5pdHBvcyA9ICFjdXJyZW50IGluXG4gIGxldCBjb252ZXJ0X2Vycm9yIGVycm9yID1cbiAgICAoKiBjb252ZXJ0IGFuIGludGVybmFsIGVycm9yIHRvIGEgQmFkL0hlbHAgZXhjZXB0aW9uXG4gICAgICAgKm9yKiBhZGQgdGhlIHByb2dyYW0gbmFtZSBhcyBhIHByZWZpeCBhbmQgdGhlIHVzYWdlIG1lc3NhZ2UgYXMgYSBzdWZmaXhcbiAgICAgICB0byBhbiB1c2VyLXJhaXNlZCBCYWQgZXhjZXB0aW9uLlxuICAgICopXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICAgIGxldCBwcm9nbmFtZSA9XG4gICAgICBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPj0gMSAmJiBzLlswXSA9ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBub19hcmcgKCk7IGYgKCk7XG4gICAgICAgIHwgQm9vbCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggYm9vbF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBib29sZWFuXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSBzIC0+IGYgc1xuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0IHIgLT4gbm9fYXJnICgpOyByIDo9IHRydWU7XG4gICAgICAgIHwgQ2xlYXIgciAtPiBub19hcmcgKCk7IHIgOj0gZmFsc2U7XG4gICAgICAgIHwgU3RyaW5nIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFN5bWJvbCAoc3ltYiwgZikgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBpZiBMaXN0Lm1lbSBhcmcgc3ltYiB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm9uZSBvZjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gKG1ha2Vfc3ltbGlzdCBcIlwiIFwiIFwiIFwiXCIgc3ltYikpKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IFNldF9zdHJpbmcgciAtPlxuICAgICAgICAgICAgciA6PSBnZXRfYXJnICgpO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgSW50IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfaW50IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBGbG9hdCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfZmxvYXQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgVHVwbGUgc3BlY3MgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIExpc3QuaXRlciB0cmVhdF9hY3Rpb24gc3BlY3M7XG4gICAgICAgIHwgUmVzdCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIC0gMSBkb1xuICAgICAgICAgICAgICBmICFhcmd2LighY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgIHwgRXhwYW5kIGYgLT5cbiAgICAgICAgICAgIGlmIG5vdCBhbGxvd19leHBhbmQgdGhlblxuICAgICAgICAgICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkFyZy5FeHBhbmQgaXMgaXMgb25seSBhbGxvd2VkIHdpdGggXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZy5wYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY1wiKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBsZXQgbmV3YXJnID0gZiBhcmcgaW5cbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IEFycmF5LnN1YiAhYXJndiAwICghY3VycmVudCArIDEpXG4gICAgICAgICAgICBhbmQgYWZ0ZXIgPVxuICAgICAgICAgICAgICBBcnJheS5zdWIgIWFyZ3YgKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICgoQXJyYXkubGVuZ3RoICFhcmd2KSAtICFjdXJyZW50IC0gMSkgaW5cbiAgICAgICAgICAgIGFyZ3Y6PSBBcnJheS5jb25jYXQgW2JlZm9yZTtuZXdhcmc7YWZ0ZXJdO1xuICAgICAgICBpblxuICAgICAgICB0cmVhdF9hY3Rpb24gYWN0aW9uIGVuZFxuICAgICAgZWxzZSBhbm9uZnVuIHNcbiAgICB3aXRoIHwgQmFkIG0gLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgKE1lc3NhZ2UgbSkpO1xuICAgICAgICAgfCBTdG9wIGUgLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgZSk7XG4gICAgZW5kO1xuICAgIGluY3IgY3VycmVudFxuICBkb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggdHJ1ZSBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2dcblxubGV0IHBhcnNlX2FyZ3ZfZHluYW1pYyA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBmYWxzZSBjdXJyZW50IChyZWYgYXJndikgc3BlY2xpc3QgYW5vbmZ1blxuICAgIGVycm1zZ1xuXG5cbmxldCBwYXJzZV9hcmd2ID8oY3VycmVudD1jdXJyZW50KSBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYXJndl9keW5hbWljIH5jdXJyZW50OmN1cnJlbnQgYXJndiAocmVmIHNwZWNsaXN0KSBhbm9uZnVuIGVycm1zZ1xuXG5cbmxldCBwYXJzZSBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndiBTeXMuYXJndiBsIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBwYXJzZV9keW5hbWljIGwgZiBtc2cgPVxuICB0cnlcbiAgICBwYXJzZV9hcmd2X2R5bmFtaWMgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxubGV0IHBhcnNlX2V4cGFuZCBsIGYgbXNnID1cbiAgdHJ5XG4gICAgbGV0IGFyZ3YgPSByZWYgU3lzLmFyZ3YgaW5cbiAgICBsZXQgc3BlYyA9IHJlZiBsIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgKCFjdXJyZW50KSBpblxuICAgIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljIGN1cnJlbnQgYXJndiBzcGVjIGYgbXNnXG4gIHdpdGhcbiAgfCBCYWQgbXNnIC0+IGVwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAyXG4gIHwgSGVscCBtc2cgLT4gcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuXG5cbmxldCBzZWNvbmRfd29yZCBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgbiA9XG4gICAgaWYgbiA+PSBsZW4gdGhlbiBsZW5cbiAgICBlbHNlIGlmIHMuW25dID0gJyAnIHRoZW4gbG9vcCAobisxKVxuICAgIGVsc2UgblxuICBpblxuICBtYXRjaCBTdHJpbmcuaW5kZXggcyAnXFx0JyB3aXRoXG4gIHwgbiAtPiBsb29wIChuKzEpXG4gIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggU3RyaW5nLmluZGV4IHMgJyAnIHdpdGhcbiAgICAgIHwgbiAtPiBsb29wIChuKzEpXG4gICAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gbGVuXG4gICAgICBlbmRcblxuXG5sZXQgbWF4X2FyZ19sZW4gY3VyIChrd2QsIHNwZWMsIGRvYykgPVxuICBtYXRjaCBzcGVjIHdpdGhcbiAgfCBTeW1ib2wgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZClcbiAgfCBfIC0+IG1heCBjdXIgKFN0cmluZy5sZW5ndGgga3dkICsgc2Vjb25kX3dvcmQgZG9jKVxuXG5cbmxldCByZXBsYWNlX2xlYWRpbmdfdGFiIHMgPVxuICBsZXQgc2VlbiA9IHJlZiBmYWxzZSBpblxuICBTdHJpbmcubWFwIChmdW5jdGlvbiAnXFx0JyB3aGVuIG5vdCAhc2VlbiAtPiBzZWVuIDo9IHRydWU7ICcgJyB8IGMgLT4gYykgc1xuXG5sZXQgYWRkX3BhZGRpbmcgbGVuIGtzZCA9XG4gIG1hdGNoIGtzZCB3aXRoXG4gIHwgKF8sIF8sIFwiXCIpIC0+XG4gICAgICAoKiBEbyBub3QgcGFkIHVuZG9jdW1lbnRlZCBvcHRpb25zLCBzbyB0aGF0IHRoZXkgc3RpbGwgZG9uJ3Qgc2hvdyB1cCB3aGVuXG4gICAgICAgKiBydW4gdGhyb3VnaCBbdXNhZ2VdIG9yIFtwYXJzZV0uICopXG4gICAgICBrc2RcbiAgfCAoa3dkLCAoU3ltYm9sIF8gYXMgc3BlYyksIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSAoKG1heCAwIChsZW4gLSBjdXRjb2wpKSArIDMpICcgJyBpblxuICAgICAgKGt3ZCwgc3BlYywgXCJcXG5cIiBeIHNwYWNlcyBeIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICB8IChrd2QsIHNwZWMsIG1zZykgLT5cbiAgICAgIGxldCBjdXRjb2wgPSBzZWNvbmRfd29yZCBtc2cgaW5cbiAgICAgIGxldCBrd2RfbGVuID0gU3RyaW5nLmxlbmd0aCBrd2QgaW5cbiAgICAgIGxldCBkaWZmID0gbGVuIC0ga3dkX2xlbiAtIGN1dGNvbCBpblxuICAgICAgaWYgZGlmZiA8PSAwIHRoZW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBzcGFjZXMgPSBTdHJpbmcubWFrZSBkaWZmICcgJyBpblxuICAgICAgICBsZXQgcHJlZml4ID0gU3RyaW5nLnN1YiAocmVwbGFjZV9sZWFkaW5nX3RhYiBtc2cpIDAgY3V0Y29sIGluXG4gICAgICAgIGxldCBzdWZmaXggPSBTdHJpbmcuc3ViIG1zZyBjdXRjb2wgKFN0cmluZy5sZW5ndGggbXNnIC0gY3V0Y29sKSBpblxuICAgICAgICAoa3dkLCBzcGVjLCBwcmVmaXggXiBzcGFjZXMgXiBzdWZmaXgpXG5cblxubGV0IGFsaWduID8obGltaXQ9bWF4X2ludCkgc3BlY2xpc3QgPVxuICBsZXQgY29tcGxldGVkID0gYWRkX2hlbHAgc3BlY2xpc3QgaW5cbiAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IG1heF9hcmdfbGVuIDAgY29tcGxldGVkIGluXG4gIGxldCBsZW4gPSBtaW4gbGVuIGxpbWl0IGluXG4gIExpc3QubWFwIChhZGRfcGFkZGluZyBsZW4pIGNvbXBsZXRlZFxuXG5sZXQgdHJpbV9jciBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBpZiBsZW4gPiAwICYmIFN0cmluZy5nZXQgcyAobGVuIC0gMSkgPSAnXFxyJyB0aGVuXG4gICAgU3RyaW5nLnN1YiBzIDAgKGxlbiAtIDEpXG4gIGVsc2VcbiAgICBzXG5cbmxldCByZWFkX2F1eCB0cmltIHNlcCBmaWxlID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZSBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgbGV0IHdvcmRzID0gcmVmIFtdIGluXG4gIGxldCBzdGFzaCAoKSA9XG4gICAgbGV0IHdvcmQgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgbGV0IHdvcmQgPSBpZiB0cmltIHRoZW4gdHJpbV9jciB3b3JkIGVsc2Ugd29yZCBpblxuICAgIHdvcmRzIDo9IHdvcmQgOjogIXdvcmRzO1xuICAgIEJ1ZmZlci5jbGVhciBidWZcbiAgaW5cbiAgYmVnaW5cbiAgICB0cnkgd2hpbGUgdHJ1ZSBkb1xuICAgICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgICAgaWYgYyA9IHNlcCB0aGVuIHN0YXNoICgpIGVsc2UgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gICAgICBkb25lXG4gICAgd2l0aCBFbmRfb2ZfZmlsZSAtPiAoKVxuICBlbmQ7XG4gIGlmIEJ1ZmZlci5sZW5ndGggYnVmID4gMCB0aGVuIHN0YXNoICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcbmxldCBjb25zdCBjIF8gPSBjXG5sZXQgZmxpcCBmIHggeSA9IGYgeSB4XG5sZXQgbmVnYXRlIHAgdiA9IG5vdCAocCB2KVxuXG5leGNlcHRpb24gRmluYWxseV9yYWlzZWQgb2YgZXhuXG5cbmxldCBwcm90ZWN0IH4oZmluYWxseSA6IHVuaXQgLT4gdW5pdCkgd29yayA9XG4gIGxldCBmaW5hbGx5X25vX2V4biAoKSA9XG4gICAgdHJ5IGZpbmFsbHkgKCkgd2l0aCBlIC0+XG4gICAgICBsZXQgYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2UgKEZpbmFsbHlfcmFpc2VkIGUpIGJ0XG4gIGluXG4gIG1hdGNoIHdvcmsgKCkgd2l0aFxuICB8IHJlc3VsdCAtPiBmaW5hbGx5X25vX2V4biAoKSA7IHJlc3VsdFxuICB8IGV4Y2VwdGlvbiB3b3JrX2V4biAtPlxuICAgICAgbGV0IHdvcmtfYnQgPSBQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICAgZmluYWxseV9ub19leG4gKCkgO1xuICAgICAgUHJpbnRleGMucmFpc2Vfd2l0aF9iYWNrdHJhY2Ugd29ya19leG4gd29ya19idFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBKYWNxdWVzLUhlbnJpIEpvdXJkYW4sIHByb2pldCBHYWxsaXVtLCBJTlJJQSBQYXJpcyAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5Ni0yMDE2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgICAqKVxuKCogICAgIGV0IGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHN0YXQgPSB7XG4gIG1pbm9yX3dvcmRzIDogZmxvYXQ7XG4gIHByb21vdGVkX3dvcmRzIDogZmxvYXQ7XG4gIG1ham9yX3dvcmRzIDogZmxvYXQ7XG4gIG1pbm9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBtYWpvcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgaGVhcF93b3JkcyA6IGludDtcbiAgaGVhcF9jaHVua3MgOiBpbnQ7XG4gIGxpdmVfd29yZHMgOiBpbnQ7XG4gIGxpdmVfYmxvY2tzIDogaW50O1xuICBmcmVlX3dvcmRzIDogaW50O1xuICBmcmVlX2Jsb2NrcyA6IGludDtcbiAgbGFyZ2VzdF9mcmVlIDogaW50O1xuICBmcmFnbWVudHMgOiBpbnQ7XG4gIGNvbXBhY3Rpb25zIDogaW50O1xuICB0b3BfaGVhcF93b3JkcyA6IGludDtcbiAgc3RhY2tfc2l6ZSA6IGludDtcbn1cblxudHlwZSBjb250cm9sID0ge1xuICBtdXRhYmxlIG1pbm9yX2hlYXBfc2l6ZSA6IGludDtcbiAgbXV0YWJsZSBtYWpvcl9oZWFwX2luY3JlbWVudCA6IGludDtcbiAgbXV0YWJsZSBzcGFjZV9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSB2ZXJib3NlIDogaW50O1xuICBtdXRhYmxlIG1heF9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSBzdGFja19saW1pdCA6IGludDtcbiAgbXV0YWJsZSBhbGxvY2F0aW9uX3BvbGljeSA6IGludDtcbiAgd2luZG93X3NpemUgOiBpbnQ7XG4gIGN1c3RvbV9tYWpvcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfbWF4X3NpemUgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2Nfc3RhdFwiXG5leHRlcm5hbCBxdWlja19zdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3F1aWNrX3N0YXRcIlxuZXh0ZXJuYWwgY291bnRlcnMgOiB1bml0IC0+IChmbG9hdCAqIGZsb2F0ICogZmxvYXQpID0gXCJjYW1sX2djX2NvdW50ZXJzXCJcbmV4dGVybmFsIG1pbm9yX3dvcmRzIDogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSlcbiAgPSBcImNhbWxfZ2NfbWlub3Jfd29yZHNcIiBcImNhbWxfZ2NfbWlub3Jfd29yZHNfdW5ib3hlZFwiXG5leHRlcm5hbCBnZXQgOiB1bml0IC0+IGNvbnRyb2wgPSBcImNhbWxfZ2NfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGNvbnRyb2wgLT4gdW5pdCA9IFwiY2FtbF9nY19zZXRcIlxuZXh0ZXJuYWwgbWlub3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWlub3JcIlxuZXh0ZXJuYWwgbWFqb3Jfc2xpY2UgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2djX21ham9yX3NsaWNlXCJcbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIGZ1bGxfbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfZnVsbF9tYWpvclwiXG5leHRlcm5hbCBjb21wYWN0IDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2NvbXBhY3Rpb25cIlxuZXh0ZXJuYWwgZ2V0X21pbm9yX2ZyZWUgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWlub3JfZnJlZVwiXG5leHRlcm5hbCBnZXRfYnVja2V0IDogaW50IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfYnVja2V0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGdldF9jcmVkaXQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGh1Z2VfZmFsbGJhY2tfY291bnQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XCJcblxub3BlbiBQcmludGZcblxubGV0IHByaW50X3N0YXQgYyA9XG4gIGxldCBzdCA9IHN0YXQgKCkgaW5cbiAgZnByaW50ZiBjIFwibWlub3JfY29sbGVjdGlvbnM6ICVkXFxuXCIgc3QubWlub3JfY29sbGVjdGlvbnM7XG4gIGZwcmludGYgYyBcIm1ham9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0Lm1ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJjb21wYWN0aW9uczogICAgICAgJWRcXG5cIiBzdC5jb21wYWN0aW9ucztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMSA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlLjBmXCIgc3QubWlub3Jfd29yZHMpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1pbm9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJwcm9tb3RlZF93b3JkczogJSouMGZcXG5cIiBsMSBzdC5wcm9tb3RlZF93b3JkcztcbiAgZnByaW50ZiBjIFwibWFqb3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWFqb3Jfd29yZHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDIgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJWRcIiBzdC50b3BfaGVhcF93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwidG9wX2hlYXBfd29yZHM6ICUqZFxcblwiIGwyIHN0LnRvcF9oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJoZWFwX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwibGl2ZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmxpdmVfd29yZHM7XG4gIGZwcmludGYgYyBcImZyZWVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5mcmVlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsYXJnZXN0X2ZyZWU6ICAgJSpkXFxuXCIgbDIgc3QubGFyZ2VzdF9mcmVlO1xuICBmcHJpbnRmIGMgXCJmcmFnbWVudHM6ICAgICAgJSpkXFxuXCIgbDIgc3QuZnJhZ21lbnRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgZnByaW50ZiBjIFwibGl2ZV9ibG9ja3M6ICVkXFxuXCIgc3QubGl2ZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImZyZWVfYmxvY2tzOiAlZFxcblwiIHN0LmZyZWVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJoZWFwX2NodW5rczogJWRcXG5cIiBzdC5oZWFwX2NodW5rc1xuXG5cbmxldCBhbGxvY2F0ZWRfYnl0ZXMgKCkgPVxuICBsZXQgKG1pLCBwcm8sIG1hKSA9IGNvdW50ZXJzICgpIGluXG4gIChtaSArLiBtYSAtLiBwcm8pICouIGZsb2F0X29mX2ludCAoU3lzLndvcmRfc2l6ZSAvIDgpXG5cblxuZXh0ZXJuYWwgZmluYWxpc2UgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWdpc3RlclwiXG5leHRlcm5hbCBmaW5hbGlzZV9sYXN0IDogKHVuaXQgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdCA9XG4gIFwiY2FtbF9maW5hbF9yZWdpc3Rlcl9jYWxsZWRfd2l0aG91dF92YWx1ZVwiXG5leHRlcm5hbCBmaW5hbGlzZV9yZWxlYXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlbGVhc2VcIlxuXG5cbnR5cGUgYWxhcm0gPSBib29sIHJlZlxudHlwZSBhbGFybV9yZWMgPSB7YWN0aXZlIDogYWxhcm07IGYgOiB1bml0IC0+IHVuaXR9XG5cbmxldCByZWMgY2FsbF9hbGFybSBhcmVjID1cbiAgaWYgIShhcmVjLmFjdGl2ZSkgdGhlbiBiZWdpblxuICAgIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgICBhcmVjLmYgKCk7XG4gIGVuZFxuXG5cbmxldCBjcmVhdGVfYWxhcm0gZiA9XG4gIGxldCBhcmVjID0geyBhY3RpdmUgPSByZWYgdHJ1ZTsgZiA9IGYgfSBpblxuICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gIGFyZWMuYWN0aXZlXG5cblxubGV0IGRlbGV0ZV9hbGFybSBhID0gYSA6PSBmYWxzZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNZXNzYWdlIGRpZ2VzdCAoTUQ1KSAqKVxuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgPSBTdHJpbmcuY29tcGFyZVxubGV0IGVxdWFsID0gU3RyaW5nLmVxdWFsXG5cbmV4dGVybmFsIHVuc2FmZV9zdHJpbmc6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X3N0cmluZ1wiXG5leHRlcm5hbCBjaGFubmVsOiBpbl9jaGFubmVsIC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9jaGFuXCJcblxubGV0IHN0cmluZyBzdHIgPVxuICB1bnNhZmVfc3RyaW5nIHN0ciAwIChTdHJpbmcubGVuZ3RoIHN0cilcblxubGV0IGJ5dGVzIGIgPSBzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYilcblxubGV0IHN1YnN0cmluZyBzdHIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBTdHJpbmcubGVuZ3RoIHN0ciAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnN1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX3N0cmluZyBzdHIgb2ZzIGxlblxuXG5sZXQgc3ViYnl0ZXMgYiBvZnMgbGVuID0gc3Vic3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpIG9mcyBsZW5cblxubGV0IGZpbGUgZmlsZW5hbWUgPVxuICBsZXQgaWMgPSBvcGVuX2luX2JpbiBmaWxlbmFtZSBpblxuICBtYXRjaCBjaGFubmVsIGljICgtMSkgd2l0aFxuICAgIHwgZCAtPiBjbG9zZV9pbiBpYzsgZFxuICAgIHwgZXhjZXB0aW9uIGUgLT4gY2xvc2VfaW4gaWM7IHJhaXNlIGVcblxubGV0IG91dHB1dCBjaGFuIGRpZ2VzdCA9XG4gIG91dHB1dF9zdHJpbmcgY2hhbiBkaWdlc3RcblxubGV0IGlucHV0IGNoYW4gPSByZWFsbHlfaW5wdXRfc3RyaW5nIGNoYW4gMTZcblxubGV0IGNoYXJfaGV4IG4gPVxuICBDaGFyLnVuc2FmZV9jaHIgKG4gKyBpZiBuIDwgMTAgdGhlbiBDaGFyLmNvZGUgJzAnIGVsc2UgKENoYXIuY29kZSAnYScgLSAxMCkpXG5cbmxldCB0b19oZXggZCA9XG4gIGlmIFN0cmluZy5sZW5ndGggZCA8PiAxNiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LnRvX2hleFwiO1xuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDMyIGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIGxldCB4ID0gQ2hhci5jb2RlIGQuW2ldIGluXG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMikgKGNoYXJfaGV4ICh4IGxzciA0KSk7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXN1bHQgKGkqMisxKSAoY2hhcl9oZXggKHggbGFuZCAweDBmKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG5cbmxldCBmcm9tX2hleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzIDw+IDMyIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QuZnJvbV9oZXhcIjtcbiAgbGV0IGRpZ2l0IGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJzAnLi4nOScgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnQScuLidGJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgJ2EnLi4nZicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8IF8gLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJEaWdlc3QuZnJvbV9oZXhcIilcbiAgaW5cbiAgbGV0IGJ5dGUgaSA9IGRpZ2l0IHMuW2ldIGxzbCA0ICsgZGlnaXQgcy5baSsxXSBpblxuICBsZXQgcmVzdWx0ID0gQnl0ZXMuY3JlYXRlIDE2IGluXG4gIGZvciBpID0gMCB0byAxNSBkb1xuICAgIEJ5dGVzLnNldCByZXN1bHQgaSAoQ2hhci5jaHIgKGJ5dGUgKDIgKiBpKSkpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3JcbiAgIFRoaXMgaXMgYSBsYWdnZWQtRmlib25hY2NpIEYoNTUsIDI0LCArKSB3aXRoIGEgbW9kaWZpZWQgYWRkaXRpb25cbiAgIGZ1bmN0aW9uIHRvIGVuaGFuY2UgdGhlIG1peGluZyBvZiBiaXRzLlxuICAgSWYgd2UgdXNlIG5vcm1hbCBhZGRpdGlvbiwgdGhlIGxvdy1vcmRlciBiaXQgZmFpbHMgdGVzdHMgMSBhbmQgN1xuICAgb2YgdGhlIERpZWhhcmQgdGVzdCBzdWl0ZSwgYW5kIGJpdHMgMSBhbmQgMiBhbHNvIGZhaWwgdGVzdCA3LlxuICAgSWYgd2UgdXNlIG11bHRpcGxpY2F0aW9uIGFzIHN1Z2dlc3RlZCBieSBNYXJzYWdsaWEsIGl0IGRvZXNuJ3QgZmFyZVxuICAgbXVjaCBiZXR0ZXIuXG4gICBCeSBtaXhpbmcgdGhlIGJpdHMgb2Ygb25lIG9mIHRoZSBudW1iZXJzIGJlZm9yZSBhZGRpdGlvbiAoWE9SIHRoZVxuICAgNSBoaWdoLW9yZGVyIGJpdHMgaW50byB0aGUgbG93LW9yZGVyIGJpdHMpLCB3ZSBnZXQgYSBnZW5lcmF0b3IgdGhhdFxuICAgcGFzc2VzIGFsbCB0aGUgRGllaGFyZCB0ZXN0cy5cbiopXG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkOiB1bml0IC0+IGludCBhcnJheSA9IFwiY2FtbF9zeXNfcmFuZG9tX3NlZWRcIlxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSB7IHN0IDogaW50IGFycmF5OyBtdXRhYmxlIGlkeCA6IGludCB9XG5cbiAgbGV0IG5ld19zdGF0ZSAoKSA9IHsgc3QgPSBBcnJheS5tYWtlIDU1IDA7IGlkeCA9IDAgfVxuICBsZXQgYXNzaWduIHN0MSBzdDIgPVxuICAgIEFycmF5LmJsaXQgc3QyLnN0IDAgc3QxLnN0IDAgNTU7XG4gICAgc3QxLmlkeCA8LSBzdDIuaWR4XG5cblxuICBsZXQgZnVsbF9pbml0IHMgc2VlZCA9XG4gICAgbGV0IGNvbWJpbmUgYWNjdSB4ID0gRGlnZXN0LnN0cmluZyAoYWNjdSBeIEludC50b19zdHJpbmcgeCkgaW5cbiAgICBsZXQgZXh0cmFjdCBkID1cbiAgICAgIENoYXIuY29kZSBkLlswXSArIChDaGFyLmNvZGUgZC5bMV0gbHNsIDgpICsgKENoYXIuY29kZSBkLlsyXSBsc2wgMTYpXG4gICAgICArIChDaGFyLmNvZGUgZC5bM10gbHNsIDI0KVxuICAgIGluXG4gICAgbGV0IHNlZWQgPSBpZiBBcnJheS5sZW5ndGggc2VlZCA9IDAgdGhlbiBbfCAwIHxdIGVsc2Ugc2VlZCBpblxuICAgIGxldCBsID0gQXJyYXkubGVuZ3RoIHNlZWQgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgZG9cbiAgICAgIHMuc3QuKGkpIDwtIGk7XG4gICAgZG9uZTtcbiAgICBsZXQgYWNjdSA9IHJlZiBcInhcIiBpblxuICAgIGZvciBpID0gMCB0byA1NCArIG1heCA1NSBsIGRvXG4gICAgICBsZXQgaiA9IGkgbW9kIDU1IGluXG4gICAgICBsZXQgayA9IGkgbW9kIGwgaW5cbiAgICAgIGFjY3UgOj0gY29tYmluZSAhYWNjdSBzZWVkLihrKTtcbiAgICAgIHMuc3QuKGopIDwtIChzLnN0LihqKSBseG9yIGV4dHJhY3QgIWFjY3UpIGxhbmQgMHgzRkZGRkZGRjsgICgqIFBSIzU1NzUgKilcbiAgICBkb25lO1xuICAgIHMuaWR4IDwtIDBcblxuXG4gIGxldCBtYWtlIHNlZWQgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBmdWxsX2luaXQgcmVzdWx0IHNlZWQ7XG4gICAgcmVzdWx0XG5cblxuICBsZXQgbWFrZV9zZWxmX2luaXQgKCkgPSBtYWtlIChyYW5kb21fc2VlZCAoKSlcblxuICBsZXQgY29weSBzID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgYXNzaWduIHJlc3VsdCBzO1xuICAgIHJlc3VsdFxuXG5cbiAgKCogUmV0dXJucyAzMCByYW5kb20gYml0cyBhcyBhbiBpbnRlZ2VyIDAgPD0geCA8IDEwNzM3NDE4MjQgKilcbiAgbGV0IGJpdHMgcyA9XG4gICAgcy5pZHggPC0gKHMuaWR4ICsgMSkgbW9kIDU1O1xuICAgIGxldCBjdXJ2YWwgPSBzLnN0LihzLmlkeCkgaW5cbiAgICBsZXQgbmV3dmFsID0gcy5zdC4oKHMuaWR4ICsgMjQpIG1vZCA1NSlcbiAgICAgICAgICAgICAgICAgKyAoY3VydmFsIGx4b3IgKChjdXJ2YWwgbHNyIDI1KSBsYW5kIDB4MUYpKSBpblxuICAgIGxldCBuZXd2YWwzMCA9IG5ld3ZhbCBsYW5kIDB4M0ZGRkZGRkYgaW4gICgqIFBSIzU1NzUgKilcbiAgICBzLnN0LihzLmlkeCkgPC0gbmV3dmFsMzA7XG4gICAgbmV3dmFsMzBcblxuXG4gIGxldCByZWMgaW50YXV4IHMgbiA9XG4gICAgbGV0IHIgPSBiaXRzIHMgaW5cbiAgICBsZXQgdiA9IHIgbW9kIG4gaW5cbiAgICBpZiByIC0gdiA+IDB4M0ZGRkZGRkYgLSBuICsgMSB0aGVuIGludGF1eCBzIG4gZWxzZSB2XG5cbiAgbGV0IGludCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA+IDB4M0ZGRkZGRkYgfHwgYm91bmQgPD0gMFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50XCJcbiAgICBlbHNlIGludGF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDMyYXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50MzIub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50MzIuc2hpZnRfbGVmdCAoSW50MzIub2ZfaW50IChiaXRzIHMgbGFuZCAxKSkgMzAgaW5cbiAgICBsZXQgciA9IEludDMyLmxvZ29yIGIxIGIyIGluXG4gICAgbGV0IHYgPSBJbnQzMi5yZW0gciBuIGluXG4gICAgaWYgSW50MzIuc3ViIHIgdiA+IEludDMyLmFkZCAoSW50MzIuc3ViIEludDMyLm1heF9pbnQgbikgMWxcbiAgICB0aGVuIGludDMyYXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQzMiBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50MzJcIlxuICAgIGVsc2UgaW50MzJhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQ2NGF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDY0Lm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzKSkgMzAgaW5cbiAgICBsZXQgYjMgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcyBsYW5kIDcpKSA2MCBpblxuICAgIGxldCByID0gSW50NjQubG9nb3IgYjEgKEludDY0LmxvZ29yIGIyIGIzKSBpblxuICAgIGxldCB2ID0gSW50NjQucmVtIHIgbiBpblxuICAgIGlmIEludDY0LnN1YiByIHYgPiBJbnQ2NC5hZGQgKEludDY0LnN1YiBJbnQ2NC5tYXhfaW50IG4pIDFMXG4gICAgdGhlbiBpbnQ2NGF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50NjQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMExcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDY0XCJcbiAgICBlbHNlIGludDY0YXV4IHMgYm91bmRcblxuXG4gIGxldCBuYXRpdmVpbnQgPVxuICAgIGlmIE5hdGl2ZWludC5zaXplID0gMzJcbiAgICB0aGVuIGZ1biBzIGJvdW5kIC0+IE5hdGl2ZWludC5vZl9pbnQzMiAoaW50MzIgcyAoTmF0aXZlaW50LnRvX2ludDMyIGJvdW5kKSlcbiAgICBlbHNlIGZ1biBzIGJvdW5kIC0+IEludDY0LnRvX25hdGl2ZWludCAoaW50NjQgcyAoSW50NjQub2ZfbmF0aXZlaW50IGJvdW5kKSlcblxuXG4gICgqIFJldHVybnMgYSBmbG9hdCAwIDw9IHggPD0gMSB3aXRoIGF0IG1vc3QgNjAgYml0cyBvZiBwcmVjaXNpb24uICopXG4gIGxldCByYXdmbG9hdCBzID1cbiAgICBsZXQgc2NhbGUgPSAxMDczNzQxODI0LjAgICgqIDJeMzAgKilcbiAgICBhbmQgcjEgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBhbmQgcjIgPSBTdGRsaWIuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IHNlZWRcbmxldCBpbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBNYW5pcHVsYXRpbmcgdGhlIGN1cnJlbnQgc3RhdGUuICopXG5cbmxldCBnZXRfc3RhdGUgKCkgPSBTdGF0ZS5jb3B5IGRlZmF1bHRcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiBkZWZhdWx0IHNcblxuKCoqKioqKioqKioqKioqKioqKioqXG5cbigqIFRlc3QgZnVuY3Rpb25zLiAgTm90IGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICAgVGhlIFtjaGlzcXVhcmVdIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBuID4gMTByLlxuICAgSXQgcmV0dXJucyBhIHRyaXBsZSAobG93LCBhY3R1YWwsIGhpZ2gpLlxuICAgSWYgbG93IDw9IGFjdHVhbCA8PSBoaWdoLCB0aGUgW2ddIGZ1bmN0aW9uIHBhc3NlZCB0aGUgdGVzdCxcbiAgIG90aGVyd2lzZSBpdCBmYWlsZWQuXG5cbiAgU29tZSByZXN1bHRzOlxuXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDUwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI5OTc5MjY0MzsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAxNDE0MjEzNjsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMjQ7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAwOyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMjQ7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDE0MTQyMTM2OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMjk5NzkyNjQzOyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbi0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTk3LjUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4OS43NDAwMDAwMDAwMDUyMzg3LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDQ4NTguNTc4NjQzNzYyNjksIDUwNDUuNSwgNTE0MS40MjEzNTYyMzczMSlcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9XG4oOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTQ0LjgwNTk5OTk5OTk4MjMwNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDE5LjE5NzQ0MDAwMDAwMzU1LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU5LjMxNzc2MDAwMDAwNTM2LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDM5Ljk4NDYzOTk5OTk5NTEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU0LjM4MjA3OTk5OTk5NTc3LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDkwLjA5NjAwMDAwMDAwNSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDc2Ljc4NzIwMDAwMDAwNjEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjE3NjAwMDAwMDAwNjc1MjEsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4yMTYwMDAwMDAwMDAzNDkyLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODAuNjIyMDAwMDAwMDAzMDI2OCwgMTIwLilcblxuKilcblxuKCogUmV0dXJuIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdltpMCxpMVsgKilcbmxldCByZWMgc3Vtc3EgdiBpMCBpMSA9XG4gIGlmIGkwID49IGkxIHRoZW4gMC4wXG4gIGVsc2UgaWYgaTEgPSBpMCArIDEgdGhlbiBTdGRsaWIuZmxvYXQgdi4oaTApICouIFN0ZGxpYi5mbG9hdCB2LihpMClcbiAgZWxzZSBzdW1zcSB2IGkwICgoaTAraTEpLzIpICsuIHN1bXNxIHYgKChpMCtpMSkvMikgaTFcblxuXG5sZXQgY2hpc3F1YXJlIGcgbiByID1cbiAgaWYgbiA8PSAxMCAqIHIgdGhlbiBpbnZhbGlkX2FyZyBcImNoaXNxdWFyZVwiO1xuICBsZXQgZiA9IEFycmF5Lm1ha2UgciAwIGluXG4gIGZvciBpID0gMSB0byBuIGRvXG4gICAgbGV0IHQgPSBnIHIgaW5cbiAgICBmLih0KSA8LSBmLih0KSArIDFcbiAgZG9uZTtcbiAgbGV0IHQgPSBzdW1zcSBmIDAgclxuICBhbmQgciA9IFN0ZGxpYi5mbG9hdCByXG4gIGFuZCBuID0gU3RkbGliLmZsb2F0IG4gaW5cbiAgbGV0IHNyID0gMi4wICouIHNxcnQgciBpblxuICAociAtLiBzciwgICAociAqLiB0IC8uIG4pIC0uIG4sICAgciArLiBzcilcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIGxpbmVhciBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbSBudW1iZXJzLlxuKilcbmxldCBzdCA9IHJlZiAwXG5sZXQgaW5pdF9kaWZmIHIgPSBzdCA6PSBpbnQgclxubGV0IGRpZmYgciA9XG4gIGxldCB4MSA9ICFzdFxuICBhbmQgeDIgPSBpbnQgclxuICBpblxuICBzdCA6PSB4MjtcbiAgaWYgeDEgPj0geDIgdGhlblxuICAgIHgxIC0geDJcbiAgZWxzZVxuICAgIHIgKyB4MSAtIHgyXG5cblxubGV0IHN0MSA9IHJlZiAwXG5hbmQgc3QyID0gcmVmIDBcblxuXG4oKiBUaGlzIGlzIHRvIHRlc3QgZm9yIHF1YWRyYXRpYyBkZXBlbmRlbmNpZXMgYmV0d2VlbiBzdWNjZXNzaXZlIHJhbmRvbVxuICAgbnVtYmVycy5cbiopXG5sZXQgaW5pdF9kaWZmMiByID0gc3QxIDo9IGludCByOyBzdDIgOj0gaW50IHJcbmxldCBkaWZmMiByID1cbiAgbGV0IHgxID0gIXN0MVxuICBhbmQgeDIgPSAhc3QyXG4gIGFuZCB4MyA9IGludCByXG4gIGluXG4gIHN0MSA6PSB4MjtcbiAgc3QyIDo9IHgzO1xuICAoeDMgLSB4MiAtIHgyICsgeDEgKyAyKnIpIG1vZCByXG5cblxuKioqKioqKioqKioqKioqKioqKiopXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEhhc2ggdGFibGVzICopXG5cbigqIFdlIGRvIGR5bmFtaWMgaGFzaGluZywgYW5kIHJlc2l6ZSB0aGUgdGFibGUgYW5kIHJlaGFzaCB0aGUgZWxlbWVudHNcbiAgIHdoZW4gYnVja2V0cyBiZWNvbWUgdG9vIGxvbmcuICopXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICBtdXRhYmxlIGRhdGE6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIEZ1bmN0aW9ucyB3aGljaCBhcHBlYXIgYmVmb3JlIHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSBtdXN0IGVpdGhlciBiZVxuICAgaW5kZXBlbmRlbnQgb2YgdGhlIGhhc2ggZnVuY3Rpb24gb3IgdGFrZSBpdCBhcyBhIHBhcmFtZXRlciAoc2VlICMyMjAyIGFuZFxuICAgY29kZSBiZWxvdyB0aGUgZnVuY3RvciBkZWZpbml0aW9ucy4gKilcblxuKCogQ3JlYXRpbmcgYSBmcmVzaCwgZW1wdHkgdGFibGUgKilcblxubGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gIGlmIHggPj0gbiB0aGVuIHhcbiAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbmxldCBjcmVhdGUgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaW5pdGlhbF9zaXplID1cbiAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbmxldCBjbGVhciBoID1cbiAgaWYgaC5zaXplID4gMCB0aGVuIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgQXJyYXkuZmlsbCBoLmRhdGEgMCAoQXJyYXkubGVuZ3RoIGguZGF0YSkgRW1wdHlcbiAgZW5kXG5cbmxldCByZXNldCBoID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gICAgfHwgbGVuID0gYWJzIGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICBjbGVhciBoXG4gIGVsc2UgYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSAoYWJzIGguaW5pdGlhbF9zaXplKSBFbXB0eVxuICBlbmRcblxubGV0IGNvcHlfYnVja2V0bGlzdCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gRW1wdHlcbiAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICBsZXQgcmVjIGxvb3AgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICAgIHwgQ29ucyBwcmVjIC0+ICBwcmVjLm5leHQgPC0gclxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgbG9vcCByIG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgciA9IENvbnMge2tleTsgZGF0YTsgbmV4dH0gaW5cbiAgICAgIGxvb3AgciBuZXh0O1xuICAgICAgclxuXG5sZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5Lm1hcCBjb3B5X2J1Y2tldGxpc3QgaC5kYXRhIH1cblxubGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbmxldCByZXNpemUgaW5kZXhmdW4gaCA9XG4gIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBiZWdpblxuICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgbmRhdGFfdGFpbCA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICBsZXQgaW5wbGFjZSA9IG5vdCAob25nb2luZ190cmF2ZXJzYWwgaCkgaW5cbiAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICAgICgqIHNvIHRoYXQgaW5kZXhmdW4gc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gYXMgY2VsbCAtPlxuICAgICAgICAgIGxldCBjZWxsID1cbiAgICAgICAgICAgIGlmIGlucGxhY2UgdGhlbiBjZWxsXG4gICAgICAgICAgICBlbHNlIENvbnMge2tleTsgZGF0YTsgbmV4dCA9IEVtcHR5fVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IG5pZHggPSBpbmRleGZ1biBoIGtleSBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIG5kYXRhX3RhaWwuKG5pZHgpIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IG5kYXRhLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBjZWxsO1xuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBuZGF0YV90YWlsLihuaWR4KSA8LSBjZWxsO1xuICAgICAgICAgIGluc2VydF9idWNrZXQgbmV4dFxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICBkb25lO1xuICAgIGlmIGlucGxhY2UgdGhlblxuICAgICAgZm9yIGkgPSAwIHRvIG5zaXplIC0gMSBkb1xuICAgICAgICBtYXRjaCBuZGF0YV90YWlsLihpKSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBDb25zIHRhaWwgLT4gdGFpbC5uZXh0IDwtIEVtcHR5XG4gICAgICBkb25lO1xuICBlbmRcblxubGV0IGl0ZXIgZiBoID1cbiAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgKClcbiAgICB8IENvbnN7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICBmIGtleSBkYXRhOyBkb19idWNrZXQgbmV4dCBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBkb19idWNrZXQgZC4oaSlcbiAgICBkb25lO1xuICAgIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbmxldCByZWMgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBFbXB0eVxuICAgICAgZW5kXG4gIHwgKENvbnMgKHtrZXk7IGRhdGE7IG5leHR9IGFzIGMpKSBhcyBzbG90IC0+XG4gICAgICBiZWdpbiBtYXRjaCBmIGtleSBkYXRhIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyBuZXh0XG4gICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBzbG90XG4gICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIHNsb3RcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYy5kYXRhIDwtIGRhdGE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBzbG90IG5leHRcbiAgICAgIGVuZFxuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gIGxldCBkID0gaC5kYXRhIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIEVtcHR5IGguZGF0YS4oaSlcbiAgICBkb25lXG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZm9sZCBmIGggaW5pdCA9XG4gIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgICBFbXB0eSAtPlxuICAgICAgICBhY2N1XG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZG9fYnVja2V0IG5leHQgKGYga2V5IGRhdGEgYWNjdSkgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgIWFjY3VcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgc3RhdGlzdGljcyA9IHtcbiAgbnVtX2JpbmRpbmdzOiBpbnQ7XG4gIG51bV9idWNrZXRzOiBpbnQ7XG4gIG1heF9idWNrZXRfbGVuZ3RoOiBpbnQ7XG4gIGJ1Y2tldF9oaXN0b2dyYW06IGludCBhcnJheVxufVxuXG5sZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYWNjdVxuICB8IENvbnN7bmV4dH0gLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIG5leHRcblxubGV0IHN0YXRzIGggPVxuICBsZXQgbWJsID1cbiAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICBBcnJheS5pdGVyXG4gICAgKGZ1biBiIC0+XG4gICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICBoLmRhdGE7XG4gIHsgbnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHRibCA9XG4gICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICBpblxuICBhdXggMCBFbXB0eVxuXG5sZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxubGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuKCogRnVuY3RvcmlhbCBpbnRlcmZhY2UgKilcblxubW9kdWxlIHR5cGUgSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZSA6ID9yYW5kb206Ym9vbCAtPiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlU2VlZGVkKEg6IFNlZWRlZEhhc2hlZFR5cGUpOiAoU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIHR5cGUga2V5ID0gSC50XG4gICAgdHlwZSAnYSBoYXNodGJsID0gKGtleSwgJ2EpIHRcbiAgICB0eXBlICdhIHQgPSAnYSBoYXNodGJsXG4gICAgbGV0IGNyZWF0ZSA9IGNyZWF0ZVxuICAgIGxldCBjbGVhciA9IGNsZWFyXG4gICAgbGV0IHJlc2V0ID0gcmVzZXRcbiAgICBsZXQgY29weSA9IGNvcHlcblxuICAgIGxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAgICAgKEguaGFzaCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBhZGQgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG4gICAgbGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgICAgIEguZXF1YWwgayBrZXkgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGFkZF9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG4gICAgbGV0IHJlcGxhY2Vfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcblxuICAgIGxldCBpdGVyID0gaXRlclxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgPSBmaWx0ZXJfbWFwX2lucGxhY2VcbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgbGV0IHN0YXRzID0gc3RhdHNcbiAgICBsZXQgdG9fc2VxID0gdG9fc2VxXG4gICAgbGV0IHRvX3NlcV9rZXlzID0gdG9fc2VxX2tleXNcbiAgICBsZXQgdG9fc2VxX3ZhbHVlcyA9IHRvX3NlcV92YWx1ZXNcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKEg6IEhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuKCogUG9seW1vcnBoaWMgaGFzaCBmdW5jdGlvbi1iYXNlZCB0YWJsZXMgKilcbigqIENvZGUgaW5jbHVkZWQgYmVsb3cgdGhlIGZ1bmN0b3JpYWwgaW50ZXJmYWNlIHRvIGd1YXJkIGFnYWluc3QgYWNjaWRlbnRhbFxuICAgdXNlIC0gc2VlICMyMjAyICopXG5cbmV4dGVybmFsIHNlZWRlZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gaW50ID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2xkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoX3VuaXZfcGFyYW1cIiBbQEBub2FsbG9jXVxuXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxubGV0IGhhc2hfcGFyYW0gbjEgbjIgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIG4xIG4yIDAgeFxubGV0IHNlZWRlZF9oYXNoIHNlZWQgeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBzZWVkIHhcblxubGV0IGtleV9pbmRleCBoIGtleSA9XG4gICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDNcbiAgdGhlbiAoc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuICBlbHNlIChvbGRfaGFzaF9wYXJhbSAxMCAxMDAga2V5KSBtb2QgKEFycmF5Lmxlbmd0aCBoLmRhdGEpXG5cbmxldCBhZGQgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxubGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgICgpXG4gIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgZW5kXG4gICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxubGV0IHJlbW92ZSBoIGtleSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbmxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbmxldCBmaW5kIGgga2V5ID1cbiAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIGQxIGVsc2VcbiAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIGQyIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG5sZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBOb25lXG4gIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsgPSAwIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbmxldCBmaW5kX29wdCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gTm9uZVxuICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgaWYgY29tcGFyZSBrZXkgazEgPSAwIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgaWYgY29tcGFyZSBrZXkgazIgPSAwIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGszID0gMCB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbmxldCBmaW5kX2FsbCBoIGtleSA9XG4gIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBbXVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiBkYXRhIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHRydWVcbiAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICBpZiBjb21wYXJlIGsga2V5ID0gMFxuICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxubGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gIGxldCBsID0gaC5kYXRhLihpKSBpblxuICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgZW5kXG5cbmxldCBtZW0gaCBrZXkgPVxuICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBmYWxzZVxuICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICBjb21wYXJlIGsga2V5ID0gMCB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxubGV0IGFkZF9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbmxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gIFNlcS5pdGVyIChmdW4gKGssdikgLT4gcmVwbGFjZSB0YmwgayB2KSBpXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gIHRibFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbmxldCBjcmVhdGUgbCA9XG4gIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gT2JqLkVwaGVtZXJvbi5tYXhfZXBoZV9sZW5ndGgpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhcIldlYWsuY3JlYXRlXCIpO1xuICBjcmVhdGUgbFxuXG4oKiogbnVtYmVyIG9mIGFkZGl0aW9uYWwgdmFsdWVzIGluIGEgd2VhayBwb2ludGVyICopXG5sZXQgYWRkaXRpb25hbF92YWx1ZXMgPSAyXG5cbmxldCBsZW5ndGggeCA9IE9iai5zaXplKE9iai5yZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxubGV0IHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBtc2cgPVxuICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICBpbnZhbGlkX2FyZyhtc2cpXG5cbmV4dGVybmFsIHNldCcgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG5leHRlcm5hbCB1bnNldCA6ICdhIHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxubGV0IHNldCBlIG8geCA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuc2V0XCI7XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gdW5zZXQgZSBvXG4gIHwgU29tZSB4IC0+IHNldCcgZSBvIHhcblxuZXh0ZXJuYWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2Egb3B0aW9uID0gXCJjYW1sX3dlYWtfZ2V0XCJcbmxldCBnZXQgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRcIjtcbiAgZ2V0IGUgb1xuXG5leHRlcm5hbCBnZXRfY29weSA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldF9jb3B5XCJcbmxldCBnZXRfY29weSBlIG8gPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLmdldF9jb3B5XCI7XG4gIGdldF9jb3B5IGUgb1xuXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5sZXQgY2hlY2sgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5jaGVja1wiO1xuICBjaGVjayBlIG9cblxuZXh0ZXJuYWwgYmxpdCA6ICdhIHQgLT4gaW50IC0+ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX3dlYWtfYmxpdFwiXG5cbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcbmxldCBibGl0IGUxIG8xIGUyIG8yIGwgPVxuICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIldlYWsuYmxpdFwiXG4gIGVsc2UgaWYgbCA8PiAwIHRoZW4gYmxpdCBlMSBvMSBlMiBvMiBsXG5cbmxldCBmaWxsIGFyIG9mcyBsZW4geCA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYXIgLSBsZW5cbiAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIldlYWsuZmlsbFwiKVxuICBlbHNlIGJlZ2luXG4gICAgZm9yIGkgPSBvZnMgdG8gKG9mcyArIGxlbiAtIDEpIGRvXG4gICAgICBzZXQgYXIgaSB4XG4gICAgZG9uZVxuICBlbmRcblxuXG4oKiogV2VhayBoYXNoIHRhYmxlcyAqKVxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZGF0YVxuICB0eXBlIHRcbiAgdmFsIGNyZWF0ZSA6IGludCAtPiB0XG4gIHZhbCBjbGVhciA6IHQgLT4gdW5pdFxuICB2YWwgbWVyZ2UgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgYWRkIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCBmaW5kIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGZpbmRfb3B0IDogdCAtPiBkYXRhIC0+IGRhdGEgb3B0aW9uXG4gIHZhbCBmaW5kX2FsbCA6IHQgLT4gZGF0YSAtPiBkYXRhIGxpc3RcbiAgdmFsIG1lbSA6IHQgLT4gZGF0YSAtPiBib29sXG4gIHZhbCBpdGVyIDogKGRhdGEgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gIHZhbCBmb2xkIDogKGRhdGEgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgdmFsIGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIHN0YXRzIDogdCAtPiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnQgKiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoSCA6IEhhc2h0YmwuSGFzaGVkVHlwZSkgOiAoUyB3aXRoIHR5cGUgZGF0YSA9IEgudCkgPSBzdHJ1Y3RcblxuICB0eXBlICdhIHdlYWtfdCA9ICdhIHRcbiAgbGV0IHdlYWtfY3JlYXRlID0gY3JlYXRlXG4gIGxldCBlbXB0eWJ1Y2tldCA9IHdlYWtfY3JlYXRlIDBcblxuICB0eXBlIGRhdGEgPSBILnRcblxuICB0eXBlIHQgPSB7XG4gICAgbXV0YWJsZSB0YWJsZSA6IGRhdGEgd2Vha190IGFycmF5O1xuICAgIG11dGFibGUgaGFzaGVzIDogaW50IGFycmF5IGFycmF5O1xuICAgIG11dGFibGUgbGltaXQgOiBpbnQ7ICAgICAgICAgICAgICAgKCogYnVja2V0IHNpemUgbGltaXQgKilcbiAgICBtdXRhYmxlIG92ZXJzaXplIDogaW50OyAgICAgICAgICAgICgqIG51bWJlciBvZiBvdmVyc2l6ZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSByb3ZlciA6IGludDsgICAgICAgICAgICAgICAoKiBmb3IgaW50ZXJuYWwgYm9va2tlZXBpbmcgKilcbiAgfVxuXG4gIGxldCBnZXRfaW5kZXggdCBoID0gKGggbGFuZCBtYXhfaW50KSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG4gIGxldCBsaW1pdCA9IDdcbiAgbGV0IG92ZXJfbGltaXQgPSAyXG5cbiAgbGV0IGNyZWF0ZSBzeiA9XG4gICAgbGV0IHN6ID0gaWYgc3ogPCA3IHRoZW4gNyBlbHNlIHN6IGluXG4gICAgbGV0IHN6ID0gaWYgc3ogPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIFN5cy5tYXhfYXJyYXlfbGVuZ3RoIGVsc2Ugc3ogaW5cbiAgICB7XG4gICAgICB0YWJsZSA9IEFycmF5Lm1ha2Ugc3ogZW1wdHlidWNrZXQ7XG4gICAgICBoYXNoZXMgPSBBcnJheS5tYWtlIHN6IFt8IHxdO1xuICAgICAgbGltaXQgPSBsaW1pdDtcbiAgICAgIG92ZXJzaXplID0gMDtcbiAgICAgIHJvdmVyID0gMDtcbiAgICB9XG5cbiAgbGV0IGNsZWFyIHQgPVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICAgIHQudGFibGUuKGkpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgdC5oYXNoZXMuKGkpIDwtIFt8IHxdO1xuICAgIGRvbmU7XG4gICAgdC5saW1pdCA8LSBsaW1pdDtcbiAgICB0Lm92ZXJzaXplIDwtIDBcblxuXG4gIGxldCBmb2xkIGYgdCBpbml0ID1cbiAgICBsZXQgcmVjIGZvbGRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiAoZiB2IGFjY3UpXG4gICAgICB8IE5vbmUgLT4gZm9sZF9idWNrZXQgKGkrMSkgYiBhY2N1XG4gICAgaW5cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChmb2xkX2J1Y2tldCAwKSB0LnRhYmxlIGluaXRcblxuXG4gIGxldCBpdGVyIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGdldCBiIGkgd2l0aFxuICAgICAgfCBTb21lIHYgLT4gZiB2OyBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgICB8IE5vbmUgLT4gaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgIGluXG4gICAgQXJyYXkuaXRlciAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IGl0ZXJfd2VhayBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBqIGIgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuICgpIGVsc2VcbiAgICAgIG1hdGNoIGNoZWNrIGIgaSB3aXRoXG4gICAgICB8IHRydWUgLT4gZiBiIHQuaGFzaGVzLihqKSBpOyBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICAgIHwgZmFsc2UgLT4gaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyaSAoaXRlcl9idWNrZXQgMCkgdC50YWJsZVxuXG5cbiAgbGV0IHJlYyBjb3VudF9idWNrZXQgaSBiIGFjY3UgPVxuICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiBhY2N1IGVsc2VcbiAgICBjb3VudF9idWNrZXQgKGkrMSkgYiAoYWNjdSArIChpZiBjaGVjayBiIGkgdGhlbiAxIGVsc2UgMCkpXG5cblxuICBsZXQgY291bnQgdCA9XG4gICAgQXJyYXkuZm9sZF9yaWdodCAoY291bnRfYnVja2V0IDApIHQudGFibGUgMFxuXG5cbiAgbGV0IG5leHRfc3ogbiA9IG1pbiAoMyAqIG4gLyAyICsgMykgU3lzLm1heF9hcnJheV9sZW5ndGhcbiAgbGV0IHByZXZfc3ogbiA9ICgobiAtIDMpICogMiArIDIpIC8gM1xuXG4gIGxldCB0ZXN0X3Nocmlua19idWNrZXQgdCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKHQucm92ZXIpIGluXG4gICAgbGV0IGhidWNrZXQgPSB0Lmhhc2hlcy4odC5yb3ZlcikgaW5cbiAgICBsZXQgbGVuID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCBwcmV2X2xlbiA9IHByZXZfc3ogbGVuIGluXG4gICAgbGV0IGxpdmUgPSBjb3VudF9idWNrZXQgMCBidWNrZXQgMCBpblxuICAgIGlmIGxpdmUgPD0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IHJlYyBsb29wIGkgaiA9XG4gICAgICAgIGlmIGogPj0gcHJldl9sZW4gdGhlbiBiZWdpblxuICAgICAgICAgIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gbG9vcCAoaSArIDEpIGpcbiAgICAgICAgICBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBqIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGJsaXQgYnVja2V0IGogYnVja2V0IGkgMTtcbiAgICAgICAgICAgIGhidWNrZXQuKGkpIDwtIGhidWNrZXQuKGopO1xuICAgICAgICAgICAgbG9vcCAoaSArIDEpIChqIC0gMSk7XG4gICAgICAgICAgZW5kIGVsc2UgbG9vcCBpIChqIC0gMSk7XG4gICAgICAgIGVuZDtcbiAgICAgIGluXG4gICAgICBsb29wIDAgKGxlbmd0aCBidWNrZXQgLSAxKTtcbiAgICAgIGlmIHByZXZfbGVuID0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIGVtcHR5YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gW3wgfF07XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgcHJldl9sZW4gaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBwcmV2X2xlbjtcbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4odC5yb3ZlcikgPC0gQXJyYXkuc3ViIGhidWNrZXQgMCBwcmV2X2xlblxuICAgICAgZW5kO1xuICAgICAgaWYgbGVuID4gdC5saW1pdCAmJiBwcmV2X2xlbiA8PSB0LmxpbWl0IHRoZW4gdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplIC0gMTtcbiAgICBlbmQ7XG4gICAgdC5yb3ZlciA8LSAodC5yb3ZlciArIDEpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cblxuICBsZXQgcmVjIHJlc2l6ZSB0ID1cbiAgICBsZXQgb2xkbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbmV3bGVuID0gbmV4dF9zeiBvbGRsZW4gaW5cbiAgICBpZiBuZXdsZW4gPiBvbGRsZW4gdGhlbiBiZWdpblxuICAgICAgbGV0IG5ld3QgPSBjcmVhdGUgbmV3bGVuIGluXG4gICAgICBsZXQgYWRkX3dlYWsgb2Igb2ggb2kgPVxuICAgICAgICBsZXQgc2V0dGVyIG5iIG5pIF8gPSBibGl0IG9iIG9pIG5iIG5pIDEgaW5cbiAgICAgICAgbGV0IGggPSBvaC4ob2kpIGluXG4gICAgICAgIGFkZF9hdXggbmV3dCBzZXR0ZXIgTm9uZSBoIChnZXRfaW5kZXggbmV3dCBoKTtcbiAgICAgIGluXG4gICAgICBpdGVyX3dlYWsgYWRkX3dlYWsgdDtcbiAgICAgIHQudGFibGUgPC0gbmV3dC50YWJsZTtcbiAgICAgIHQuaGFzaGVzIDwtIG5ld3QuaGFzaGVzO1xuICAgICAgdC5saW1pdCA8LSBuZXd0LmxpbWl0O1xuICAgICAgdC5vdmVyc2l6ZSA8LSBuZXd0Lm92ZXJzaXplO1xuICAgICAgdC5yb3ZlciA8LSB0LnJvdmVyIG1vZCBBcnJheS5sZW5ndGggbmV3dC50YWJsZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgdC5saW1pdCA8LSBtYXhfaW50OyAgICAgICAgICAgICAoKiBtYXhpbXVtIHNpemUgYWxyZWFkeSByZWFjaGVkICopXG4gICAgICB0Lm92ZXJzaXplIDwtIDA7XG4gICAgZW5kXG5cbiAgYW5kIGFkZF9hdXggdCBzZXR0ZXIgZCBoIGluZGV4ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZXdzeiA9XG4gICAgICAgICAgbWluICgzICogc3ogLyAyICsgMykgKFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXMpXG4gICAgICAgIGluXG4gICAgICAgIGlmIG5ld3N6IDw9IHN6IHRoZW4gZmFpbHdpdGggXCJXZWFrLk1ha2U6IGhhc2ggYnVja2V0IGNhbm5vdCBncm93IG1vcmVcIjtcbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIG5ld3N6IGluXG4gICAgICAgIGxldCBuZXdoYXNoZXMgPSBBcnJheS5tYWtlIG5ld3N6IDAgaW5cbiAgICAgICAgYmxpdCBidWNrZXQgMCBuZXdidWNrZXQgMCBzejtcbiAgICAgICAgQXJyYXkuYmxpdCBoYXNoZXMgMCBuZXdoYXNoZXMgMCBzejtcbiAgICAgICAgc2V0dGVyIG5ld2J1Y2tldCBzeiBkO1xuICAgICAgICBuZXdoYXNoZXMuKHN6KSA8LSBoO1xuICAgICAgICB0LnRhYmxlLihpbmRleCkgPC0gbmV3YnVja2V0O1xuICAgICAgICB0Lmhhc2hlcy4oaW5kZXgpIDwtIG5ld2hhc2hlcztcbiAgICAgICAgaWYgc3ogPD0gdC5saW1pdCAmJiBuZXdzeiA+IHQubGltaXQgdGhlbiBiZWdpblxuICAgICAgICAgIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSArIDE7XG4gICAgICAgICAgZm9yIF9pID0gMCB0byBvdmVyX2xpbWl0IGRvIHRlc3Rfc2hyaW5rX2J1Y2tldCB0IGRvbmU7XG4gICAgICAgIGVuZDtcbiAgICAgICAgaWYgdC5vdmVyc2l6ZSA+IEFycmF5Lmxlbmd0aCB0LnRhYmxlIC8gb3Zlcl9saW1pdCB0aGVuIHJlc2l6ZSB0O1xuICAgICAgZW5kIGVsc2UgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBiZWdpblxuICAgICAgICBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIHNldHRlciBidWNrZXQgaSBkO1xuICAgICAgICBoYXNoZXMuKGkpIDwtIGg7XG4gICAgICBlbmQ7XG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBhZGQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIChnZXRfaW5kZXggdCBoKVxuXG5cbiAgbGV0IGZpbmRfb3IgdCBkIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kIGggaW5kZXhcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IG1lcmdlIHQgZCA9XG4gICAgZmluZF9vciB0IGQgKGZ1biBoIGluZGV4IC0+IGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCBpbmRleDsgZClcblxuXG4gIGxldCBmaW5kIHQgZCA9IGZpbmRfb3IgdCBkIChmdW4gX2ggX2luZGV4IC0+IHJhaXNlIE5vdF9mb3VuZClcblxuICBsZXQgZmluZF9vcHQgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gTm9uZVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBmaW5kX3NoYWRvdyB0IGQgaWZmb3VuZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZCAtPiBpZmZvdW5kIGJ1Y2tldCBpXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgcmVtb3ZlIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIHcgaSAtPiBzZXQgdyBpIE5vbmUpICgpXG5cblxuICBsZXQgbWVtIHQgZCA9IGZpbmRfc2hhZG93IHQgZCAoZnVuIF93IF9pIC0+IHRydWUpIGZhbHNlXG5cblxuICBsZXQgZmluZF9hbGwgdCBkID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSBhY2N1ID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBhY2N1XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IGxvb3AgKGkgKyAxKSAodiA6OiBhY2N1KVxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpIGFjY3VcbiAgICBpblxuICAgIGxvb3AgMCBbXVxuXG5cbiAgbGV0IHN0YXRzIHQgPVxuICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBsZW5zID0gQXJyYXkubWFwIGxlbmd0aCB0LnRhYmxlIGluXG4gICAgQXJyYXkuc29ydCBjb21wYXJlIGxlbnM7XG4gICAgbGV0IHRvdGxlbiA9IEFycmF5LmZvbGRfbGVmdCAoICsgKSAwIGxlbnMgaW5cbiAgICAobGVuLCBjb3VudCB0LCB0b3RsZW4sIGxlbnMuKDApLCBsZW5zLihsZW4vMiksIGxlbnMuKGxlbi0xKSlcblxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQSBwcmV0dHktcHJpbnRpbmcgZmFjaWxpdHkgYW5kIGRlZmluaXRpb24gb2YgZm9ybWF0dGVycyBmb3IgJ3BhcmFsbGVsJ1xuICAgKGkuZS4gdW5yZWxhdGVkIG9yIGluZGVwZW5kZW50KSBwcmV0dHktcHJpbnRpbmcgb24gbXVsdGlwbGUgb3V0IGNoYW5uZWxzLiAqKVxuXG4oKlxuICAgVGhlIHByZXR0eS1wcmludGluZyBlbmdpbmUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuKilcblxubGV0IGlkIHggPSB4XG5cbigqIEEgZGV2b3RlZCB0eXBlIGZvciBzaXplcyB0byBhdm9pZCBjb25mdXNpb25cbiAgIGJldHdlZW4gc2l6ZXMgYW5kIG1lcmUgaW50ZWdlcnMuICopXG5tb2R1bGUgU2l6ZSA6IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9faW50IDogdCAtPiBpbnRcbiAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgdW5rbm93biA6IHRcbiAgdmFsIGlzX2tub3duIDogdCAtPiBib29sXG5lbmQgID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCB0b19pbnQgPSBpZFxuICBsZXQgb2ZfaW50ID0gaWRcbiAgbGV0IHplcm8gPSAwXG4gIGxldCB1bmtub3duID0gLTFcbiAgbGV0IGlzX2tub3duIG4gPSBuID49IDBcbmVuZFxuXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgeyAgICAgICAgICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgICAgIGZpdHM6IHN0cmluZyAqIGludCAqIHN0cmluZzsgICAoKiBsaW5lIGlzIG5vdCBzcGxpdCAqKVxuICAgICAgYnJlYWtzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICgqIGxpbmUgaXMgc3BsaXQgKilcbiAgICB9XG4gIHwgUHBfdGJyZWFrIG9mIGludCAqIGludCAgICAgKCogZ28gdG8gbmV4dCB0YWJ1bGF0aW9uICopXG4gIHwgUHBfc3RhYiAgICAgICAgICAgICAgICAgICAgKCogc2V0IGEgdGFidWxhdGlvbiAqKVxuICB8IFBwX2JlZ2luIG9mIGludCAqIGJveF90eXBlICgqIGJlZ2lubmluZyBvZiBhIGJveCAqKVxuICB8IFBwX2VuZCAgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIGJveCAqKVxuICB8IFBwX3RiZWdpbiBvZiB0Ym94ICAgICAgICAgICgqIGJlZ2lubmluZyBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfdGVuZCAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF9uZXdsaW5lICAgICAgICAgICAgICAgICAoKiB0byBmb3JjZSBhIG5ld2xpbmUgaW5zaWRlIGEgYm94ICopXG4gIHwgUHBfaWZfbmV3bGluZSAgICAgICAgICAgICAgKCogdG8gZG8gc29tZXRoaW5nIG9ubHkgaWYgdGhpcyB2ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSBoYXMgYmVlbiBicm9rZW4gKilcbiAgfCBQcF9vcGVuX3RhZyBvZiBzdGFnICAgICAgICAgKCogb3BlbmluZyBhIHRhZyBuYW1lICopXG4gIHwgUHBfY2xvc2VfdGFnICAgICAgICAgICAgICAgKCogY2xvc2luZyB0aGUgbW9zdCByZWNlbnRseSBvcGVuIHRhZyAqKVxuXG5hbmQgc3RhZyA9IC4uXG5cbmFuZCB0Ym94ID0gUHBfdGJveCBvZiBpbnQgbGlzdCByZWYgICgqIFRhYnVsYXRpb24gYm94ICopXG5cbnR5cGUgdGFnID0gc3RyaW5nXG50eXBlIHN0YWcgKz0gU3RyaW5nX3RhZyBvZiB0YWdcblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6XG4gICBwcmV0dHktcHJpbnRpbmcgbWF0ZXJpYWwgaXMgbm90IHdyaXR0ZW4gaW4gdGhlIG91dHB1dCBhcyBzb29uIGFzIGVtaXR0ZWQ7XG4gICBpbnN0ZWFkLCB0aGUgbWF0ZXJpYWwgaXMgc2ltcGx5IHJlY29yZGVkIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSxcbiAgIHVudGlsIHRoZSBlbmNsb3NpbmcgYm94IGhhcyBhIGtub3duIGNvbXB1dGVkIHNpemUgYW5kIHByb3BlciBzcGxpdHRpbmdcbiAgIGRlY2lzaW9ucyBjYW4gYmUgbWFkZS5cblxuICAgVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGNvbnRhaW5zIGZvcm1hdHRpbmcgZWxlbWVudHMgdG8gYmUgcHJpbnRlZC5cbiAgIEVhY2ggZm9ybWF0dGluZyBlbGVtZW50IGlzIGEgdHVwbGUgKHNpemUsIHRva2VuLCBsZW5ndGgpLCB3aGVyZVxuICAgLSBsZW5ndGggaXMgdGhlIGRlY2xhcmVkIGxlbmd0aCBvZiB0aGUgdG9rZW4sXG4gICAtIHNpemUgaXMgZWZmZWN0aXZlIHNpemUgb2YgdGhlIHRva2VuIHdoZW4gaXQgaXMgcHJpbnRlZFxuICAgICAoc2l6ZSBpcyBzZXQgd2hlbiB0aGUgc2l6ZSBvZiB0aGUgYm94IGlzIGtub3duLCBzbyB0aGF0IHNpemUgb2YgYnJlYWtcbiAgICAgIGhpbnRzIGFyZSBkZWZpbml0aXZlKS4gKilcbnR5cGUgcHBfcXVldWVfZWxlbSA9IHtcbiAgbXV0YWJsZSBzaXplIDogU2l6ZS50O1xuICB0b2tlbiA6IHBwX3Rva2VuO1xuICBsZW5ndGggOiBpbnQ7XG59XG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGRlZmluaXRpb24uICopXG50eXBlIHBwX3F1ZXVlID0gcHBfcXVldWVfZWxlbSBRdWV1ZS50XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrOiBzY2FubmluZyBlbGVtZW50IGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fZWxlbSA9IHtcbiAgbGVmdF90b3RhbCA6IGludDsgKCogVmFsdWUgb2YgcHBfbGVmdF90b3RhbCB3aGVuIHRoZSBlbGVtZW50IHdhcyBlbnF1ZXVlZC4gKilcbiAgcXVldWVfZWxlbSA6IHBwX3F1ZXVlX2VsZW1cbn1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6XG4gICB0aGUgZm9ybWF0dGluZyBzdGFjayBjb250YWlucyB0aGUgZGVzY3JpcHRpb24gb2YgYWxsIHRoZSBjdXJyZW50bHkgYWN0aXZlXG4gICBib3hlczsgdGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2sgaXMgdXNlZCB0byBzcGxpdCB0aGUgbGluZXNcbiAgIHdoaWxlIHByaW50aW5nIHRva2Vucy4gKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIGZvcm1hdHRpbmcgc3RhY2s6IGZvcm1hdHRpbmcgc3RhY2sgZWxlbWVudCBkZWZpbml0aW9uLlxuICAgRWFjaCBzdGFjayBlbGVtZW50IGRlc2NyaWJlcyBhIHByZXR0eS1wcmludGluZyBib3guICopXG50eXBlIHBwX2Zvcm1hdF9lbGVtID0geyBib3hfdHlwZSA6IGJveF90eXBlOyB3aWR0aCA6IGludCB9XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuICBwcF9zY2FuX3N0YWNrIDogcHBfc2Nhbl9lbGVtIFN0YWNrLnQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrLiAqKVxuICBwcF9mb3JtYXRfc3RhY2sgOiBwcF9mb3JtYXRfZWxlbSBTdGFjay50O1xuICBwcF90Ym94X3N0YWNrIDogdGJveCBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgc2VtYW50aWNzIHRhZyBzdGFjay4gKilcbiAgcHBfdGFnX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICBwcF9tYXJrX3N0YWNrIDogc3RhZyBTdGFjay50O1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX21hcmtfY2xvc2VfdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfcHJpbnRfb3Blbl90YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogc3RhZyAtPiB1bml0O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG4gIHBwX3F1ZXVlIDogcHBfcXVldWU7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBzcGVjaWZpYyB0YWcgaGFuZGxpbmcgZnVuY3Rpb25zLiAqKVxudHlwZSBmb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl9zdGFnIDogc3RhZyAtPiBzdHJpbmc7XG4gIG1hcmtfY2xvc2Vfc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHVuaXQ7XG59XG5cblxuKCogVGhlIGZvcm1hdHRlciBmdW5jdGlvbnMgdG8gb3V0cHV0IG1hdGVyaWFsLiAqKVxudHlwZSBmb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9IHtcbiAgb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gIG91dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgb3V0X25ld2xpbmUgOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xufVxuXG5cbigqXG5cbiAgQXV4aWxpYXJpZXMgYW5kIGJhc2ljIGZ1bmN0aW9ucy5cblxuKilcblxuKCogRW50ZXIgYSB0b2tlbiBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUuICopXG5sZXQgcHBfZW5xdWV1ZSBzdGF0ZSB0b2tlbiA9XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgdG9rZW4ubGVuZ3RoO1xuICBRdWV1ZS5hZGQgdG9rZW4gc3RhdGUucHBfcXVldWVcblxuXG5sZXQgcHBfY2xlYXJfcXVldWUgc3RhdGUgPVxuICBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwtIDE7IHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIDE7XG4gIFF1ZXVlLmNsZWFyIHN0YXRlLnBwX3F1ZXVlXG5cblxuKCogUHBfaW5maW5pdHk6IGxhcmdlIHZhbHVlIGZvciBkZWZhdWx0IHRva2VucyBzaXplLlxuXG4gICBQcF9pbmZpbml0eSBpcyBkb2N1bWVudGVkIGFzIGJlaW5nIGdyZWF0ZXIgdGhhbiAxZTEwOyB0byBhdm9pZFxuICAgY29uZnVzaW9uIGFib3V0IHRoZSB3b3JkICdncmVhdGVyJywgd2UgY2hvb3NlIHBwX2luZmluaXR5IGdyZWF0ZXJcbiAgIHRoYW4gMWUxMCArIDE7IGZvciBjb3JyZWN0IGhhbmRsaW5nIG9mIHRlc3RzIGluIHRoZSBhbGdvcml0aG0sXG4gICBwcF9pbmZpbml0eSBtdXN0IGJlIGV2ZW4gb25lIG1vcmUgdGhhbiAxZTEwICsgMTsgbGV0J3Mgc3RhbmQgb24gdGhlXG4gICBzYWZlIHNpZGUgYnkgY2hvb3NpbmcgMS5lMTArMTAuXG5cbiAgIFBwX2luZmluaXR5IGNvdWxkIHByb2JhYmx5IGJlIDEwNzM3NDE4MjMgdGhhdCBpcyAyXjMwIC0gMSwgdGhhdCBpc1xuICAgdGhlIG1pbmltYWwgdXBwZXIgYm91bmQgZm9yIGludGVnZXJzOyBub3cgdGhhdCBtYXhfaW50IGlzIGRlZmluZWQsXG4gICB0aGlzIGxpbWl0IGNvdWxkIGFsc28gYmUgZGVmaW5lZCBhcyBtYXhfaW50IC0gMS5cblxuICAgSG93ZXZlciwgYmVmb3JlIHNldHRpbmcgcHBfaW5maW5pdHkgdG8gc29tZXRoaW5nIGFyb3VuZCBtYXhfaW50LCB3ZVxuICAgbXVzdCBjYXJlZnVsbHkgZG91YmxlLWNoZWNrIGFsbCB0aGUgaW50ZWdlciBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgIHRoYXQgaW52b2x2ZSBwcF9pbmZpbml0eSwgc2luY2UgYW55IG92ZXJmbG93IHdvdWxkIHdyZWNrIGhhdm9jIHRoZVxuICAgcHJldHR5LXByaW50aW5nIGFsZ29yaXRobSdzIGludmFyaWFudHMuIEdpdmVuIHRoYXQgdGhpcyBhcml0aG1ldGljXG4gICBjb3JyZWN0bmVzcyBjaGVjayBpcyBkaWZmaWN1bHQgYW5kIGVycm9yIHByb25lIGFuZCBnaXZlbiB0aGF0IDFlMTBcbiAgICsgMSBpcyBpbiBwcmFjdGljZSBsYXJnZSBlbm91Z2gsIHRoZXJlIGlzIG5vIG5lZWQgdG8gYXR0ZW1wdCB0byBzZXRcbiAgIHBwX2luZmluaXR5IHRvIHRoZSB0aGVvcmV0aWNhbGx5IG1heGltdW0gbGltaXQuIEl0IGlzIG5vdCB3b3J0aCB0aGVcbiAgIGJ1cmRlbiAhICopXG5sZXQgcHBfaW5maW5pdHkgPSAxMDAwMDAwMDEwXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgZm9yIHRoZSBmb3JtYXR0ZXIuICopXG5sZXQgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBzID0gc3RhdGUucHBfb3V0X3N0cmluZyBzIDAgKFN0cmluZy5sZW5ndGggcylcbmFuZCBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSA9IHN0YXRlLnBwX291dF9uZXdsaW5lICgpXG5hbmQgcHBfb3V0cHV0X3NwYWNlcyBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X3NwYWNlcyBuXG5hbmQgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBuID0gc3RhdGUucHBfb3V0X2luZGVudCBuXG5cbigqIEZvcm1hdCBhIHRleHR1YWwgdG9rZW4gKilcbmxldCBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHRleHQgPVxuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHRleHQ7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIGZhbHNlXG5cbigqIEZvcm1hdCBhIHN0cmluZyBieSBpdHMgbGVuZ3RoLCBpZiBub3QgZW1wdHkgKilcbmxldCBmb3JtYXRfc3RyaW5nIHN0YXRlIHMgPVxuICBpZiBzIDw+IFwiXCIgdGhlbiBmb3JtYXRfcHBfdGV4dCBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrLCBpbmRlbnRpbmcgYSBuZXcgbGluZS4gKilcbmxldCBicmVha19uZXdfbGluZSBzdGF0ZSAoYmVmb3JlLCBvZmZzZXQsIGFmdGVyKSB3aWR0aCA9XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYmVmb3JlO1xuICBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfaXNfbmV3X2xpbmUgPC0gdHJ1ZTtcbiAgbGV0IGluZGVudCA9IHN0YXRlLnBwX21hcmdpbiAtIHdpZHRoICsgb2Zmc2V0IGluXG4gICgqIERvbid0IGluZGVudCBtb3JlIHRoYW4gcHBfbWF4X2luZGVudC4gKilcbiAgbGV0IHJlYWxfaW5kZW50ID0gbWluIHN0YXRlLnBwX21heF9pbmRlbnQgaW5kZW50IGluXG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIHJlYWxfaW5kZW50O1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50O1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gZm9yY2UgYSBsaW5lIGJyZWFrIGluc2lkZSBhIGJveDogbm8gb2Zmc2V0IGlzIGFkZGVkLiAqKVxubGV0IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGggPSBicmVha19uZXdfbGluZSBzdGF0ZSAoXCJcIiwgMCwgXCJcIikgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIChiZWZvcmUsIHdpZHRoLCBhZnRlcikgPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGg7XG4gIGZvcm1hdF9zdHJpbmcgc3RhdGUgYWZ0ZXJcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+IHBwX291dHB1dF9uZXdsaW5lIHN0YXRlXG4gIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgaWYgd2lkdGggPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW5cbiAgICAgIG1hdGNoIGJveF90eXBlIHdpdGhcbiAgICAgIHwgUHBfZml0cyB8IFBwX2hib3ggLT4gKClcbiAgICAgIHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBza2lwIGEgdG9rZW4sIGlmIHRoZSBwcmV2aW91cyBsaW5lIGhhcyBiZWVuIGJyb2tlbi4gKilcbmxldCBwcF9za2lwX3Rva2VuIHN0YXRlID1cbiAgbWF0Y2ggUXVldWUudGFrZV9vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogcHJpbnRfaWZfbmV3bGluZSBtdXN0IGhhdmUgYmVlbiB0aGUgbGFzdCBwcmludGluZyBjb21tYW5kICopXG4gIHwgU29tZSB7IHNpemU7IGxlbmd0aDsgXyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuZ3RoO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIFNpemUudG9faW50IHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBmb3JtYXRfcHBfdGV4dCBzdGF0ZSBzaXplIHNcblxuICB8IFBwX2JlZ2luIChvZmYsIHR5KSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgaWYgaW5zZXJ0aW9uX3BvaW50ID4gc3RhdGUucHBfbWF4X2luZGVudCB0aGVuXG4gICAgICAoKiBjYW4gbm90IG9wZW4gYSBib3ggcmlnaHQgdGhlcmUuICopXG4gICAgICBiZWdpbiBwcF9mb3JjZV9icmVha19saW5lIHN0YXRlIGVuZDtcbiAgICBsZXQgd2lkdGggPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJveF90eXBlID1cbiAgICAgIG1hdGNoIHR5IHdpdGhcbiAgICAgIHwgUHBfdmJveCAtPiBQcF92Ym94XG4gICAgICB8IFBwX2hib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHMgLT5cbiAgICAgICAgaWYgc2l6ZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnQgdGhlbiB0eSBlbHNlIFBwX2ZpdHMgaW5cbiAgICBTdGFjay5wdXNoIHsgYm94X3R5cGU7IHdpZHRoIH0gc3RhdGUucHBfZm9ybWF0X3N0YWNrXG5cbiAgfCBQcF9lbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB8PiBpZ25vcmVcblxuICB8IFBwX3RiZWdpbiAoUHBfdGJveCBfIGFzIHRib3gpIC0+XG4gICAgU3RhY2sucHVzaCB0Ym94IHN0YXRlLnBwX3Rib3hfc3RhY2tcblxuICB8IFBwX3RlbmQgLT5cbiAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCByZWMgYWRkX3RhYiBuID0gZnVuY3Rpb25cbiAgICAgICAgfCBbXSAtPiBbbl1cbiAgICAgICAgfCB4IDo6IGwgYXMgbHMgLT4gaWYgbiA8IHggdGhlbiBuIDo6IGxzIGVsc2UgeCA6OiBhZGRfdGFiIG4gbCBpblxuICAgICAgdGFicyA6PSBhZGRfdGFiIChzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0KSAhdGFic1xuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX3Rib3hfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIHwgU29tZSAoUHBfdGJveCB0YWJzKSAtPlxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCBbXSAtPiBpbnNlcnRpb25fcG9pbnRcbiAgICAgICAgfCBmaXJzdCA6OiBfIC0+XG4gICAgICAgICAgbGV0IHJlYyBmaW5kID0gZnVuY3Rpb25cbiAgICAgICAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgICAgICAgIGlmIGhlYWQgPj0gaW5zZXJ0aW9uX3BvaW50IHRoZW4gaGVhZCBlbHNlIGZpbmQgdGFpbFxuICAgICAgICAgICAgfCBbXSAtPiBmaXJzdCBpblxuICAgICAgICAgIGZpbmQgIXRhYnMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSB0YWIgLSBpbnNlcnRpb25fcG9pbnQgaW5cbiAgICAgIGlmIG9mZnNldCA+PSAwXG4gICAgICB0aGVuIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoXCJcIiwgb2Zmc2V0ICsgbiwgXCJcIilcbiAgICAgIGVsc2UgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIHRhYiArIG9mZiwgXCJcIikgc3RhdGUucHBfbWFyZ2luXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyB3aWR0aDsgX30gLT4gYnJlYWtfbGluZSBzdGF0ZSB3aWR0aFxuICAgIGVuZFxuXG4gIHwgUHBfaWZfbmV3bGluZSAtPlxuICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ICE9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICB0aGVuIHBwX3NraXBfdG9rZW4gc3RhdGVcblxuICB8IFBwX2JyZWFrIHsgZml0czsgYnJlYWtzIH0gLT5cbiAgICBsZXQgYmVmb3JlLCBvZmYsIF8gPSBicmVha3MgaW5cbiAgICBiZWdpbiBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIHwgU29tZSB7IGJveF90eXBlOyB3aWR0aCB9IC0+XG4gICAgICBiZWdpbiBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgIHRoZW4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICAgIGVsc2UgYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIHwgUHBfYm94IC0+XG4gICAgICAgICgqIEhhdmUgdGhlIGxpbmUganVzdCBiZWVuIGJyb2tlbiBoZXJlID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfaXNfbmV3X2xpbmUgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0cyBlbHNlXG4gICAgICAgIGlmIHNpemUgKyBTdHJpbmcubGVuZ3RoIGJlZm9yZSA+IHN0YXRlLnBwX3NwYWNlX2xlZnRcbiAgICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aCBlbHNlXG4gICAgICAgICgqIGJyZWFrIHRoZSBsaW5lIGhlcmUgbGVhZHMgdG8gbmV3IGluZGVudGF0aW9uID8gKilcbiAgICAgICAgaWYgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPiBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZlxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2h2Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9maXRzIC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX3Zib3ggLT4gYnJlYWtfbmV3X2xpbmUgc3RhdGUgYnJlYWtzIHdpZHRoXG4gICAgICB8IFBwX2hib3ggLT4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHNcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9tYXJrX3N0YWNrIHdpdGhcbiAgICAgfCBOb25lIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19jbG9zZV90YWcgdGFnX25hbWUgaW5cbiAgICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlclxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFByaW50aW5nIGlzIGRlbGF5ZWQgd2hlbiB0aGUgdGV4dCB3YWl0aW5nIGluIHRoZSBxdWV1ZSByZXF1aXJlc1xuICAgbW9yZSByb29tIHRvIGZvcm1hdCB0aGFuIGV4aXN0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IHJlYyBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICBtYXRjaCBRdWV1ZS5wZWVrX29wdCBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBObyB0b2tlbnMgdG8gcHJpbnQgKilcbiAgfCBTb21lIHsgc2l6ZTsgdG9rZW47IGxlbmd0aCB9IC0+XG4gICAgbGV0IHBlbmRpbmdfY291bnQgPSBzdGF0ZS5wcF9yaWdodF90b3RhbCAtIHN0YXRlLnBwX2xlZnRfdG90YWwgaW5cbiAgICBpZiBTaXplLmlzX2tub3duIHNpemUgfHwgcGVuZGluZ19jb3VudCA+PSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gYmVnaW5cbiAgICAgIFF1ZXVlLnRha2Ugc3RhdGUucHBfcXVldWUgfD4gaWdub3JlOyAoKiBOb3QgZW1wdHk6IHdlIHBlZWsgaW50byBpdCAqKVxuICAgICAgbGV0IHNpemUgPSBpZiBTaXplLmlzX2tub3duIHNpemUgdGhlbiBTaXplLnRvX2ludCBzaXplIGVsc2UgcHBfaW5maW5pdHkgaW5cbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSBzaXplIHRva2VuO1xuICAgICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBsZW5ndGggKyBzdGF0ZS5wcF9sZWZ0X3RvdGFsO1xuICAgICAgKGFkdmFuY2VfbGVmdCBbQHRhaWxjYWxsXSkgc3RhdGVcbiAgICBlbmRcblxuXG4oKiBUbyBlbnF1ZXVlIGEgdG9rZW4gOiB0cnkgdG8gYWR2YW5jZS4gKilcbmxldCBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgdG9rID0gcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7IGFkdmFuY2VfbGVmdCBzdGF0ZVxuXG5cbigqIFRvIGVucXVldWUgc3RyaW5ncy4gKilcbmxldCBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHMgPVxuICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgeyBzaXplOyB0b2tlbiA9IFBwX3RleHQgczsgbGVuZ3RoID0gU2l6ZS50b19pbnQgc2l6ZSB9XG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSAoU2l6ZS5vZl9pbnQgKFN0cmluZy5sZW5ndGggcykpIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGFjayA9XG4gIFN0YWNrLmNsZWFyIHN0YWNrO1xuICBsZXQgcXVldWVfZWxlbSA9IHsgc2l6ZSA9IFNpemUudW5rbm93bjsgdG9rZW4gPSBQcF90ZXh0IFwiXCI7IGxlbmd0aCA9IDAgfSBpblxuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IC0xOyBxdWV1ZV9lbGVtIH0gc3RhY2tcblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHNjYW5fc3RhY2sgaXMgbmV2ZXIgZW1wdHkuICopXG4gIHwgU29tZSB7IGxlZnRfdG90YWw7IHF1ZXVlX2VsZW0gfSAtPlxuICAgIGxldCBzaXplID0gU2l6ZS50b19pbnQgcXVldWVfZWxlbS5zaXplIGluXG4gICAgKCogdGVzdCBpZiBzY2FuIHN0YWNrIGNvbnRhaW5zIGFueSBkYXRhIHRoYXQgaXMgbm90IG9ic29sZXRlLiAqKVxuICAgIGlmIGxlZnRfdG90YWwgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW5cbiAgICAgIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggcXVldWVfZWxlbS50b2tlbiB3aXRoXG4gICAgICB8IFBwX2JyZWFrIF8gfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW4gYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLnNpemUgPC0gU2l6ZS5vZl9pbnQgKHN0YXRlLnBwX3JpZ2h0X3RvdGFsICsgc2l6ZSk7XG4gICAgICAgICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9zY2FuX3N0YWNrIHw+IGlnbm9yZVxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfYmVnaW4gKF8sIF8pIC0+XG4gICAgICAgIGlmIG5vdCB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX3RleHQgXyB8IFBwX3N0YWIgfCBQcF90YmVnaW4gXyB8IFBwX3RlbmQgfCBQcF9lbmRcbiAgICAgIHwgUHBfbmV3bGluZSB8IFBwX2lmX25ld2xpbmUgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG5cblxuKCogUHVzaCBhIHRva2VuIG9uIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLlxuICAgSWYgYiBpcyB0cnVlIHNldF9zaXplIGlzIGNhbGxlZC4gKilcbmxldCBzY2FuX3B1c2ggc3RhdGUgYiB0b2tlbiA9XG4gIHBwX2VucXVldWUgc3RhdGUgdG9rZW47XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBsZXQgZWxlbSA9IHsgbGVmdF90b3RhbCA9IHN0YXRlLnBwX3JpZ2h0X3RvdGFsOyBxdWV1ZV9lbGVtID0gdG9rZW4gfSBpblxuICBTdGFjay5wdXNoIGVsZW0gc3RhdGUucHBfc2Nhbl9zdGFja1xuXG5cbigqIFRvIG9wZW4gYSBuZXcgYm94IDpcbiAgIHRoZSB1c2VyIG1heSBzZXQgdGhlIGRlcHRoIGJvdW5kIHBwX21heF9ib3hlc1xuICAgYW55IHRleHQgbmVzdGVkIGRlZXBlciBpcyBwcmludGVkIGFzIHRoZSBlbGxpcHNpcyBzdHJpbmcuICopXG5sZXQgcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBicl90eSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfYmVnaW4gKGluZGVudCwgYnJfdHkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDAgfTtcbiAgICAgIHNldF9zaXplIHN0YXRlIHRydWU7IHNldF9zaXplIHN0YXRlIGZhbHNlXG4gICAgZW5kO1xuICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDE7XG4gIGVuZFxuXG5cbigqIE9wZW4gYSB0YWcsIHB1c2hpbmcgaXQgb24gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9vcGVuX3N0YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBTdGFjay5wdXNoIHRhZ19uYW1lIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyB0YWdfbmFtZVxuICBlbmQ7XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgbGV0IHRva2VuID0gUHBfb3Blbl90YWcgdGFnX25hbWUgaW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW47IGxlbmd0aCA9IDAgfVxuXG5cbigqIENsb3NlIGEgdGFnLCBwb3BwaW5nIGl0IGZyb20gdGhlIHRhZyBzdGFjay4gKilcbmxldCBwcF9jbG9zZV9zdGFnIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9jbG9zZV90YWc7IGxlbmd0aCA9IDAgfTtcbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gICAgbWF0Y2ggU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90YWdfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICB8IFNvbWUgdGFnX25hbWUgLT5cbiAgICAgIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyB0YWdfbmFtZVxuXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgcyA9IHBwX29wZW5fc3RhZyBzdGF0ZSAoU3RyaW5nX3RhZyBzKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9IHBwX2Nsb3NlX3N0YWcgc3RhdGUgKClcblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgbWFya19vcGVuX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnO1xuICBtYXJrX2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl9zdGFnID0gc3RhdGUucHBfcHJpbnRfb3Blbl90YWc7XG4gIHByaW50X2Nsb3NlX3N0YWcgPSBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWc7XG59XG5cblxubGV0IHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fc3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV9zdGFnID0gbWN0O1xuICAgICBwcmludF9vcGVuX3N0YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3N0YWcgPSBwY3Q7XG4gIH0gPVxuICBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIDwtIG1vdDtcbiAgc3RhdGUucHBfbWFya19jbG9zZV90YWcgPC0gbWN0O1xuICBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZyA8LSBwb3Q7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBwY3RcblxuXG4oKiBJbml0aWFsaXplIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX3Jpbml0IHN0YXRlID1cbiAgcHBfY2xlYXJfcXVldWUgc3RhdGU7XG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzdGF0ZS5wcF9zY2FuX3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF9mb3JtYXRfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3Rib3hfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX3RhZ19zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfbWFya19zdGFjaztcbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gMDtcbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSAwO1xuICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX21hcmdpbjtcbiAgcHBfb3Blbl9zeXNfYm94IHN0YXRlXG5cbmxldCBjbGVhcl90YWdfc3RhY2sgc3RhdGUgPVxuICBTdGFjay5pdGVyIChmdW4gXyAtPiBwcF9jbG9zZV90YWcgc3RhdGUgKCkpIHN0YXRlLnBwX3RhZ19zdGFja1xuXG5cbigqIEZsdXNoaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIGIgPVxuICBjbGVhcl90YWdfc3RhY2sgc3RhdGU7XG4gIHdoaWxlIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIGRvXG4gICAgcHBfY2xvc2VfYm94IHN0YXRlICgpXG4gIGRvbmU7XG4gIHN0YXRlLnBwX3JpZ2h0X3RvdGFsIDwtIHBwX2luZmluaXR5O1xuICBhZHZhbmNlX2xlZnQgc3RhdGU7XG4gIGlmIGIgdGhlbiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZTtcbiAgcHBfcmluaXQgc3RhdGVcblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGZvcm1hdCB2YWx1ZXMgYW5kIHVzZSBib3hlcy5cblxuKilcblxuKCogVG8gZm9ybWF0IGEgc3RyaW5nLiAqKVxubGV0IHBwX3ByaW50X2FzX3NpemUgc3RhdGUgc2l6ZSBzID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlc1xuICB0aGVuIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIHNpemUgc1xuXG5cbmxldCBwcF9wcmludF9hcyBzdGF0ZSBpc2l6ZSBzID1cbiAgcHBfcHJpbnRfYXNfc2l6ZSBzdGF0ZSAoU2l6ZS5vZl9pbnQgaXNpemUpIHNcblxuXG5sZXQgcHBfcHJpbnRfc3RyaW5nIHN0YXRlIHMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAoU3RyaW5nLmxlbmd0aCBzKSBzXG5cblxuKCogVG8gZm9ybWF0IGFuIGludGVnZXIuICopXG5sZXQgcHBfcHJpbnRfaW50IHN0YXRlIGkgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKEludC50b19zdHJpbmcgaSlcblxuKCogVG8gZm9ybWF0IGEgZmxvYXQuICopXG5sZXQgcHBfcHJpbnRfZmxvYXQgc3RhdGUgZiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Zsb2F0IGYpXG5cbigqIFRvIGZvcm1hdCBhIGJvb2xlYW4uICopXG5sZXQgcHBfcHJpbnRfYm9vbCBzdGF0ZSBiID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfYm9vbCBiKVxuXG4oKiBUbyBmb3JtYXQgYSBjaGFyLiAqKVxubGV0IHBwX3ByaW50X2NoYXIgc3RhdGUgYyA9XG4gIHBwX3ByaW50X2FzIHN0YXRlIDEgKFN0cmluZy5tYWtlIDEgYylcblxuXG4oKiBPcGVuaW5nIGJveGVzLiAqKVxubGV0IHBwX29wZW5faGJveCBzdGF0ZSAoKSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hib3hcbmFuZCBwcF9vcGVuX3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF92Ym94XG5cbmFuZCBwcF9vcGVuX2h2Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfaHZib3hcbmFuZCBwcF9vcGVuX2hvdmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2hvdmJveFxuYW5kIHBwX29wZW5fYm94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfYm94XG5cblxuKCogUHJpbnRpbmcgcXVldWVkIHRleHQuXG5cbiAgIFtwcF9wcmludF9mbHVzaF0gcHJpbnRzIGFsbCBwZW5kaW5nIGl0ZW1zIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhbmRcbiAgIHRoZW4gZmx1c2hlcyB0aGUgbG93IGxldmVsIG91dHB1dCBkZXZpY2Ugb2YgdGhlIGZvcm1hdHRlciB0byBhY3R1YWxseVxuICAgZGlzcGxheSBwcmludGluZyBtYXRlcmlhbC5cblxuICAgW3BwX3ByaW50X25ld2xpbmVdIGJlaGF2ZXMgYXMgW3BwX3ByaW50X2ZsdXNoXSBhZnRlciBwcmludGluZyBhbiBhZGRpdGlvbmFsXG4gICBuZXcgbGluZS4gKilcbmxldCBwcF9wcmludF9uZXdsaW5lIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgdHJ1ZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5hbmQgcHBfcHJpbnRfZmx1c2ggc3RhdGUgKCkgPVxuICBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBmYWxzZTsgc3RhdGUucHBfb3V0X2ZsdXNoICgpXG5cblxuKCogVG8gZ2V0IGEgbmV3bGluZSB3aGVuIG9uZSBkb2VzIG5vdCB3YW50IHRvIGNsb3NlIHRoZSBjdXJyZW50IGJveC4gKilcbmxldCBwcF9mb3JjZV9uZXdsaW5lIHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBUbyBmb3JtYXQgc29tZXRoaW5nLCBvbmx5IGluIGNhc2UgdGhlIGxpbmUgaGFzIGp1c3QgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfcHJpbnRfaWZfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZVxuICAgICAgeyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX2lmX25ld2xpbmU7IGxlbmd0aCA9IDAgfVxuXG5cbigqIEdlbmVyYWxpemVkIGJyZWFrIGhpbnQgdGhhdCBhbGxvd3MgcHJpbnRpbmcgc3RyaW5ncyBiZWZvcmUvYWZ0ZXJcbiAgIHNhbWUtbGluZSBvZmZzZXQgKHdpZHRoKSBvciBuZXctbGluZSBvZmZzZXQgKilcbmxldCBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGUgfmZpdHMgfmJyZWFrcyA9XG4gIGxldCBiZWZvcmUsIHdpZHRoLCBhZnRlciA9IGZpdHMgaW5cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLm9mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkgaW5cbiAgICBsZXQgdG9rZW4gPSBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IGluXG4gICAgbGV0IGxlbmd0aCA9IFN0cmluZy5sZW5ndGggYmVmb3JlICsgd2lkdGggKyBTdHJpbmcubGVuZ3RoIGFmdGVyIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuKCogUHJpbnRpbmcgYnJlYWsgaGludHM6XG4gICBBIGJyZWFrIGhpbnQgaW5kaWNhdGVzIHdoZXJlIGEgYm94IG1heSBiZSBicm9rZW4uXG4gICBJZiBsaW5lIGlzIGJyb2tlbiB0aGVuIG9mZnNldCBpcyBhZGRlZCB0byB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnRcbiAgIGJveCBlbHNlICh0aGUgdmFsdWUgb2YpIHdpZHRoIGJsYW5rcyBhcmUgcHJpbnRlZC4gKilcbmxldCBwcF9wcmludF9icmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBwcF9wcmludF9jdXN0b21fYnJlYWsgc3RhdGVcbiAgICB+Zml0czooXCJcIiwgd2lkdGgsIFwiXCIpIH5icmVha3M6KFwiXCIsIG9mZnNldCwgXCJcIilcblxuXG4oKiBQcmludCBhIHNwYWNlIDpcbiAgIGEgc3BhY2UgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIGEgc2luZ2xlIHNwYWNlIGlmIHRoZSBicmVhayBkb2VzIG5vdFxuICAgc3BsaXQgdGhlIGxpbmU7XG4gICBhIGN1dCBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgbm90aGluZyBpZiB0aGUgYnJlYWsgZG9lcyBub3Qgc3BsaXQgdGhlXG4gICBsaW5lLiAqKVxubGV0IHBwX3ByaW50X3NwYWNlIHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMSAwXG5hbmQgcHBfcHJpbnRfY3V0IHN0YXRlICgpID0gcHBfcHJpbnRfYnJlYWsgc3RhdGUgMCAwXG5cblxuKCogVGFidWxhdGlvbiBib3hlcy4gKilcbmxldCBwcF9vcGVuX3Rib3ggc3RhdGUgKCkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUuemVybyBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSk7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCogQ2xvc2UgYSB0YWJ1bGF0aW9uIGJveC4gKilcbmxldCBwcF9jbG9zZV90Ym94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3RlbmQ7IGxlbmd0aCA9IDAgfSBpblxuICAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbTtcbiAgICAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoIC0gMVxuICBlbmRcblxuXG4oKiBQcmludCBhIHRhYnVsYXRpb24gYnJlYWsuICopXG5sZXQgcHBfcHJpbnRfdGJyZWFrIHN0YXRlIHdpZHRoIG9mZnNldCA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IGVsZW0gPSB7IHNpemU7IHRva2VuID0gUHBfdGJyZWFrICh3aWR0aCwgb2Zmc2V0KTsgbGVuZ3RoID0gd2lkdGggfSBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID0geyBzaXplID0gU2l6ZS56ZXJvOyB0b2tlbiA9IFBwX3N0YWI7IGxlbmd0aCA9IDAgfSBpblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtXG5cblxuKCpcblxuICBQcm9jZWR1cmVzIHRvIGNvbnRyb2wgdGhlIHByZXR0eS1wcmludGVyc1xuXG4qKVxuXG4oKiBTZXRfbWF4X2JveGVzLiAqKVxubGV0IHBwX3NldF9tYXhfYm94ZXMgc3RhdGUgbiA9IGlmIG4gPiAxIHRoZW4gc3RhdGUucHBfbWF4X2JveGVzIDwtIG5cblxuKCogVG8ga25vdyB0aGUgY3VycmVudCBtYXhpbXVtIG51bWJlciBvZiBib3hlcyBhbGxvd2VkLiAqKVxubGV0IHBwX2dldF9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxubGV0IHBwX292ZXJfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfY3Vycl9kZXB0aCA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG4oKiBFbGxpcHNpcy4gKilcbmxldCBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSBzID0gc3RhdGUucHBfZWxsaXBzaXMgPC0gc1xuYW5kIHBwX2dldF9lbGxpcHNpc190ZXh0IHN0YXRlICgpID0gc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUbyBzZXQgdGhlIG1hcmdpbiBvZiBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9saW1pdCBuID1cbiAgaWYgbiA8IHBwX2luZmluaXR5IHRoZW4gbiBlbHNlIHByZWQgcHBfaW5maW5pdHlcblxuXG4oKiBJbnRlcm5hbCBwcmV0dHktcHJpbnRlciBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X21pbl9zcGFjZV9sZWZ0IHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0IDwtIG47XG4gICAgc3RhdGUucHBfbWF4X2luZGVudCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9yaW5pdCBzdGF0ZVxuXG5cbigqIEluaXRpYWxseSwgd2UgaGF2ZSA6XG4gICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQsIGFuZFxuICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbi4gKilcbmxldCBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuID1cbiAgaWYgbiA+IDEgdGhlblxuICAgIHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSAoc3RhdGUucHBfbWFyZ2luIC0gbilcblxuXG5sZXQgcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXhfaW5kZW50XG5cbmxldCBwcF9zZXRfbWFyZ2luIHN0YXRlIG4gPVxuICBpZiBuID49IDEgdGhlblxuICAgIGxldCBuID0gcHBfbGltaXQgbiBpblxuICAgIHN0YXRlLnBwX21hcmdpbiA8LSBuO1xuICAgIGxldCBuZXdfbWF4X2luZGVudCA9XG4gICAgICAoKiBUcnkgdG8gbWFpbnRhaW4gbWF4X2luZGVudCB0byBpdHMgYWN0dWFsIHZhbHVlLiAqKVxuICAgICAgaWYgc3RhdGUucHBfbWF4X2luZGVudCA8PSBzdGF0ZS5wcF9tYXJnaW5cbiAgICAgIHRoZW4gc3RhdGUucHBfbWF4X2luZGVudCBlbHNlXG4gICAgICAoKiBJZiBwb3NzaWJsZSBtYWludGFpbiBwcF9taW5fc3BhY2VfbGVmdCB0byBpdHMgYWN0dWFsIHZhbHVlLFxuICAgICAgICAgaWYgdGhpcyBsZWFkcyB0byBhIHRvbyBzbWFsbCBtYXhfaW5kZW50LCB0YWtlIGhhbGYgb2YgdGhlXG4gICAgICAgICBuZXcgbWFyZ2luLCBpZiBpdCBpcyBncmVhdGVyIHRoYW4gMS4gKilcbiAgICAgICBtYXggKG1heCAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQpXG4gICAgICAgICAgICAgICAgKHN0YXRlLnBwX21hcmdpbiAvIDIpKSAxIGluXG4gICAgKCogUmVidWlsZCBpbnZhcmlhbnRzLiAqKVxuICAgIHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG5ld19tYXhfaW5kZW50XG5cblxuKCoqIEdlb21ldHJ5IGZ1bmN0aW9ucyBhbmQgdHlwZXMgKilcbnR5cGUgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ6aW50OyBtYXJnaW46IGludH1cblxubGV0IGNoZWNrX2dlb21ldHJ5IGdlb21ldHJ5ID1cbiAgZ2VvbWV0cnkubWF4X2luZGVudCA+IDFcbiAgJiYgIGdlb21ldHJ5Lm1hcmdpbiA+IGdlb21ldHJ5Lm1heF9pbmRlbnRcblxubGV0IHBwX2dldF9tYXJnaW4gc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJnaW5cblxubGV0IHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luID1cbiAgaWYgbWF4X2luZGVudCA8IDIgdGhlblxuICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRm9ybWF0LnBwX3NldF9nZW9tZXRyeTogbWF4X2luZGVudCA8IDJcIilcbiAgZWxzZSBpZiBtYXJnaW4gPD0gbWF4X2luZGVudCB0aGVuXG4gICAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkZvcm1hdC5wcF9zZXRfZ2VvbWV0cnk6IG1hcmdpbiA8PSBtYXhfaW5kZW50XCIpXG4gIGVsc2VcbiAgICBwcF9zZXRfbWFyZ2luIHN0YXRlIG1hcmdpbjsgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbWF4X2luZGVudFxuXG5sZXQgcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGlmIGNoZWNrX2dlb21ldHJ5IHttYXhfaW5kZW50O21hcmdpbn0gdGhlblxuICAgIHBwX3NldF9nZW9tZXRyeSBzdGF0ZSB+bWF4X2luZGVudCB+bWFyZ2luXG4gIGVsc2VcbiAgICAoKVxuXG5sZXQgcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpID1cbiAgeyBtYXJnaW4gPSBwcF9nZXRfbWFyZ2luIHN0YXRlICgpOyBtYXhfaW5kZW50ID0gcHBfZ2V0X21heF9pbmRlbnQgc3RhdGUgKCkgfVxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuICopXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgIG91dF9zdHJpbmcgPSBmO1xuICAgICAgb3V0X2ZsdXNoID0gZztcbiAgICAgIG91dF9uZXdsaW5lID0gaDtcbiAgICAgIG91dF9zcGFjZXMgPSBpO1xuICAgICAgb3V0X2luZGVudCA9IGo7XG4gICAgfSA9XG4gIHN0YXRlLnBwX291dF9zdHJpbmcgPC0gZjtcbiAgc3RhdGUucHBfb3V0X2ZsdXNoIDwtIGc7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGg7XG4gIHN0YXRlLnBwX291dF9zcGFjZXMgPC0gaTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBqXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG91dF9zdHJpbmcgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nO1xuICBvdXRfZmx1c2ggPSBzdGF0ZS5wcF9vdXRfZmx1c2g7XG4gIG91dF9uZXdsaW5lID0gc3RhdGUucHBfb3V0X25ld2xpbmU7XG4gIG91dF9zcGFjZXMgPSBzdGF0ZS5wcF9vdXRfc3BhY2VzO1xuICBvdXRfaW5kZW50ID0gc3RhdGUucHBfb3V0X2luZGVudDtcbn1cblxuXG4oKiBTZXR0aW5nIGEgZm9ybWF0dGVyIGJhc2ljIHN0cmluZyBvdXRwdXQgYW5kIGZsdXNoIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmOyBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZ1xuXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaClcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfbmV3bGluZSBzdGF0ZSAoKSA9IHN0YXRlLnBwX291dF9zdHJpbmcgXCJcXG5cIiAwICAxXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBzcGFjZXMuICopXG5sZXQgYmxhbmtfbGluZSA9IFN0cmluZy5tYWtlIDgwICcgJ1xubGV0IHJlYyBkaXNwbGF5X2JsYW5rcyBzdGF0ZSBuID1cbiAgaWYgbiA+IDAgdGhlblxuICBpZiBuIDw9IDgwIHRoZW4gc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgbiBlbHNlXG4gIGJlZ2luXG4gICAgc3RhdGUucHBfb3V0X3N0cmluZyBibGFua19saW5lIDAgODA7XG4gICAgZGlzcGxheV9ibGFua3Mgc3RhdGUgKG4gLSA4MClcbiAgZW5kXG5cblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbmxldCBkaXNwbGF5X2luZGVudCA9IGRpc3BsYXlfYmxhbmtzXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucyBhcyBwcmludGluZyB0byBhIGdpdmVuXG4gICBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0YXRlIG9jID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBvdXRwdXRfc3Vic3RyaW5nIG9jO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gKGZ1biAoKSAtPiBmbHVzaCBvYyk7XG4gIHN0YXRlLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBzdGF0ZTtcbiAgc3RhdGUucHBfb3V0X2luZGVudCA8LSBkaXNwbGF5X2luZGVudCBzdGF0ZVxuXG4oKlxuXG4gIERlZmluaW5nIHNwZWNpZmljIGZvcm1hdHRlcnNcblxuKilcblxubGV0IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPFwiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5sZXQgZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyA9IGZ1bmN0aW9uXG4gIHwgU3RyaW5nX3RhZyBzIC0+IFwiPC9cIiBeIHMgXiBcIj5cIlxuICB8IF8gLT4gXCJcIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgc3lzX3RvayA9XG4gICAgeyBzaXplID0gU2l6ZS51bmtub3duOyB0b2tlbiA9IFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpOyBsZW5ndGggPSAwIH0gaW5cbiAgUXVldWUuYWRkIHN5c190b2sgcHBfcXVldWU7XG4gIGxldCBzY2FuX3N0YWNrID0gU3RhY2suY3JlYXRlICgpIGluXG4gIGluaXRpYWxpemVfc2Nhbl9zdGFjayBzY2FuX3N0YWNrO1xuICBTdGFjay5wdXNoIHsgbGVmdF90b3RhbCA9IDE7IHF1ZXVlX2VsZW0gPSBzeXNfdG9rIH0gc2Nhbl9zdGFjaztcbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc2Nhbl9zdGFjaztcbiAgICBwcF9mb3JtYXRfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfdGJveF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90YWdfc3RhY2sgPSBTdGFjay5jcmVhdGUgKCk7XG4gICAgcHBfbWFya19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtTdGRsaWIuc3Rkb3V0XSwgW1N0ZGxpYi5zdGRlcnJdLCBhbmQgeyFzdGRidWZ9LiAqKVxubGV0IHN0ZF9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgU3RkbGliLnN0ZGVyclxuYW5kIHN0cl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIHN0ZGJ1ZlxuXG5cbigqIFtmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGZdIGZsdXNoZXMgZm9ybWF0dGVyIFtwcGZdLFxuICAgdGhlbiByZXR1cm5zIHRoZSBjb250ZW50cyBvZiBidWZmZXIgW2J1Zl0gdGhhdCBpcyByZXNldC5cbiAgIEZvcm1hdHRlciBbcHBmXSBpcyBzdXBwb3NlZCB0byBwcmludCB0byBidWZmZXIgW2J1Zl0sIG90aGVyd2lzZSB0aGlzXG4gICBmdW5jdGlvbiBpcyBub3QgcmVhbGx5IHVzZWZ1bC4gKilcbmxldCBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGJ1ZiBwcGYgPVxuICBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2U7XG4gIGxldCBzID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICBCdWZmZXIucmVzZXQgYnVmO1xuICBzXG5cblxuKCogRmx1c2ggW3N0cl9mb3JtYXR0ZXJdIGFuZCBnZXQgdGhlIGNvbnRlbnRzIG9mIFtzdGRidWZdLiAqKVxubGV0IGZsdXNoX3N0cl9mb3JtYXR0ZXIgKCkgPSBmbHVzaF9idWZmZXJfZm9ybWF0dGVyIHN0ZGJ1ZiBzdHJfZm9ybWF0dGVyXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZ1xuKilcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nIGlzIHByZXR0eS1wcmludGluZyB3aXRoIG5vIGxvdyBsZXZlbCBvdXRwdXQuXG5cbiAgV2hlbiB1c2luZyBhIHN5bWJvbGljIGZvcm1hdHRlciwgYWxsIHJlZ3VsYXIgcHJldHR5LXByaW50aW5nIGFjdGl2aXRpZXNcbiAgb2NjdXIgYnV0IG91dHB1dCBtYXRlcmlhbCBpcyBzeW1ib2xpYyBhbmQgc3RvcmVkIGluIGEgYnVmZmVyIG9mIG91dHB1dFxuICBpdGVtcy4gQXQgdGhlIGVuZCBvZiBwcmV0dHktcHJpbnRpbmcsIGZsdXNoaW5nIHRoZSBvdXRwdXQgYnVmZmVyIGFsbG93c1xuICBwb3N0LXByb2Nlc3Npbmcgb2Ygc3ltYm9saWMgb3V0cHV0IGJlZm9yZSBsb3cgbGV2ZWwgb3V0cHV0IG9wZXJhdGlvbnMuXG4qKVxuXG50eXBlIHN5bWJvbGljX291dHB1dF9pdGVtID1cbiAgfCBPdXRwdXRfZmx1c2hcbiAgfCBPdXRwdXRfbmV3bGluZVxuICB8IE91dHB1dF9zdHJpbmcgb2Ygc3RyaW5nXG4gIHwgT3V0cHV0X3NwYWNlcyBvZiBpbnRcbiAgfCBPdXRwdXRfaW5kZW50IG9mIGludFxuXG50eXBlIHN5bWJvbGljX291dHB1dF9idWZmZXIgPSB7XG4gIG11dGFibGUgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDogc3ltYm9saWNfb3V0cHV0X2l0ZW0gbGlzdDtcbn1cblxubGV0IG1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciAoKSA9XG4gIHsgc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzID0gW10gfVxuXG5sZXQgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIFtdXG5cbmxldCBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBMaXN0LnJldiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBpdGVtcyA9IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiBpblxuICBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYjtcbiAgaXRlbXNcblxubGV0IGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgaXRlbSA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gaXRlbSA6OiBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzXG5cbmxldCBmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgc3ltYm9saWNfZmx1c2ggc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9mbHVzaFxuICBhbmQgc3ltYm9saWNfbmV3bGluZSBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X25ld2xpbmVcbiAgYW5kIHN5bWJvbGljX3N0cmluZyBzb2IgcyBpIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zdHJpbmcgKFN0cmluZy5zdWIgcyBpIG4pKVxuICBhbmQgc3ltYm9saWNfc3BhY2VzIHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3BhY2VzIG4pXG4gIGFuZCBzeW1ib2xpY19pbmRlbnQgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9pbmRlbnQgbikgaW5cblxuICBsZXQgZiA9IHN5bWJvbGljX3N0cmluZyBzb2JcbiAgYW5kIGcgPSBzeW1ib2xpY19mbHVzaCBzb2JcbiAgYW5kIGggPSBzeW1ib2xpY19uZXdsaW5lIHNvYlxuICBhbmQgaSA9IHN5bWJvbGljX3NwYWNlcyBzb2JcbiAgYW5kIGogPSBzeW1ib2xpY19pbmRlbnQgc29iIGluXG4gIHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgalxuXG4oKlxuXG4gIEJhc2ljIGZ1bmN0aW9ucyBvbiB0aGUgJ3N0YW5kYXJkJyBmb3JtYXR0ZXJcbiAgKHRoZSBmb3JtYXR0ZXIgdGhhdCBwcmludHMgdG8gW1N0ZGxpYi5zdGRvdXRdKS5cblxuKilcblxubGV0IG9wZW5faGJveCA9IHBwX29wZW5faGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl92Ym94ID0gcHBfb3Blbl92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2h2Ym94ID0gcHBfb3Blbl9odmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ob3Zib3ggPSBwcF9vcGVuX2hvdmJveCBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9ib3ggPSBwcF9vcGVuX2JveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfYm94ID0gcHBfY2xvc2VfYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3RhZyA9IHBwX29wZW5fdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV90YWcgPSBwcF9jbG9zZV90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fc3RhZyA9IHBwX29wZW5fc3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2Vfc3RhZyA9IHBwX2Nsb3NlX3N0YWcgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2FzID0gcHBfcHJpbnRfYXMgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3N0cmluZyA9IHBwX3ByaW50X3N0cmluZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfaW50ID0gcHBfcHJpbnRfaW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9mbG9hdCA9IHBwX3ByaW50X2Zsb2F0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9jaGFyID0gcHBfcHJpbnRfY2hhciBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYm9vbCA9IHBwX3ByaW50X2Jvb2wgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2JyZWFrID0gcHBfcHJpbnRfYnJlYWsgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2N1dCA9IHBwX3ByaW50X2N1dCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3BhY2UgPSBwcF9wcmludF9zcGFjZSBzdGRfZm9ybWF0dGVyXG5hbmQgZm9yY2VfbmV3bGluZSA9IHBwX2ZvcmNlX25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2ZsdXNoID0gcHBfcHJpbnRfZmx1c2ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X25ld2xpbmUgPSBwcF9wcmludF9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pZl9uZXdsaW5lID0gcHBfcHJpbnRfaWZfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBvcGVuX3Rib3ggPSBwcF9vcGVuX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3Rib3ggPSBwcF9jbG9zZV90Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF90YnJlYWsgPSBwcF9wcmludF90YnJlYWsgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X3RhYiA9IHBwX3NldF90YWIgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RhYiA9IHBwX3ByaW50X3RhYiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWFyZ2luID0gcHBfc2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9pbmRlbnQgPSBwcF9zZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZ2VvbWV0cnkgPSBwcF9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIHNhZmVfc2V0X2dlb21ldHJ5ID0gcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9nZW9tZXRyeSA9IHBwX2dldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2JveGVzID0gcHBfc2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21heF9ib3hlcyA9IHBwX2dldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIG92ZXJfbWF4X2JveGVzID0gcHBfb3Zlcl9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2VsbGlwc2lzX3RleHQgPSBwcF9zZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2VsbGlwc2lzX3RleHQgPSBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9wcmludF90YWdzID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9wcmludF90YWdzID1cbiAgcHBfZ2V0X3ByaW50X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF9tYXJrX3RhZ3MgPVxuICBwcF9zZXRfbWFya190YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFya190YWdzID1cbiAgcHBfZ2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgc2V0X3RhZ3MgPVxuICBwcF9zZXRfdGFncyBzdGRfZm9ybWF0dGVyXG5cblxuKCogQ29udmVuaWVuY2UgZnVuY3Rpb25zICopXG5cbigqIFRvIGZvcm1hdCBhIGxpc3QgKilcbmxldCByZWMgcHBfcHJpbnRfbGlzdCA/KHBwX3NlcCA9IHBwX3ByaW50X2N1dCkgcHBfdiBwcGYgPSBmdW5jdGlvblxuICB8IFtdIC0+ICgpXG4gIHwgW3ZdIC0+IHBwX3YgcHBmIHZcbiAgfCB2IDo6IHZzIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3ByaW50X2xpc3QgfnBwX3NlcCBwcF92IHBwZiB2c1xuXG4oKiBUbyBmb3JtYXQgZnJlZS1mbG93aW5nIHRleHQgKilcbmxldCBwcF9wcmludF90ZXh0IHBwZiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGVmdCA9IHJlZiAwIGluXG4gIGxldCByaWdodCA9IHJlZiAwIGluXG4gIGxldCBmbHVzaCAoKSA9XG4gICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoU3RyaW5nLnN1YiBzICFsZWZ0ICghcmlnaHQgLSAhbGVmdCkpO1xuICAgIGluY3IgcmlnaHQ7IGxlZnQgOj0gIXJpZ2h0O1xuICBpblxuICB3aGlsZSAoIXJpZ2h0IDw+IGxlbikgZG9cbiAgICBtYXRjaCBzLlshcmlnaHRdIHdpdGhcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgZmx1c2ggKCk7XG4gICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gICAgICB8ICcgJyAtPlxuICAgICAgICBmbHVzaCAoKTsgcHBfcHJpbnRfc3BhY2UgcHBmICgpXG4gICAgICAoKiB0aGVyZSBpcyBubyBzcGVjaWZpYyBzdXBwb3J0IGZvciAnXFx0J1xuICAgICAgICAgYXMgaXQgaXMgdW5jbGVhciB3aGF0IGEgcmlnaHQgc2VtYW50aWNzIHdvdWxkIGJlICopXG4gICAgICB8IF8gLT4gaW5jciByaWdodFxuICBkb25lO1xuICBpZiAhbGVmdCA8PiBsZW4gdGhlbiBmbHVzaCAoKVxuXG5sZXQgcHBfcHJpbnRfb3B0aW9uID8obm9uZSA9IGZ1biBfICgpIC0+ICgpKSBwcF92IHBwZiA9IGZ1bmN0aW9uXG58IE5vbmUgLT4gbm9uZSBwcGYgKClcbnwgU29tZSB2IC0+IHBwX3YgcHBmIHZcblxubGV0IHBwX3ByaW50X3Jlc3VsdCB+b2sgfmVycm9yIHBwZiA9IGZ1bmN0aW9uXG58IE9rIHYgLT4gb2sgcHBmIHZcbnwgRXJyb3IgZSAtPiBlcnJvciBwcGYgZVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5sZXQgY29tcHV0ZV90YWcgb3V0cHV0IHRhZ19hY2MgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgb3V0cHV0IHBwZiB0YWdfYWNjO1xuICBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIGxldCBsZW4gPSBCdWZmZXIubGVuZ3RoIGJ1ZiBpblxuICBpZiBsZW4gPCAyIHRoZW4gQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICBlbHNlIEJ1ZmZlci5zdWIgYnVmIDEgKGxlbiAtIDIpXG5cbiAoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBEZWZpbmluZyBjb250aW51YXRpb25zIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMgb2ZcbiAgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLlxuXG4gICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogSW50ZXJwcmV0IGEgZm9ybWF0dGluZyBlbnRpdHkgb24gYSBmb3JtYXR0ZXIuICopXG5sZXQgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmbXRpbmdfbGl0ID0gbWF0Y2ggZm10aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgICAgICAtPiBwcF9jbG9zZV90YWcgcHBmICgpXG4gIHwgQnJlYWsgKF8sIHdpZHRoLCBvZmZzZXQpICAtPiBwcF9wcmludF9icmVhayBwcGYgd2lkdGggb2Zmc2V0XG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9mbHVzaCBwcGYgKClcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgIC0+IHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpXG4gIHwgRmx1c2hfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9wcmludF9uZXdsaW5lIHBwZiAoKVxuICB8IE1hZ2ljX3NpemUgKF8sIF8pICAgICAgICAgLT4gKClcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICdAJ1xuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJyUnXG4gIHwgU2Nhbl9pbmRpYyBjICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCc7IHBwX3ByaW50X2NoYXIgcHBmIGNcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLm91dHB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgZiBwcGY7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gUHJpbnRmLmJ1ZnB1dF9hY2MgYnkgdGhlIGludGVycHJldGF0aW9uIG9mIGZvcm1hdHRpbmcuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBwcGYgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgYykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoU3RyaW5nLm1ha2UgMSBjKTtcbiAgfCBBY2NfZGVsYXkgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIChmICgpKTtcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBvdXRwdXRfZm9ybWF0dGluZ19saXQgcHBmIGY7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX29wZW5fc3RhZyBwcGYgKFN0cmluZ190YWcgKGNvbXB1dGVfdGFnIHN0cnB1dF9hY2MgYWNjJykpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBvdXRwdXRfYWNjIHBwZiBhY2M7IGsgcHBmKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmFuZCBpa2ZwcmludGYgayBwcGYgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBwcGYgZm10XG5cbmxldCBpZnByaW50ZiBfcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGlnbm9yZSAoKSBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZF9mb3JtYXR0ZXIgZm10XG5sZXQgZXByaW50ZiBmbXQgPSBmcHJpbnRmIGVycl9mb3JtYXR0ZXIgZm10XG5cbmxldCBrZHByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIGFjYyAtPiBrIChmdW4gcHBmIC0+IG91dHB1dF9hY2MgcHBmIGFjYykpXG4gICAgRW5kX29mX2FjYyBmbXRcblxubGV0IGRwcmludGYgZm10ID0ga2RwcmludGYgKGZ1biBpIC0+IGkpIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIHN0cnB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgaWQgZm10XG5cbmxldCBrYXNwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBiID0gcHBfbWFrZV9idWZmZXIgKCkgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxubGV0IGFzcHJpbnRmIGZtdCA9IGthc3ByaW50ZiBpZCBmbXRcblxuKCogRmx1c2hpbmcgc3RhbmRhcmQgZm9ybWF0dGVycyBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxuXG5sZXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyAoKSA9XG4gIHBwX3ByaW50X2ZsdXNoIHN0ZF9mb3JtYXR0ZXIgKCk7XG4gIHBwX3ByaW50X2ZsdXNoIGVycl9mb3JtYXR0ZXIgKClcblxubGV0ICgpID0gYXRfZXhpdCBmbHVzaF9zdGFuZGFyZF9mb3JtYXR0ZXJzXG5cbigqXG5cbiAgRGVwcmVjYXRlZCBzdHVmZi5cblxuKilcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGVcbiAgICB+b3V0OmYgfmZsdXNoOmcgfm5ld2xpbmU6aCB+c3BhY2VzOmkgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGlcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoLFxuICAgc3RhdGUucHBfb3V0X25ld2xpbmUsIHN0YXRlLnBwX291dF9zcGFjZXMpXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBlcnJvciBwcm9uZSBmdW5jdGlvbiwgZG8gbm90IHVzZSBpdC5cbiAgIFRoaXMgZnVuY3Rpb24gaXMgbmVpdGhlciBjb21wb3NpdGlvbmFsIG5vciBpbmNyZW1lbnRhbCwgc2luY2UgaXQgZmx1c2hlc1xuICAgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGF0IGVhY2ggY2FsbC5cbiAgIFRvIGdldCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LCBkZWZpbmUgYSBmb3JtYXR0ZXIgb2YgeW91ciBvd24gd3JpdGluZyB0b1xuICAgdGhlIGJ1ZmZlciBhcmd1bWVudCwgYXMgaW5cbiAgIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJcbiAgIHRoZW4gdXNlIHshZnByaW50ZiBwcGZ9IGFzIHVzdWFsLiAqKVxubGV0IGJwcmludGYgYiAoRm9ybWF0IChmbXQsIF8pIDogKCdhLCBmb3JtYXR0ZXIsIHVuaXQpIGZvcm1hdCkgPVxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIGFjYyA9IG91dHB1dF9hY2MgcHBmIGFjYzsgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuXG4oKiBEZXByZWNhdGVkIDogYWxpYXMgZm9yIGtzcHJpbnRmLiAqKVxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuXG5cblxuKCogRGVwcmVjYXRlZCB0YWcgZnVuY3Rpb25zICopXG5cbnR5cGUgZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl90YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3RhZyA9IHBjdDtcbiAgIH0gPVxuICBsZXQgc3RyaW5naWZ5IGYgZSA9IGZ1bmN0aW9uIFN0cmluZ190YWcgcyAtPiBmIHMgfCBfIC0+IGUgaW5cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBzdHJpbmdpZnkgbW90IFwiXCI7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBtY3QgXCJcIjtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gc3RyaW5naWZ5IHBvdCAoKTtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHN0cmluZ2lmeSBwY3QgKClcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBmbXQgKCkgPVxuICBsZXQgZnVucyA9IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgZm10ICgpIGluXG4gIGxldCBtYXJrX29wZW5fdGFnIHMgPSBmdW5zLm1hcmtfb3Blbl9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBtYXJrX2Nsb3NlX3RhZyBzID0gZnVucy5tYXJrX2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X29wZW5fdGFnIHMgPSBmdW5zLnByaW50X29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgcHJpbnRfY2xvc2VfdGFnIHMgPSBmdW5zLnByaW50X2Nsb3NlX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAge21hcmtfb3Blbl90YWc7IG1hcmtfY2xvc2VfdGFnOyBwcmludF9vcGVuX3RhZzsgcHJpbnRfY2xvc2VfdGFnfVxuXG5sZXQgc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRcblxuKCogYWxpYXMgdG8gYXZvaWQgd2FybmluZyBmb3IgYW1iaWd1aXR5IGJldHdlZW5cbiAgIFN0ZGxpYi5mb3JtYXQ2XG4gICBhbmQgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcblxuICAgKHRoZSBmb3JtZXIgaXMgaW4gZmFjdCBhbiBhbGlhcyBmb3IgdGhlIGxhdHRlcixcbiAgICBidXQgdGhlIGFtYmlndWl0eSB3YXJuaW5nIGRvZXNuJ3QgY2FyZSlcbiopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIFN0ZGxpYi5mb3JtYXQ2XG5cblxuKCogVGhlIHJ1bi10aW1lIGxpYnJhcnkgZm9yIHNjYW5uZXJzLiAqKVxuXG4oKiBTY2FubmluZyBidWZmZXJzLiAqKVxubW9kdWxlIHR5cGUgU0NBTk5JTkcgPSBzaWdcblxuICB0eXBlIGluX2NoYW5uZWxcblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB2YWwgc3RkaW4gOiBpbl9jaGFubmVsXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBbc3RkaWJdIGlzIGVxdWl2YWxlbnQgdG8gW1NjYW5uaW5nLmZyb21fY2hhbm5lbCBTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBzdGRpYiA6IGluX2NoYW5uZWxcbiAgKCogQW4gYWxpYXMgZm9yIFtTY2FuZi5zdGRpbl0sIHRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tXG4gICAgIFtTdGRsaWIuc3RkaW5dLiAqKVxuXG4gIHZhbCBuZXh0X2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLm5leHRfY2hhciBpYl0gYWR2YW5jZSB0aGUgc2Nhbm5pbmcgYnVmZmVyIGZvclxuICAgICBvbmUgY2hhcmFjdGVyLlxuICAgICBJZiBubyBtb3JlIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJdIG1hcmsgdGhlIGN1cnJlbnRfY2hhciBhcyBhbHJlYWR5XG4gICAgIHNjYW5uZWQuICopXG5cbiAgdmFsIHBlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBbU2Nhbm5pbmcucGVla19jaGFyIGliXSByZXR1cm5zIHRoZSBjdXJyZW50IGNoYXIgYXZhaWxhYmxlIGluXG4gICAgIHRoZSBidWZmZXIgb3IgcmVhZHMgb25lIGlmIG5lY2Vzc2FyeSAod2hlbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXNcbiAgICAgYWxyZWFkeSBzY2FubmVkKS5cbiAgICAgSWYgbm8gY2hhcmFjdGVyIGNhbiBiZSByZWFkLCBzZXRzIGFuIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiBhbmRcbiAgICAgcmV0dXJucyAnXFwwMDAnLiAqKVxuXG4gIHZhbCBjaGVja2VkX3BlZWtfY2hhciA6IHNjYW5idWYgLT4gY2hhclxuICAoKiBTYW1lIGFzIFtTY2FubmluZy5wZWVrX2NoYXJdIGFib3ZlIGJ1dCBhbHdheXMgcmV0dXJucyBhIHZhbGlkIGNoYXIgb3JcbiAgICAgZmFpbHM6IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgbnVsbCBjaGFyIHdoZW4gdGhlIHJlYWRpbmcgbWV0aG9kIG9mIHRoZVxuICAgICBpbnB1dCBidWZmZXIgaGFzIHJlYWNoZWQgYW4gZW5kIG9mIGZpbGUsIHRoZSBmdW5jdGlvbiByYWlzZXMgZXhjZXB0aW9uXG4gICAgIFtFbmRfb2ZfZmlsZV0uICopXG5cbiAgdmFsIHN0b3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBjaGFyIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc3RvcmVfY2hhciBsaW0gaWIgY10gYWRkcyBbY10gdG8gdGhlIHRva2VuIGJ1ZmZlclxuICAgICBvZiB0aGUgc2Nhbm5pbmcgYnVmZmVyIFtpYl0uIEl0IGFsc28gYWR2YW5jZXMgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3RlciBhbmQgcmV0dXJucyBbbGltIC0gMV0sIGluZGljYXRpbmcgdGhlIG5ldyBsaW1pdCBmb3IgdGhlXG4gICAgIGxlbmd0aCBvZiB0aGUgY3VycmVudCB0b2tlbi4gKilcblxuICB2YWwgc2tpcF9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5za2lwX2NoYXIgbGltIGliXSBpZ25vcmVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci4gKilcblxuICB2YWwgaWdub3JlX2NoYXIgOiBpbnQgLT4gc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmlnbm9yZV9jaGFyIGliIGxpbV0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIgYW5kXG4gICAgIGRlY3JlbWVudHMgdGhlIGxpbWl0LiAqKVxuXG4gIHZhbCB0b2tlbiA6IHNjYW5idWYgLT4gc3RyaW5nXG4gICgqIFtTY2FubmluZy50b2tlbiBpYl0gcmV0dXJucyB0aGUgc3RyaW5nIHN0b3JlZCBpbnRvIHRoZSB0b2tlblxuICAgICBidWZmZXIgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlcjogaXQgcmV0dXJucyB0aGUgdG9rZW4gbWF0Y2hlZCBieSB0aGVcbiAgICAgZm9ybWF0LiAqKVxuXG4gIHZhbCByZXNldF90b2tlbiA6IHNjYW5idWYgLT4gdW5pdFxuICAoKiBbU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWJdIHJlc2V0cyB0aGUgdG9rZW4gYnVmZmVyIG9mXG4gICAgIHRoZSBnaXZlbiBzY2FubmluZyBidWZmZXIuICopXG5cbiAgdmFsIGNoYXJfY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuY2hhcl9jb3VudCBpYl0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgcmVhZCBzbyBmYXIgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBsaW5lX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmxpbmVfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBuZXcgbGluZVxuICAgICBjaGFyYWN0ZXJzIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgdG9rZW5fY291bnQgOiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcudG9rZW5fY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiB0b2tlbnMgcmVhZFxuICAgICBzbyBmYXIgZnJvbSBbaWJdLiAqKVxuXG4gIHZhbCBlb2YgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVvZiBpYl0gcmV0dXJucyB0aGUgZW5kIG9mIGlucHV0IGNvbmRpdGlvblxuICAgICBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBlbmRfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IGJvb2xcbiAgKCogW1NjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYl0gdGVzdHMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlciAoaWYgbm8gY2hhciBoYXMgZXZlciBiZWVuIHJlYWQsIGFuIGF0dGVtcHQgdG9cbiAgICAgcmVhZCBvbmUgaXMgcGVyZm9ybWVkKS4gKilcblxuICB2YWwgYmVnaW5uaW5nX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5iZWdpbm5pbmdfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBiZWdpbm5pbmcgb2YgaW5wdXRcbiAgICAgY29uZGl0aW9uIG9mIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIG5hbWVfb2ZfaW5wdXQgOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcubmFtZV9vZl9pbnB1dCBpYl0gcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgIHNvdXJjZSBmb3IgaW5wdXQgYnVmZmVyIFtpYl0uICopXG5cbiAgdmFsIG9wZW5faW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgb3Blbl9pbl9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9maWxlIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZV9iaW4gOiBmaWxlX25hbWUgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9zdHJpbmcgOiBzdHJpbmcgLT4gaW5fY2hhbm5lbFxuICB2YWwgZnJvbV9mdW5jdGlvbiA6ICh1bml0IC0+IGNoYXIpIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fY2hhbm5lbCA6IFN0ZGxpYi5pbl9jaGFubmVsIC0+IGluX2NoYW5uZWxcblxuICB2YWwgY2xvc2VfaW4gOiBpbl9jaGFubmVsIC0+IHVuaXRcblxuICB2YWwgbWVtb19mcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG4gICgqIE9ic29sZXRlLiAqKVxuXG5lbmRcblxuXG5tb2R1bGUgU2Nhbm5pbmcgOiBTQ0FOTklORyA9IHN0cnVjdFxuXG4gICgqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FuZi4gKilcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbF9uYW1lID1cbiAgICB8IEZyb21fY2hhbm5lbCBvZiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9maWxlIG9mIGZpbGVfbmFtZSAqIFN0ZGxpYi5pbl9jaGFubmVsXG4gICAgfCBGcm9tX2Z1bmN0aW9uXG4gICAgfCBGcm9tX3N0cmluZ1xuXG5cbiAgdHlwZSBpbl9jaGFubmVsID0ge1xuICAgIG11dGFibGUgaWNfZW9mIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhciA6IGNoYXI7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgOiBib29sO1xuICAgIG11dGFibGUgaWNfY2hhcl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2xpbmVfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY190b2tlbl9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX2dldF9uZXh0X2NoYXIgOiB1bml0IC0+IGNoYXI7XG4gICAgaWNfdG9rZW5fYnVmZmVyIDogQnVmZmVyLnQ7XG4gICAgaWNfaW5wdXRfbmFtZSA6IGluX2NoYW5uZWxfbmFtZTtcbiAgfVxuXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIGxldCBudWxsX2NoYXIgPSAnXFwwMDAnXG5cbiAgKCogUmVhZHMgYSBuZXcgY2hhcmFjdGVyIGZyb20gaW5wdXQgYnVmZmVyLlxuICAgICBOZXh0X2NoYXIgbmV2ZXIgZmFpbHMsIGV2ZW4gaW4gY2FzZSBvZiBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IHRoZW4gc2ltcGx5IHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbi4gKilcbiAgbGV0IG5leHRfY2hhciBpYiA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGliLmljX2dldF9uZXh0X2NoYXIgKCkgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIHRydWU7XG4gICAgICBpYi5pY19jaGFyX2NvdW50IDwtIHN1Y2MgaWIuaWNfY2hhcl9jb3VudDtcbiAgICAgIGlmIGMgPSAnXFxuJyB0aGVuIGliLmljX2xpbmVfY291bnQgPC0gc3VjYyBpYi5pY19saW5lX2NvdW50O1xuICAgICAgYyB3aXRoXG4gICAgfCBFbmRfb2ZfZmlsZSAtPlxuICAgICAgbGV0IGMgPSBudWxsX2NoYXIgaW5cbiAgICAgIGliLmljX2N1cnJlbnRfY2hhciA8LSBjO1xuICAgICAgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDwtIGZhbHNlO1xuICAgICAgaWIuaWNfZW9mIDwtIHRydWU7XG4gICAgICBjXG5cblxuICBsZXQgcGVla19jaGFyIGliID1cbiAgICBpZiBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWRcbiAgICB0aGVuIGliLmljX2N1cnJlbnRfY2hhclxuICAgIGVsc2UgbmV4dF9jaGFyIGliXG5cblxuICAoKiBSZXR1cm5zIGEgdmFsaWQgY3VycmVudCBjaGFyIGZvciB0aGUgaW5wdXQgYnVmZmVyLiBJbiBwYXJ0aWN1bGFyXG4gICAgIG5vIGlycmVsZXZhbnQgbnVsbCBjaGFyYWN0ZXIgKGFzIHNldCBieSBbbmV4dF9jaGFyXSBpbiBjYXNlIG9mIGVuZFxuICAgICBvZiBpbnB1dCkgaXMgcmV0dXJuZWQsIHNpbmNlIFtFbmRfb2ZfZmlsZV0gaXMgcmFpc2VkIHdoZW5cbiAgICAgW25leHRfY2hhcl0gc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uIHdoaWxlIHRyeWluZyB0byByZWFkIGFcbiAgICAgbmV3IGNoYXJhY3Rlci4gKilcbiAgbGV0IGNoZWNrZWRfcGVla19jaGFyIGliID1cbiAgICBsZXQgYyA9IHBlZWtfY2hhciBpYiBpblxuICAgIGlmIGliLmljX2VvZiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAgIGNcblxuXG4gIGxldCBlbmRfb2ZfaW5wdXQgaWIgPVxuICAgIGlnbm9yZSAocGVla19jaGFyIGliKTtcbiAgICBpYi5pY19lb2ZcblxuXG4gIGxldCBlb2YgaWIgPSBpYi5pY19lb2ZcblxuICBsZXQgYmVnaW5uaW5nX29mX2lucHV0IGliID0gaWIuaWNfY2hhcl9jb3VudCA9IDBcblxuICBsZXQgbmFtZV9vZl9pbnB1dCBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgX2ljIC0+IFwidW5uYW1lZCBTdGRsaWIgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gU3RkbGliLmNsb3NlX2luIGljOyByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gICgqIFRoZSBzY2FubmVyIGRvZXMgbm90IGNsb3NlIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dDpcbiAgICAgaXQganVzdCByYWlzZXMgW0VuZF9vZl9maWxlXS4gKilcbiAgbGV0IHNjYW5fcmFpc2VfYXRfZW5kIF9pYyA9IHJhaXNlIEVuZF9vZl9maWxlXG5cbiAgbGV0IGZyb21faWMgc2Nhbl9jbG9zZV9pYyBpbmFtZSBpYyA9XG4gICAgbGV0IGxlbiA9ICFmaWxlX2J1ZmZlcl9zaXplIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgbGV0IGxpbSA9IHJlZiAwIGluXG4gICAgbGV0IGVvZiA9IHJlZiBmYWxzZSBpblxuICAgIGxldCBuZXh0ICgpID1cbiAgICAgIGlmICFpIDwgIWxpbSB0aGVuIGJlZ2luIGxldCBjID0gQnl0ZXMuZ2V0IGJ1ZiAhaSBpbiBpbmNyIGk7IGMgZW5kIGVsc2VcbiAgICAgIGlmICFlb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlIGJlZ2luXG4gICAgICAgIGxpbSA6PSBpbnB1dCBpYyBidWYgMCBsZW47XG4gICAgICAgIGlmICFsaW0gPSAwIHRoZW4gYmVnaW4gZW9mIDo9IHRydWU7IHNjYW5fY2xvc2VfaWMgaWMgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBpIDo9IDE7XG4gICAgICAgICAgQnl0ZXMuZ2V0IGJ1ZiAwXG4gICAgICAgIGVuZFxuICAgICAgZW5kIGluXG4gICAgY3JlYXRlIGluYW1lIG5leHRcblxuXG4gIGxldCBmcm9tX2ljX2Nsb3NlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9jbG9zZV9hdF9lbmRcbiAgbGV0IGZyb21faWNfcmFpc2VfYXRfZW5kID0gZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG4gICgqIFRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLlxuICAgICBPbmUgY291bGQgdHJ5IHRvIGRlZmluZSBbc3RkaWJdIGFzIGEgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgYXQgYSB0aW1lIChubyBidWZmZXJpemF0aW9uIGF0IGFsbCksIGJ1dCB1bmZvcnR1bmF0ZWx5IHRoZSB0b3AtbGV2ZWxcbiAgICAgaW50ZXJhY3Rpb24gd291bGQgYmUgd3JvbmcuIFRoaXMgaXMgZHVlIHRvIHNvbWUga2luZCBvZlxuICAgICAncmFjZSBjb25kaXRpb24nIHdoZW4gcmVhZGluZyBmcm9tIFtTdGRsaWIuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbU3RkbGliLnN0ZGluXTsgdGhlbiwgY29uZnVzaW9uXG4gICAgIHdpbGwgcmVzdWx0IGZyb20gd2hhdCBzaG91bGQgYmUgcmVhZCBieSB0aGUgdG9wLWxldmVsIGFuZCB3aGF0IHNob3VsZCBiZVxuICAgICByZWFkIGJ5IFtTY2FuZi5zY2FuZl0uXG4gICAgIFRoaXMgaXMgZXZlbiBtb3JlIGNvbXBsaWNhdGVkIGJ5IHRoZSBvbmUgY2hhcmFjdGVyIGxvb2thaGVhZCB0aGF0XG4gICAgIFtTY2FuZi5zY2FuZl0gaXMgc29tZXRpbWVzIG9ibGlnZWQgdG8gbWFpbnRhaW46IHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyXG4gICAgIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCBbU2NhbmYuc2NhbmZdIGVudHJ5LCBzZWVtaW5nbHkgY29taW5nIGZyb21cbiAgICAgbm93aGVyZS5cbiAgICAgQWxzbyBubyBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuIHJlYWRpbmcgZnJvbSBzdGRpbjogaWYgbm90IGVub3VnaFxuICAgICBjaGFyYWN0ZXJzIGhhdmUgYmVlbiByZWFkLCB3ZSBzaW1wbHkgYXNrIHRvIHJlYWQgbW9yZS4gKilcbiAgbGV0IHN0ZGluID1cbiAgICBmcm9tX2ljIHNjYW5fcmFpc2VfYXRfZW5kXG4gICAgICAoRnJvbV9maWxlIChcIi1cIiwgU3RkbGliLnN0ZGluKSkgU3RkbGliLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgU3RkbGliLm9wZW5faW5cbiAgbGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2ZpbGUgPSBvcGVuX2luXG4gIGxldCBmcm9tX2ZpbGVfYmluID0gb3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBmcm9tX2ljX3JhaXNlX2F0X2VuZCAoRnJvbV9jaGFubmVsIGljKSBpY1xuXG5cbiAgbGV0IGNsb3NlX2luIGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBpYyAtPlxuICAgICAgU3RkbGliLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9mdW5jdGlvbiB8IEZyb21fc3RyaW5nIC0+ICgpXG5cblxuICAoKlxuICAgICBPYnNvbGV0ZTogYSBtZW1vIFtmcm9tX2NoYW5uZWxdIHZlcnNpb24gdG8gYnVpbGQgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF1cbiAgICAgc2Nhbm5pbmcgYnVmZmVyIG91dCBvZiBhIFtTdGRsaWIuaW5fY2hhbm5lbF0uXG4gICAgIFRoaXMgZnVuY3Rpb24gd2FzIHVzZWQgdG8gdHJ5IHRvIHByZXNlcnZlIHRoZSBzY2FubmluZ1xuICAgICBzZW1hbnRpY3MgZm9yIHRoZSAobm93IG9ic29sZXRlKSBmdW5jdGlvbiBbZnNjYW5mXS5cbiAgICAgR2l2ZW4gdGhhdCBhbGwgc2Nhbm5lciBtdXN0IHJlYWQgZnJvbSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBzY2FubmluZ1xuICAgICBidWZmZXIsIFtmc2NhbmZdIG11c3QgcmVhZCBmcm9tIG9uZSFcbiAgICAgTW9yZSBwcmVjaXNlbHksIGdpdmVuIFtpY10sIGFsbCBzdWNjZXNzaXZlIGNhbGxzIFtmc2NhbmYgaWNdIG11c3QgcmVhZFxuICAgICBmcm9tIHRoZSBzYW1lIHNjYW5uaW5nIGJ1ZmZlci5cbiAgICAgVGhpcyBvYmxpZ2VkIHRoaXMgbGlicmFyeSB0byBhbGxvY2F0ZWQgc2Nhbm5pbmcgYnVmZmVycyB0aGF0IHdlcmVcbiAgICAgbm90IHByb3Blcmx5IGdhcmJhZ2UgY29sbGVjdGFibGUsIGhlbmNlIGxlYWRpbmcgdG8gbWVtb3J5IGxlYWtzLlxuICAgICBJZiB5b3UgbmVlZCB0byByZWFkIGZyb20gYSBbU3RkbGliLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgU3RkbGliLippbnQqX29mX3N0cmluZyBkbyBub3QgYWNjZXB0IGEgbGVhZGluZyArLFxuICAgd2Ugc2tpcCBpdCBpZiBuZWNlc3NhcnkuICopXG5sZXQgdG9rZW5faW50X2xpdGVyYWwgY29udiBpYiA9XG4gIGxldCB0b2sgPVxuICAgIG1hdGNoIGNvbnYgd2l0aFxuICAgIHwgRF9jb252ZXJzaW9uIHwgSV9jb252ZXJzaW9uIC0+IFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBVX2NvbnZlcnNpb24gLT4gXCIwdVwiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IE9fY29udmVyc2lvbiAtPiBcIjBvXCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgWF9jb252ZXJzaW9uIC0+IFwiMHhcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBCX2NvbnZlcnNpb24gLT4gXCIwYlwiIF4gU2Nhbm5pbmcudG9rZW4gaWIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHRvayBpblxuICBpZiBsID0gMCB8fCB0b2suWzBdIDw+ICcrJyB0aGVuIHRvayBlbHNlIFN0cmluZy5zdWIgdG9rIDEgKGwgLSAxKVxuXG5cbigqIEFsbCB0aGUgZnVuY3Rpb25zIHRoYXQgY29udmVydCBhIHN0cmluZyB0byBhIG51bWJlciByYWlzZSB0aGUgZXhjZXB0aW9uXG4gICBGYWlsdXJlIHdoZW4gdGhlIGNvbnZlcnNpb24gaXMgbm90IHBvc3NpYmxlLlxuICAgVGhpcyBleGNlcHRpb24gaXMgdGhlbiB0cmFwcGVkIGluIFtrc2NhbmZdLiAqKVxubGV0IHRva2VuX2ludCBjb252IGliID0gaW50X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxubGV0IHRva2VuX2Zsb2F0IGliID0gZmxvYXRfb2Zfc3RyaW5nIChTY2FubmluZy50b2tlbiBpYilcblxuKCogVG8gc2NhbiBuYXRpdmUgaW50cywgaW50MzIgYW5kIGludDY0IGludGVnZXJzLlxuICAgV2UgY2Fubm90IGFjY2VzcyB0byBjb252ZXJzaW9ucyB0by9mcm9tIHN0cmluZ3MgZm9yIHRob3NlIHR5cGVzLFxuICAgTmF0aXZlaW50Lm9mX3N0cmluZywgSW50MzIub2Zfc3RyaW5nLCBhbmQgSW50NjQub2Zfc3RyaW5nLFxuICAgc2luY2UgdGhvc2UgbW9kdWxlcyBhcmUgbm90IGF2YWlsYWJsZSB0byBbU2NhbmZdLlxuICAgSG93ZXZlciwgd2UgY2FuIGJpbmQgYW5kIHVzZSB0aGUgY29ycmVzcG9uZGluZyBwcmltaXRpdmVzIHRoYXQgYXJlXG4gICBhdmFpbGFibGUgaW4gdGhlIHJ1bnRpbWUuICopXG5leHRlcm5hbCBuYXRpdmVpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgaW50MzJfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDY0X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuXG5cbmxldCB0b2tlbl9uYXRpdmVpbnQgY29udiBpYiA9IG5hdGl2ZWludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50MzIgY29udiBpYiA9IGludDMyX29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcbmxldCB0b2tlbl9pbnQ2NCBjb252IGliID0gaW50NjRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxuXG4oKiBTY2FubmluZyBudW1iZXJzLiAqKVxuXG4oKiBEaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHN1cHBvc2UgdGhhdCBvbmUgY2hhcmFjdGVyIGhhcyBiZWVuIGNoZWNrZWQgYW5kXG4gICBpcyBhdmFpbGFibGUsIHNpbmNlIHRoZXkgcmV0dXJuIGF0IGVuZCBvZiBmaWxlIHdpdGggdGhlIGN1cnJlbnRseSBmb3VuZFxuICAgdG9rZW4gc2VsZWN0ZWQuXG5cbiAgIFB1dCBpdCBpbiBhbm90aGVyIHdheSwgdGhlIGRpZ2l0cyBzY2FubmluZyBmdW5jdGlvbnMgc2NhbiBmb3IgYSBwb3NzaWJseVxuICAgZW1wdHkgc2VxdWVuY2Ugb2YgZGlnaXRzLCAoaGVuY2UsIGEgc3VjY2Vzc2Z1bCBzY2FubmluZyBmcm9tIG9uZSBvZiB0aG9zZVxuICAgZnVuY3Rpb25zIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIHRva2VuIGlzIGEgd2VsbC1mb3JtZWQgbnVtYmVyOiB0byBnZXQgYVxuICAgdHJ1ZSBudW1iZXIsIGl0IGlzIG1hbmRhdG9yeSB0byBjaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB2YWxpZCBkaWdpdCBpc1xuICAgYXZhaWxhYmxlIGJlZm9yZSBjYWxsaW5nIG9uZSBvZiB0aGUgZGlnaXQgc2Nhbm5pbmcgZnVuY3Rpb25zKS4gKilcblxuKCogVGhlIGRlY2ltYWwgY2FzZSBpcyB0cmVhdGVkIGVzcGVjaWFsbHkgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4gKilcbmxldCByZWMgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCAnXycgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbmxldCBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1cyB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkZWNpbWFsIGRpZ2l0c1wiIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnMCcgLi4gJzknIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcbiAgfCBjIC0+XG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImNoYXJhY3RlciAlQyBpcyBub3QgYSBkZWNpbWFsIGRpZ2l0XCIgYylcblxuXG4oKiBUbyBzY2FuIG51bWJlcnMgZnJvbSBvdGhlciBiYXNlcywgd2UgdXNlIGEgcHJlZGljYXRlIGFyZ3VtZW50IHRvXG4gICBzY2FuIGRpZ2l0cy4gKilcbmxldCBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBzY2FuX2RpZ2l0cyB3aWR0aCBpYiA9XG4gICAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgYyB3aGVuIGRpZ2l0cCBjIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgIHNjYW5fZGlnaXRzIHdpZHRoIGliXG4gICAgfCAnXycgLT5cbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgXyAtPiB3aWR0aCBpblxuICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2RpZ2l0X3BsdXMgYmFzaXMgZGlnaXRwIHdpZHRoIGliID1cbiAgKCogRW5zdXJlIHdlIGhhdmUgZ290IGVub3VnaCB3aWR0aCBsZWZ0LFxuICAgICBhbmQgcmVhZCBhdCBsZWFzdCBvbmUgZGlnaXQuICopXG4gIGlmIHdpZHRoID0gMCB0aGVuIGJhZF90b2tlbl9sZW5ndGggXCJkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgZGlnaXRwIGMgdGhlblxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGlnaXRfc3RhciBkaWdpdHAgd2lkdGggaWJcbiAgZWxzZVxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgdmFsaWQgJXMgZGlnaXRcIiBjIGJhc2lzKVxuXG5cbmxldCBpc19iaW5hcnlfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnMScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9iaW5hcnlfaW50ID0gc2Nhbl9kaWdpdF9wbHVzIFwiYmluYXJ5XCIgaXNfYmluYXJ5X2RpZ2l0XG5cbmxldCBpc19vY3RhbF9kaWdpdCA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc3JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX29jdGFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcIm9jdGFsXCIgaXNfb2N0YWxfZGlnaXRcblxubGV0IGlzX2hleGFfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5cbmxldCBzY2FuX2hleGFkZWNpbWFsX2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImhleGFkZWNpbWFsXCIgaXNfaGV4YV9kaWdpdFxuXG4oKiBTY2FuIGEgZGVjaW1hbCBpbnRlZ2VyLiAqKVxubGV0IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgPSBzY2FuX2RlY2ltYWxfZGlnaXRfcGx1c1xuXG5sZXQgc2Nhbl9zaWduIHdpZHRoIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnKycgLT4gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjXG4gIHwgJy0nIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG5cblxuKCogU2NhbiBhbiB1bnNpZ25lZCBpbnRlZ2VyIHRoYXQgY291bGQgYmUgZ2l2ZW4gaW4gYW55IChjb21tb24pIGJhc2lzLlxuICAgSWYgZGlnaXRzIGFyZSBwcmVmaXhlZCBieSBvbmUgb2YgMHgsIDBYLCAwbywgb3IgMGIsIHRoZSBudW1iZXIgaXNcbiAgIGFzc3VtZWQgdG8gYmUgd3JpdHRlbiByZXNwZWN0aXZlbHkgaW4gaGV4YWRlY2ltYWwsIGhleGFkZWNpbWFsLFxuICAgb2N0YWwsIG9yIGJpbmFyeS4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIG1hdGNoIFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgICB8ICd4JyB8ICdYJyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ28nIC0+IHNjYW5fb2N0YWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCAnYicgLT4gc2Nhbl9iaW5hcnlfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gICAgfCBfIC0+IHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliIGVuZFxuICB8IF8gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2ludCB3aWR0aCBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5fc2lnbiB3aWR0aCBpYiBpblxuICBzY2FuX3Vuc2lnbmVkX2ludCB3aWR0aCBpYlxuXG5cbmxldCBzY2FuX2ludF9jb252ZXJzaW9uIGNvbnYgd2lkdGggaWIgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBCX2NvbnZlcnNpb24gLT4gc2Nhbl9iaW5hcnlfaW50IHdpZHRoIGliXG4gIHwgRF9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBJX2NvbnZlcnNpb24gLT4gc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWJcbiAgfCBPX2NvbnZlcnNpb24gLT4gc2Nhbl9vY3RhbF9pbnQgd2lkdGggaWJcbiAgfCBVX2NvbnZlcnNpb24gLT4gc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICB8IFhfY29udmVyc2lvbiAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW5uaW5nIGZsb2F0aW5nIHBvaW50IG51bWJlcnMuICopXG5cbigqIEZyYWN0aW9uYWwgcGFydCBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlZHVjZWQgdG8gMCBkaWdpdHMuICopXG5sZXQgc2Nhbl9mcmFjdGlvbmFsX3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogRXhwIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYiA9XG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gd2lkdGggZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnZScgfCAnRScgYXMgYyAtPlxuICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgfCBfIC0+IHdpZHRoXG5cblxuKCogU2NhbiB0aGUgaW50ZWdlciBwYXJ0IG9mIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCAobm90IHVzaW5nIHRoZVxuICAgT0NhbWwgbGV4aWNhbCBjb252ZW50aW9uIHNpbmNlIHRoZSBpbnRlZ2VyIHBhcnQgY2FuIGJlIGVtcHR5KTpcbiAgIGFuIG9wdGlvbmFsIHNpZ24sIGZvbGxvd2VkIGJ5IGEgcG9zc2libHkgZW1wdHkgc2VxdWVuY2Ugb2YgZGVjaW1hbFxuICAgZGlnaXRzIChlLmcuIC0uMSkuICopXG5sZXQgc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWJcblxuXG4oKlxuICAgRm9yIHRoZSB0aW1lIGJlaW5nIHdlIGhhdmUgKGFzIGZvdW5kIGluIHNjYW5mLm1saSk6XG4gICB0aGUgZmllbGQgd2lkdGggaXMgY29tcG9zZWQgb2YgYW4gb3B0aW9uYWwgaW50ZWdlciBsaXRlcmFsXG4gICBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsIHdpZHRoIG9mIHRoZSB0b2tlbiB0byByZWFkLlxuICAgVW5mb3J0dW5hdGVseSwgdGhlIHR5cGUtY2hlY2tlciBsZXQgdGhlIHVzZXIgd3JpdGUgYW4gb3B0aW9uYWwgcHJlY2lzaW9uLFxuICAgc2luY2UgdGhpcyBpcyB2YWxpZCBmb3IgcHJpbnRmIGZvcm1hdCBzdHJpbmdzLlxuXG4gICBUaHVzLCB0aGUgbmV4dCBzdGVwIGZvciBTY2FuZiBpcyB0byBzdXBwb3J0IGEgZnVsbCB3aWR0aCBhbmQgcHJlY2lzaW9uXG4gICBpbmRpY2F0aW9uLCBtb3JlIG9yIGxlc3Mgc2ltaWxhciB0byB0aGUgb25lIGZvciBwcmludGYsIHBvc3NpYmx5IGV4dGVuZGVkXG4gICB0byB0aGUgc3BlY2lmaWNhdGlvbiBvZiBhIFttYXgsIG1pbl0gcmFuZ2UgZm9yIHRoZSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZFxuICAgZm9yIHN0cmluZ3MuIFNvbWV0aGluZyBsaWtlIHRoZSBmb2xsb3dpbmcgc3BlYyBmb3Igc2NhbmYubWxpOlxuXG4gICBUaGUgb3B0aW9uYWwgW3dpZHRoXSBpcyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltYWxcbiAgIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLiBGb3IgaW5zdGFuY2UsIFslNmRdIHJlYWRzIGFuIGludGVnZXIsXG4gICBoYXZpbmcgYXQgbW9zdCA2IGNoYXJhY3RlcnMuXG5cbiAgIFRoZSBvcHRpb25hbCBbcHJlY2lzaW9uXSBpcyBhIGRvdCBbLl0gZm9sbG93ZWQgYnkgYW4gaW50ZWdlcjpcblxuICAgLSBpbiB0aGUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGNvbnZlcnNpb25zIChbJWZdLCBbJWVdLCBbJWddLCBbJUZdLCBbJUVdLFxuICAgYW5kIFslRl0gY29udmVyc2lvbnMsIHRoZSBbcHJlY2lzaW9uXSBpbmRpY2F0ZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mXG4gICBkaWdpdHMgdGhhdCBtYXkgZm9sbG93IHRoZSBkZWNpbWFsIHBvaW50LiBGb3IgaW5zdGFuY2UsIFslLjRmXSByZWFkcyBhXG4gICBbZmxvYXRdIHdpdGggYXQgbW9zdCA0IGZyYWN0aW9uYWwgZGlnaXRzLFxuXG4gICAtIGluIHRoZSBzdHJpbmcgY29udmVyc2lvbnMgKFslc10sIFslU10sIFslXFxbIHJhbmdlIFxcXV0pLCBhbmQgaW4gdGhlXG4gICBpbnRlZ2VyIG51bWJlciBjb252ZXJzaW9ucyAoWyVpXSwgWyVkXSwgWyV1XSwgWyV4XSwgWyVvXSwgYW5kIHRoZWlyXG4gICBbaW50MzJdLCBbaW50NjRdLCBhbmQgW25hdGl2ZV9pbnRdIGNvcnJlc3BvbmRlbnQpLCB0aGUgW3ByZWNpc2lvbl1cbiAgIGluZGljYXRlcyB0aGUgcmVxdWlyZWQgbWluaW11bSB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZCxcblxuICAgLSBvbiBhbGwgb3RoZXIgY29udmVyc2lvbnMsIHRoZSB3aWR0aCBhbmQgcHJlY2lzaW9uIHNwZWNpZnkgdGhlIFttYXgsIG1pbl1cbiAgIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWQuXG4qKVxubGV0IHNjYW5fZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9pbnRlZ2VyX3BhcnQgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGgsIHByZWNpc2lvbiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHByZWNpc2lvbiBpYikgaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuICB8IF8gLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIsIHByZWNpc2lvblxuXG5cbmxldCBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBlcnJvciBzdHIgPVxuICBsZXQgbG93ZXJjYXNlIGMgPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ0EnIC4uICdaJyAtPlxuICAgICAgY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKyBpbnRfb2ZfY2hhciAnYScpXG4gICAgfCBfIC0+IGMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCA9IHJlZiB3aWR0aCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgbG93ZXJjYXNlIGMgPD4gbG93ZXJjYXNlIHN0ci5baV0gdGhlbiBlcnJvciAoKTtcbiAgICBpZiAhd2lkdGggPSAwIHRoZW4gZXJyb3IgKCk7XG4gICAgd2lkdGggOj0gU2Nhbm5pbmcuc3RvcmVfY2hhciAhd2lkdGggaWIgYztcbiAgZG9uZTtcbiAgIXdpZHRoXG5cblxubGV0IHNjYW5faGV4X2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGxldCB3aWR0aCA9IGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJ4XCIgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgfCBfIC0+IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgIHwgJy4nIGFzIGMgLT4gKFxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgICApXG4gICAgICAgICAgfCBfIC0+IHdpZHRoIGluXG4gICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICAgIHwgXyAtPiB3aWR0aFxuICApXG4gIHwgJ24nIHwgJ04nIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwiYW5cIlxuICB8ICdpJyB8ICdJJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcIm5maW5pdHlcIlxuICB8IF8gLT4gYmFkX2hleF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBpblxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBtYXRjaCBjIHdpdGhcbiAgfCAnLicgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAoKiBUaGUgZWZmZWN0aXZlIHdpZHRoIGF2YWlsYWJsZSBmb3Igc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCBpc1xuICAgICAgIHRoZSBtaW5pbXVtIG9mIGRlY2xhcmVkIHByZWNpc2lvbiBhbmQgd2lkdGggbGVmdC4gKilcbiAgICBsZXQgcHJlY2lzaW9uID0gbWluIHdpZHRoIHByZWNpc2lvbiBpblxuICAgICgqIEFmdGVyIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBbcHJlY2lzaW9uXSBwcm92aXNpb25hbCB3aWR0aCxcbiAgICAgICBbd2lkdGhfcHJlY2lzaW9uXSBpcyBsZWZ0LiAqKVxuICAgIGxldCB3aWR0aF9wcmVjaXNpb24gPSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIgaW5cbiAgICAoKiBIZW5jZSwgc2Nhbm5pbmcgdGhlIGZyYWN0aW9uYWwgcGFydCB0b29rIGV4YWN0bHlcbiAgICAgICBbcHJlY2lzaW9uIC0gd2lkdGhfcHJlY2lzaW9uXSBjaGFycy4gKilcbiAgICBsZXQgZnJhY193aWR0aCA9IHByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbiBpblxuICAgICgqIEFuZCBuZXcgcHJvdmlzaW9uYWwgd2lkdGggaXMgW3dpZHRoIC0gd2lkdGhfcHJlY2lzaW9uLiAqKVxuICAgIGxldCB3aWR0aCA9IHdpZHRoIC0gZnJhY193aWR0aCBpblxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8ICdlJyB8ICdFJyAtPlxuICAgIHNjYW5fZXhwb25lbnRfcGFydCB3aWR0aCBpYlxuICB8IF8gLT4gYmFkX2Zsb2F0ICgpXG5cblxubGV0IHNjYW5fY2FtbF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgfCAnMCcgYXMgYyAtPiAoXG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ3gnIHwgJ1gnIGFzIGMgLT4gKFxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWIgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgICBsZXQgd2lkdGggPSBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgd2lkdGggLSAocHJlY2lzaW9uIC0gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgcHJlY2lzaW9uIGliKVxuICAgICAgICApXG4gICAgICAgIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBiYWRfZmxvYXQgKCkgaW5cbiAgICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJ3AnIHwgJ1AnIGFzIGMgLT5cbiAgICAgICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gICAgICAgIHwgXyAtPiB3aWR0aFxuICAgIClcbiAgICB8IF8gLT5cbiAgICAgIHNjYW5fY2FtbF9mbG9hdF9yZXN0IHdpZHRoIHByZWNpc2lvbiBpYlxuICApXG4gIHwgJzEnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbigqIFNwZWNpYWwgY2FzZSBvZiBuYW4gYW5kIGluZmluaXR5OlxuICB8ICdpJyAtPlxuICB8ICduJyAtPlxuKilcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbigqIFNjYW4gYSByZWd1bGFyIHN0cmluZzpcbiAgIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIGEgc3BhY2UsIGlmIG5vIHNjYW5uaW5nIGluZGljYXRpb24gaGFzIGJlZW4gZ2l2ZW47XG4gICBvdGhlcndpc2UsIHN0b3BzIHdoZW4gZW5jb3VudGVyaW5nIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzY2FubmluZ1xuICAgaW5kaWNhdGlvbiBbc3RwXS5cbiAgIEl0IGFsc28gc3RvcHMgYXQgZW5kIG9mIGZpbGUgb3Igd2hlbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyBoYXNcbiAgIGJlZW4gcmVhZC4gKilcbmxldCBzY2FuX3N0cmluZyBzdHAgd2lkdGggaWIgPVxuICBsZXQgcmVjIGxvb3Agd2lkdGggPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIG1hdGNoIHN0cCB3aXRoXG4gICAgICB8IFNvbWUgYycgd2hlbiBjID0gYycgLT4gU2Nhbm5pbmcuc2tpcF9jaGFyIHdpZHRoIGliXG4gICAgICB8IFNvbWUgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBsb29wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGluXG4gIGxvb3Agd2lkdGhcblxuXG4oKiBTY2FuIGEgY2hhcjogcGVlayBzdHJpY3RseSBvbmUgY2hhcmFjdGVyIGluIHRoZSBpbnB1dCwgd2hhdHNvZXZlci4gKilcbmxldCBzY2FuX2NoYXIgd2lkdGggaWIgPVxuICAoKiBUaGUgY2FzZSB3aWR0aCA9IDAgY291bGQgbm90IGhhcHBlbiBoZXJlLCBzaW5jZSBpdCBpcyB0ZXN0ZWQgYmVmb3JlXG4gICAgIGNhbGxpbmcgc2Nhbl9jaGFyLCBpbiB0aGUgbWFpbiBzY2FubmluZyBmdW5jdGlvbi5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiYSBjaGFyYWN0ZXJcIiBlbHNlICopXG4gIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliKVxuXG5cbmxldCBjaGFyX2Zvcl9iYWNrc2xhc2ggPSBmdW5jdGlvblxuICB8ICduJyAtPiAnXFwwMTAnXG4gIHwgJ3InIC0+ICdcXDAxMydcbiAgfCAnYicgLT4gJ1xcMDA4J1xuICB8ICd0JyAtPiAnXFwwMDknXG4gIHwgYyAtPiBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGRlY2ltYWwgZGlnaXQgY2hhcmFjdGVyLiAqKVxubGV0IGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID0gaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJ1xuXG5sZXQgY2hhcl9mb3JfZGVjaW1hbF9jb2RlIGMwIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDEwMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMCArXG4gICAgIDEwICogZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMxICtcbiAgICAgICAgICBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzIgaW5cbiAgaWYgYyA8IDAgfHwgYyA+IDI1NSB0aGVuXG4gICAgYmFkX2lucHV0XG4gICAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICAgIFwiYmFkIGNoYXJhY3RlciBkZWNpbWFsIGVuY29kaW5nIFxcXFwlYyVjJWNcIiBjMCBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogVGhlIGludGVnZXIgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgZmFjaWFsIHZhbHVlIG9mIGEgdmFsaWRcbiAgIGhleGFkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMgPVxuICBsZXQgZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgKCogQ291bGQgYWxzbyBiZTpcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICc5JyB0aGVuIGQgLSBpbnRfb2ZfY2hhciAnMCcgZWxzZVxuICAgIGlmIGQgPD0gaW50X29mX2NoYXIgJ0YnIHRoZW4gMTAgKyBkIC0gaW50X29mX2NoYXIgJ0EnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdmJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdhJyBlbHNlIGFzc2VydCBmYWxzZVxuICAqKVxuICBpZiBkID49IGludF9vZl9jaGFyICdhJyB0aGVuXG4gICAgZCAtIDg3ICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdhJyAqKSBlbHNlXG4gIGlmIGQgPj0gaW50X29mX2NoYXIgJ0EnIHRoZW5cbiAgICBkIC0gNTUgICgqIDEwICsgaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICdBJyAqKSBlbHNlXG4gICAgZCAtIGludF9vZl9jaGFyICcwJ1xuXG5cbmxldCBjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyID1cbiAgbGV0IGMgPVxuICAgIDE2ICogaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICBoZXhhZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmIFwiYmFkIGNoYXJhY3RlciBoZXhhZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlY1wiIGMxIGMyKSBlbHNlXG4gIGNoYXJfb2ZfaW50IGNcblxuXG4oKiBDYWxsZWQgaW4gcGFydGljdWxhciB3aGVuIGVuY291bnRlcmluZyAnXFxcXCcgYXMgc3RhcnRlciBvZiBhIGNoYXIuXG4gICBTdG9wcyBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmcgJ1xcJycuICopXG5sZXQgY2hlY2tfbmV4dF9jaGFyIG1lc3NhZ2Ugd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiBiYWRfZW5kX29mX2lucHV0IG1lc3NhZ2UgZWxzZVxuICBjXG5cblxubGV0IGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciA9IGNoZWNrX25leHRfY2hhciBcImEgQ2hhclwiXG5sZXQgY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgPSBjaGVja19uZXh0X2NoYXIgXCJhIFN0cmluZ1wiXG5cbmxldCBzY2FuX2JhY2tzbGFzaF9jaGFyIHdpZHRoIGliID1cbiAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgfCAnXFxcXCcgfCAnXFwnJyB8ICdcXFwiJyB8ICduJyB8ICd0JyB8ICdiJyB8ICdyJyBhcyBjIC0+XG4gICAgU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAoY2hhcl9mb3JfYmFja3NsYXNoIGMpXG4gIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPiBjXG4gICAgICB8IGMgLT4gYmFkX2lucHV0X2VzY2FwZSBjIGluXG4gICAgbGV0IGMwID0gYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMilcbiAgfCAneCcgLT5cbiAgICBsZXQgZ2V0X2RpZ2l0ICgpID1cbiAgICAgIGxldCBjID0gU2Nhbm5pbmcubmV4dF9jaGFyIGliIGluXG4gICAgICBtYXRjaCBjIHdpdGhcbiAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMSA9IGdldF9kaWdpdCAoKSBpblxuICAgIGxldCBjMiA9IGdldF9kaWdpdCAoKSBpblxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgKHdpZHRoIC0gMikgaWIgKGNoYXJfZm9yX2hleGFkZWNpbWFsX2NvZGUgYzEgYzIpXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dF9lc2NhcGUgY1xuXG5cbigqIFNjYW4gYSBjaGFyYWN0ZXIgKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2NhbWxfY2hhciB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBmaW5kX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgY1xuXG4gIGFuZCBmaW5kX2NoYXIgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxcXCcgLT5cbiAgICAgIGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpIGliKVxuICAgIHwgYyAtPlxuICAgICAgZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9jaGFyIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXCcnIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFwnJyBjIGluXG5cbiAgZmluZF9zdGFydCB3aWR0aFxuXG5cbigqIFNjYW4gYSBkZWxpbWl0ZWQgc3RyaW5nIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiA9XG5cbiAgbGV0IHJlYyBmaW5kX3N0YXJ0IHdpZHRoID1cbiAgICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gICAgfCAnXFxcIicgLT4gZmluZF9zdG9wIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXFwiJyBjXG5cbiAgYW5kIGZpbmRfc3RvcCB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliXG4gICAgfCAnXFxcXCcgLT4gc2Nhbl9iYWNrc2xhc2ggKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgYyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYylcblxuICBhbmQgc2Nhbl9iYWNrc2xhc2ggd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXHInIC0+IHNraXBfbmV3bGluZSAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYilcblxuICBhbmQgc2tpcF9uZXdsaW5lIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxuJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiAnXFxyJylcblxuICBhbmQgc2tpcF9zcGFjZXMgd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICcgJyAtPiBza2lwX3NwYWNlcyAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBfIC0+IGZpbmRfc3RvcCB3aWR0aCBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgYm9vbGVhbiAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fYm9vbCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbGV0IG0gPVxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJ3QnIC0+IDRcbiAgICB8ICdmJyAtPiA1XG4gICAgfCBjIC0+XG4gICAgICBiYWRfaW5wdXRcbiAgICAgICAgKFByaW50Zi5zcHJpbnRmIFwidGhlIGNoYXJhY3RlciAlQyBjYW5ub3Qgc3RhcnQgYSBib29sZWFuXCIgYykgaW5cbiAgc2Nhbl9zdHJpbmcgTm9uZSBtIGliXG5cblxuKCogU2NhbiBhIHN0cmluZyBjb250YWluaW5nIGVsZW1lbnRzIGluIGNoYXJfc2V0IGFuZCB0ZXJtaW5hdGVkIGJ5IHNjYW5faW5kaWNcbiAgIGlmIHByb3ZpZGVkLiAqKVxubGV0IHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgc2Nhbl9pbmRpYyB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9jaGFycyBpIHN0cCA9XG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpID4gMCAmJiBub3QgKFNjYW5uaW5nLmVvZiBpYikgJiZcbiAgICAgICBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjICYmXG4gICAgICAgaW50X29mX2NoYXIgYyA8PiBzdHAgdGhlblxuICAgICAgbGV0IF8gPSBTY2FubmluZy5zdG9yZV9jaGFyIG1heF9pbnQgaWIgYyBpblxuICAgICAgc2Nhbl9jaGFycyAoaSAtIDEpIHN0cCBpblxuICBtYXRjaCBzY2FuX2luZGljIHdpdGhcbiAgfCBOb25lIC0+IHNjYW5fY2hhcnMgd2lkdGggKC0xKTtcbiAgfCBTb21lIGMgLT5cbiAgICBzY2FuX2NoYXJzIHdpZHRoIChpbnRfb2ZfY2hhciBjKTtcbiAgICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlblxuICAgICAgbGV0IGNpID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgICBpZiBjID0gY2lcbiAgICAgIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWJcbiAgICAgIGVsc2UgY2hhcmFjdGVyX21pc21hdGNoIGMgY2lcblxuXG4oKiBUaGUgZ2xvYmFsIGVycm9yIHJlcG9ydCBmdW5jdGlvbiBmb3IgW1NjYW5mXS4gKilcbmxldCBzY2FuZl9iYWRfaW5wdXQgaWIgPSBmdW5jdGlvblxuICB8IFNjYW5fZmFpbHVyZSBzIHwgRmFpbHVyZSBzIC0+XG4gICAgbGV0IGkgPSBTY2FubmluZy5jaGFyX2NvdW50IGliIGluXG4gICAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcInNjYW5mOiBiYWQgaW5wdXQgYXQgY2hhciBudW1iZXIgJWk6ICVzXCIgaSBzKVxuICB8IHggLT4gcmFpc2UgeFxuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiBhIGNvdW50ZXIgZnJvbSBhbiBpbnB1dCBidWZmZXIuICopXG5sZXQgZ2V0X2NvdW50ZXIgaWIgY291bnRlciA9XG4gIG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAtPiBTY2FubmluZy5saW5lX2NvdW50IGliXG4gIHwgQ2hhcl9jb3VudGVyIC0+IFNjYW5uaW5nLmNoYXJfY291bnQgaWJcbiAgfCBUb2tlbl9jb3VudGVyIC0+IFNjYW5uaW5nLnRva2VuX2NvdW50IGliXG5cblxuKCogQ29tcHV0ZSB0aGUgd2lkdGggb2YgYSBwYWRkaW5nIG9wdGlvbiAoc2VlIFwiJTQye1wiIGFuZCBcIiUxMjMoXCIpLiAqKVxubGV0IHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gbWF4X2ludFxuICB8IFNvbWUgd2lkdGggLT4gd2lkdGhcblxuXG5sZXQgc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmcgPVxuICBpZiBmbXRpbmcgPSBFc2NhcGVkX3BlcmNlbnQgdGhlbiAnJScsIFwiXCIgZWxzZVxuICAgIGxldCBzdHIgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nIGluXG4gICAgbGV0IHN0cCA9IHN0ci5bMV0gaW5cbiAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIDIgKFN0cmluZy5sZW5ndGggc3RyIC0gMikgaW5cbiAgICBzdHAsIHN1Yl9zdHJcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUmVhZGVyIG1hbmFnZW1lbnQgKilcblxuKCogQSBjYWxsIHRvIHRha2VfZm9ybWF0X3JlYWRlcnMgb24gYSBmb3JtYXQgaXMgZXZhbHVhdGVkIGludG8gZnVuY3Rpb25zXG4gICB0YWtpbmcgcmVhZGVycyBhcyBhcmd1bWVudHMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYW4gaGV0ZXJvZ2VuZW91cyBsaXN0ICopXG4oKiBXaGVuIGFsbCByZWFkZXJzIGFyZSB0YWtlbiwgZmluYWxseSBwYXNzIHRoZSBsaXN0IG9mIHRoZSByZWFkZXJzIHRvIHRoZVxuICAgY29udGludWF0aW9uIGsuICopXG5sZXQgcmVjIHRha2VfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICBkID1cbmZ1biBrIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IFJlYWRlciBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0XG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDYW1sX2NoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFN0cmluZyAoXywgcmVzdCkgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9zdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEludDMyIChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgTmF0aXZlaW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQ2NCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsb2F0IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQm9vbCAoXywgcmVzdCkgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ3VzdG9tIChfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSksIHJlc3QpIC0+XG4gICAgICB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXQgZm10IHJlc3QpXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAgICAtPlxuICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAgICAgICAtPiB0YWtlX2lnbm9yZWRfZm9ybWF0X3JlYWRlcnMgayBpZ24gcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgICAgICAgLT4gayBOaWxcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gZm10dHkgY29taW5nIGZyb20gYSBGb3JtYXRfc3Vic3QgXCIlKC4uLiUpXCIuICopXG5hbmQgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBmbXR0eSAtPlxuICAgICAgKHksIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIHgsIGUsIGYpIGZtdCAtPiBkID1cbmZ1biBrIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgUmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdCBmbXRcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQzMl90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGbG9hdF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEZvcm1hdF9hcmdfdHkgKF8sIHJlc3QpICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogVGFrZSByZWFkZXJzIGFzc29jaWF0ZWQgdG8gYW4gaWdub3JlZCBwYXJhbWV0ZXIuICopXG5hbmQgdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSB4IHkgYSBjIGQgZSBmIC5cbiAgICAoKGQsIGUpIGhldGVyX2xpc3QgLT4gZSkgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIHgsIHkpIGlnbm9yZWQgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayBmbXR0eSBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBzY2FubmluZyAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBzY2FubmluZyBmdW5jdGlvbi4gKilcbigqIFNjYW4gYSBzdHJlYW0gYWNjb3JkaW5nIHRvIGEgZm9ybWF0IGFuZCByZWFkZXJzIG9idGFpbmVkIGJ5XG4gICB0YWtlX2Zvcm1hdF9yZWFkZXJzLCBhbmQgYWdncmVnYXRlIHNjYW5uZWQgdmFsdWVzIGludG8gYW5cbiAgIGhldGVyb2dlbmVvdXMgbGlzdC4gKilcbigqIFJldHVybiB0aGUgaGV0ZXJvZ2VuZW91cyBsaXN0IG9mIHNjYW5uZWQgdmFsdWVzLiAqKVxubGV0IHJlYyBtYWtlX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoYSwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9jaGFyIDAgaWIgaW5cbiAgICBsZXQgYyA9IHRva2VuX2NoYXIgaWIgaW5cbiAgICBDb25zIChjLCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcblxuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lIHN0cCkgd2lkdGggaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9zdHJpbmcgKFNvbWUgJ3snKSB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW5cbiAgICAgICAgICAgICAgICAgICB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICdbJykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIE5vbmUgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9jYW1sX3N0cmluZyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fc3RyaW5nXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQgYylcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50MzIgYylcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX25hdGl2ZWludCBjKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9pbnQ2NCBjKVxuICB8IEZsb2F0ICgoXywgKEZsb2F0X0YgfCBGbG9hdF9DRikpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fY2FtbF9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HKSksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoXywgKEZsb2F0X2ggfCBGbG9hdF9IKSksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBmb3JtYXRfZnJvbV9zdHJpbmcgcyBmbXQgPVxuICBzc2NhbmZfZm9ybWF0IChcIlxcXCJcIiBeIFN0cmluZy5lc2NhcGVkIHMgXiBcIlxcXCJcIikgZm10IChmdW4geCAtPiB4KVxuXG5cbmxldCB1bmVzY2FwZWQgcyA9XG4gIHNzY2FuZiAoXCJcXFwiXCIgXiBzIF4gXCJcXFwiXCIpIFwiJVMlIVwiIChmdW4geCAtPiB4KVxuXG5cbigqIERlcHJlY2F0ZWQgKilcbmxldCBrZnNjYW5mIGljIGVmIGZtdCA9IGtic2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBlZiBmbXRcbmxldCBmc2NhbmYgaWMgZm10ID0ga3NjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgc2NhbmZfYmFkX2lucHV0IGZtdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBSZWdpc3RlcmluZyBPQ2FtbCB2YWx1ZXMgd2l0aCB0aGUgQyBydW50aW1lIGZvciBsYXRlciBjYWxsYmFja3MgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gT2JqLnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgcmVnaXN0ZXIgbmFtZSB2ID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSAoT2JqLnJlcHIgdilcblxubGV0IHJlZ2lzdGVyX2V4Y2VwdGlvbiBuYW1lIChleG4gOiBleG4pID1cbiAgbGV0IGV4biA9IE9iai5yZXByIGV4biBpblxuICBsZXQgc2xvdCA9IGlmIE9iai50YWcgZXhuID0gT2JqLm9iamVjdF90YWcgdGhlbiBleG4gZWxzZSBPYmouZmllbGQgZXhuIDAgaW5cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgbmFtZSBzbG90XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICBKZXJvbWUgVm91aWxsb24sIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gT2JqXG5cbigqKioqIE9iamVjdCByZXByZXNlbnRhdGlvbiAqKioqKVxuXG5leHRlcm5hbCBzZXRfaWQ6ICdhIC0+ICdhID0gXCJjYW1sX3NldF9vb19pZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIE9iamVjdCBjb3B5ICoqKiopXG5cbmxldCBjb3B5IG8gPVxuICBsZXQgbyA9IChPYmoub2JqIChPYmouZHVwIChPYmoucmVwciBvKSkpIGluXG4gIHNldF9pZCBvXG5cbigqKioqIENvbXByZXNzaW9uIG9wdGlvbnMgKioqKilcbigqIFBhcmFtZXRlcnMgKilcbnR5cGUgcGFyYW1zID0ge1xuICAgIG11dGFibGUgY29tcGFjdF90YWJsZSA6IGJvb2w7XG4gICAgbXV0YWJsZSBjb3B5X3BhcmVudCA6IGJvb2w7XG4gICAgbXV0YWJsZSBjbGVhbl93aGVuX2NvcHlpbmcgOiBib29sO1xuICAgIG11dGFibGUgcmV0cnlfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBidWNrZXRfc21hbGxfc2l6ZSA6IGludFxuICB9XG5cbmxldCBwYXJhbXMgPSB7XG4gIGNvbXBhY3RfdGFibGUgPSB0cnVlO1xuICBjb3B5X3BhcmVudCA9IHRydWU7XG4gIGNsZWFuX3doZW5fY29weWluZyA9IHRydWU7XG4gIHJldHJ5X2NvdW50ID0gMztcbiAgYnVja2V0X3NtYWxsX3NpemUgPSAxNlxufVxuXG4oKioqKiBQYXJhbWV0ZXJzICoqKiopXG5cbmxldCBpbml0aWFsX29iamVjdF9zaXplID0gMlxuXG4oKioqKiBJdGVtcyAqKioqKVxuXG50eXBlIGl0ZW0gPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbmxldCBkdW1teV9pdGVtID0gKG1hZ2ljICgpIDogaXRlbSlcblxuKCoqKiogVHlwZXMgKioqKilcblxudHlwZSB0YWdcbnR5cGUgbGFiZWwgPSBpbnRcbnR5cGUgY2xvc3VyZSA9IGl0ZW1cbnR5cGUgdCA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxudHlwZSBvYmogPSB0IGFycmF5XG5leHRlcm5hbCByZXQgOiAob2JqIC0+ICdhKSAtPiBjbG9zdXJlID0gXCIlaWRlbnRpdHlcIlxuXG4oKioqKiBMYWJlbHMgKioqKilcblxubGV0IHB1YmxpY19tZXRob2RfbGFiZWwgcyA6IHRhZyA9XG4gIGxldCBhY2N1ID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICBhY2N1IDo9IDIyMyAqICFhY2N1ICsgQ2hhci5jb2RlIHMuW2ldXG4gIGRvbmU7XG4gICgqIHJlZHVjZSB0byAzMSBiaXRzICopXG4gIGFjY3UgOj0gIWFjY3UgbGFuZCAoMSBsc2wgMzEgLSAxKTtcbiAgKCogbWFrZSBpdCBzaWduZWQgZm9yIDY0IGJpdHMgYXJjaGl0ZWN0dXJlcyAqKVxuICBsZXQgdGFnID0gaWYgIWFjY3UgPiAweDNGRkZGRkZGIHRoZW4gIWFjY3UgLSAoMSBsc2wgMzEpIGVsc2UgIWFjY3UgaW5cbiAgKCogUHJpbnRmLmVwcmludGYgXCIlcyA9ICVkXFxuXCIgcyB0YWc7IGZsdXNoIHN0ZGVycjsgKilcbiAgbWFnaWMgdGFnXG5cbigqKioqIFNwYXJzZSBhcnJheSAqKioqKVxuXG5tb2R1bGUgVmFycyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgdmFycyA9IGludCBWYXJzLnRcblxubW9kdWxlIE1ldGhzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBtZXRocyA9IGxhYmVsIE1ldGhzLnRcbm1vZHVsZSBMYWJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IGxhYmVsIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIGxhYnMgPSBib29sIExhYnMudFxuXG4oKiBUaGUgY29tcGlsZXIgYXNzdW1lcyB0aGF0IHRoZSBmaXJzdCBmaWVsZCBvZiB0aGlzIHN0cnVjdHVyZSBpcyBbc2l6ZV0uICopXG50eXBlIHRhYmxlID1cbiB7IG11dGFibGUgc2l6ZTogaW50O1xuICAgbXV0YWJsZSBtZXRob2RzOiBjbG9zdXJlIGFycmF5O1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X25hbWU6IG1ldGhzO1xuICAgbXV0YWJsZSBtZXRob2RzX2J5X2xhYmVsOiBsYWJzO1xuICAgbXV0YWJsZSBwcmV2aW91c19zdGF0ZXM6XG4gICAgIChtZXRocyAqIGxhYnMgKiAobGFiZWwgKiBpdGVtKSBsaXN0ICogdmFycyAqXG4gICAgICBsYWJlbCBsaXN0ICogc3RyaW5nIGxpc3QpIGxpc3Q7XG4gICBtdXRhYmxlIGhpZGRlbl9tZXRoczogKGxhYmVsICogaXRlbSkgbGlzdDtcbiAgIG11dGFibGUgdmFyczogdmFycztcbiAgIG11dGFibGUgaW5pdGlhbGl6ZXJzOiAob2JqIC0+IHVuaXQpIGxpc3QgfVxuXG5sZXQgZHVtbXlfdGFibGUgPVxuICB7IG1ldGhvZHMgPSBbfCBkdW1teV9pdGVtIHxdO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSAwIH1cblxubGV0IHRhYmxlX2NvdW50ID0gcmVmIDBcblxuKCogZHVtbXlfbWV0IHNob3VsZCBiZSBhIHBvaW50ZXIsIHNvIHVzZSBhbiBhdG9tICopXG5sZXQgZHVtbXlfbWV0IDogaXRlbSA9IG9iaiAoT2JqLm5ld19ibG9jayAwIDApXG4oKiBpZiBkZWJ1Z2dpbmcgaXMgbmVlZGVkLCB0aGlzIGNvdWxkIGJlIGEgZ29vZCBpZGVhOiAqKVxuKCogbGV0IGR1bW15X21ldCAoKSA9IGZhaWx3aXRoIFwiVW5kZWZpbmVkIG1ldGhvZFwiICopXG5cbmxldCByZWMgZml0X3NpemUgbiA9XG4gIGlmIG4gPD0gMiB0aGVuIG4gZWxzZVxuICBmaXRfc2l6ZSAoKG4rMSkvMikgKiAyXG5cbmxldCBuZXdfdGFibGUgcHViX2xhYmVscyA9XG4gIGluY3IgdGFibGVfY291bnQ7XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggcHViX2xhYmVscyBpblxuICBsZXQgbWV0aG9kcyA9IEFycmF5Lm1ha2UgKGxlbioyKzIpIGR1bW15X21ldCBpblxuICBtZXRob2RzLigwKSA8LSBtYWdpYyBsZW47XG4gIG1ldGhvZHMuKDEpIDwtIG1hZ2ljIChmaXRfc2l6ZSBsZW4gKiBTeXMud29yZF9zaXplIC8gOCAtIDEpO1xuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkbyBtZXRob2RzLihpKjIrMykgPC0gbWFnaWMgcHViX2xhYmVscy4oaSkgZG9uZTtcbiAgeyBtZXRob2RzID0gbWV0aG9kcztcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gaW5pdGlhbF9vYmplY3Rfc2l6ZSB9XG5cbmxldCByZXNpemUgYXJyYXkgbmV3X3NpemUgPVxuICBsZXQgb2xkX3NpemUgPSBBcnJheS5sZW5ndGggYXJyYXkubWV0aG9kcyBpblxuICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3X2J1Y2sgPSBBcnJheS5tYWtlIG5ld19zaXplIGR1bW15X21ldCBpblxuICAgIEFycmF5LmJsaXQgYXJyYXkubWV0aG9kcyAwIG5ld19idWNrIDAgb2xkX3NpemU7XG4gICAgYXJyYXkubWV0aG9kcyA8LSBuZXdfYnVja1xuIGVuZFxuXG5sZXQgcHV0IGFycmF5IGxhYmVsIGVsZW1lbnQgPVxuICByZXNpemUgYXJyYXkgKGxhYmVsICsgMSk7XG4gIGFycmF5Lm1ldGhvZHMuKGxhYmVsKSA8LSBlbGVtZW50XG5cbigqKioqIENsYXNzZXMgKioqKilcblxubGV0IG1ldGhvZF9jb3VudCA9IHJlZiAwXG5sZXQgaW5zdF92YXJfY291bnQgPSByZWYgMFxuXG4oKiB0eXBlIHQgKilcbnR5cGUgbWV0aCA9IGl0ZW1cblxubGV0IG5ld19tZXRob2QgdGFibGUgPVxuICBsZXQgaW5kZXggPSBBcnJheS5sZW5ndGggdGFibGUubWV0aG9kcyBpblxuICByZXNpemUgdGFibGUgKGluZGV4ICsgMSk7XG4gIGluZGV4XG5cbmxldCBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG5hbWUgPVxuICB0cnlcbiAgICBNZXRocy5maW5kIG5hbWUgdGFibGUubWV0aG9kc19ieV9uYW1lXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGxhYmVsID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBNZXRocy5hZGQgbmFtZSBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWJlbCB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWw7XG4gICAgbGFiZWxcblxubGV0IGdldF9tZXRob2RfbGFiZWxzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBuYW1lc1xuXG5sZXQgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBlbGVtZW50ID1cbiAgaW5jciBtZXRob2RfY291bnQ7XG4gIGlmIExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHRoZW5cbiAgICBwdXQgdGFibGUgbGFiZWwgZWxlbWVudFxuICBlbHNlXG4gICAgdGFibGUuaGlkZGVuX21ldGhzIDwtIChsYWJlbCwgZWxlbWVudCkgOjogdGFibGUuaGlkZGVuX21ldGhzXG5cbmxldCBnZXRfbWV0aG9kIHRhYmxlIGxhYmVsID1cbiAgdHJ5IExpc3QuYXNzb2MgbGFiZWwgdGFibGUuaGlkZGVuX21ldGhzXG4gIHdpdGggTm90X2ZvdW5kIC0+IHRhYmxlLm1ldGhvZHMuKGxhYmVsKVxuXG5sZXQgdG9fbGlzdCBhcnIgPVxuICBpZiBhcnIgPT0gbWFnaWMgMCB0aGVuIFtdIGVsc2UgQXJyYXkudG9fbGlzdCBhcnJcblxubGV0IG5hcnJvdyB0YWJsZSB2YXJzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgPVxuICBsZXQgdmFycyA9IHRvX2xpc3QgdmFyc1xuICBhbmQgdmlydF9tZXRocyA9IHRvX2xpc3QgdmlydF9tZXRoc1xuICBhbmQgY29uY3JfbWV0aHMgPSB0b19saXN0IGNvbmNyX21ldGhzIGluXG4gIGxldCB2aXJ0X21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSB2aXJ0X21ldGhzIGluXG4gIGxldCBjb25jcl9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgY29uY3JfbWV0aHMgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtXG4gICAgICh0YWJsZS5tZXRob2RzX2J5X25hbWUsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwsIHRhYmxlLmhpZGRlbl9tZXRocyxcbiAgICAgIHRhYmxlLnZhcnMsIHZpcnRfbWV0aF9sYWJzLCB2YXJzKVxuICAgICA6OiB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICBWYXJzLmZvbGRcbiAgICAgIChmdW4gbGFiIGluZm8gdHZhcnMgLT5cbiAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZhcnMgdGhlbiBWYXJzLmFkZCBsYWIgaW5mbyB0dmFycyBlbHNlIHR2YXJzKVxuICAgICAgdGFibGUudmFycyBWYXJzLmVtcHR5O1xuICBsZXQgYnlfbmFtZSA9IHJlZiBNZXRocy5lbXB0eSBpblxuICBsZXQgYnlfbGFiZWwgPSByZWYgTGFicy5lbXB0eSBpblxuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj1cbiAgICAgICAgICBMYWJzLmFkZCBsYWJlbFxuICAgICAgICAgICAgKHRyeSBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuICAgICAgICAgICAgIWJ5X2xhYmVsKVxuICAgIGNvbmNyX21ldGhzIGNvbmNyX21ldGhfbGFicztcbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9IExhYnMuYWRkIGxhYmVsIGZhbHNlICFieV9sYWJlbClcbiAgICB2aXJ0X21ldGhzIHZpcnRfbWV0aF9sYWJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gIWJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gIWJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhfbGFicyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBbXVxuXG5sZXQgd2lkZW4gdGFibGUgPVxuICBsZXQgKGJ5X25hbWUsIGJ5X2xhYmVsLCBzYXZlZF9oaWRkZW5fbWV0aHMsIHNhdmVkX3ZhcnMsIHZpcnRfbWV0aHMsIHZhcnMpID1cbiAgICBMaXN0LmhkIHRhYmxlLnByZXZpb3VzX3N0YXRlc1xuICBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC0gTGlzdC50bCB0YWJsZS5wcmV2aW91c19zdGF0ZXM7XG4gIHRhYmxlLnZhcnMgPC1cbiAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAoZnVuIHMgdiAtPiBWYXJzLmFkZCB2IChWYXJzLmZpbmQgdiB0YWJsZS52YXJzKSBzKVxuICAgICAgIHNhdmVkX3ZhcnMgdmFycztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIGJ5X25hbWU7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aHMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgc2F2ZWRfaGlkZGVuX21ldGhzXG5cbmxldCBuZXdfc2xvdCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IHRhYmxlLnNpemUgaW5cbiAgdGFibGUuc2l6ZSA8LSBpbmRleCArIDE7XG4gIGluZGV4XG5cbmxldCBuZXdfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IGluZGV4ID0gbmV3X3Nsb3QgdGFibGUgaW5cbiAgICBpZiBuYW1lIDw+IFwiXCIgdGhlbiB0YWJsZS52YXJzIDwtIFZhcnMuYWRkIG5hbWUgaW5kZXggdGFibGUudmFycztcbiAgICBpbmRleFxuXG5sZXQgdG9fYXJyYXkgYXJyID1cbiAgaWYgYXJyID0gT2JqLm1hZ2ljIDAgdGhlbiBbfHxdIGVsc2UgYXJyXG5cbmxldCBuZXdfbWV0aG9kc192YXJpYWJsZXMgdGFibGUgbWV0aHMgdmFscyA9XG4gIGxldCBtZXRocyA9IHRvX2FycmF5IG1ldGhzIGluXG4gIGxldCBubWV0aHMgPSBBcnJheS5sZW5ndGggbWV0aHMgYW5kIG52YWxzID0gQXJyYXkubGVuZ3RoIHZhbHMgaW5cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgKG5tZXRocyArIG52YWxzKSAwIGluXG4gIGZvciBpID0gMCB0byBubWV0aHMgLSAxIGRvXG4gICAgcmVzLihpKSA8LSBnZXRfbWV0aG9kX2xhYmVsIHRhYmxlIG1ldGhzLihpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbnZhbHMgLSAxIGRvXG4gICAgcmVzLihpK25tZXRocykgPC0gbmV3X3ZhcmlhYmxlIHRhYmxlIHZhbHMuKGkpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgZ2V0X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFycyB3aXRoIE5vdF9mb3VuZCAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGdldF92YXJpYWJsZXMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF92YXJpYWJsZSB0YWJsZSkgbmFtZXNcblxubGV0IGFkZF9pbml0aWFsaXplciB0YWJsZSBmID1cbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIGY6OnRhYmxlLmluaXRpYWxpemVyc1xuXG4oKlxubW9kdWxlIEtleXMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gdGFnIGFycmF5IGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG5sZXQga2V5X21hcCA9IHJlZiBLZXlzLmVtcHR5XG5sZXQgZ2V0X2tleSB0YWdzIDogaXRlbSA9XG4gIHRyeSBtYWdpYyAoS2V5cy5maW5kIHRhZ3MgIWtleV9tYXAgOiB0YWcgYXJyYXkpXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAga2V5X21hcCA6PSBLZXlzLmFkZCB0YWdzIHRhZ3MgIWtleV9tYXA7XG4gICAgbWFnaWMgdGFnc1xuKilcblxubGV0IGNyZWF0ZV90YWJsZSBwdWJsaWNfbWV0aG9kcyA9XG4gIGlmIHB1YmxpY19tZXRob2RzID09IG1hZ2ljIDAgdGhlbiBuZXdfdGFibGUgW3x8XSBlbHNlXG4gICgqIFtwdWJsaWNfbWV0aG9kc10gbXVzdCBiZSBpbiBhc2NlbmRpbmcgb3JkZXIgZm9yIGJ5dGVjb2RlICopXG4gIGxldCB0YWdzID0gQXJyYXkubWFwIHB1YmxpY19tZXRob2RfbGFiZWwgcHVibGljX21ldGhvZHMgaW5cbiAgbGV0IHRhYmxlID0gbmV3X3RhYmxlIHRhZ3MgaW5cbiAgQXJyYXkuaXRlcmlcbiAgICAoZnVuIGkgbWV0IC0+XG4gICAgICBsZXQgbGFiID0gaSoyKzIgaW5cbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSAgPC0gTWV0aHMuYWRkIG1ldCBsYWIgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgICAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBMYWJzLmFkZCBsYWIgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsKVxuICAgIHB1YmxpY19tZXRob2RzO1xuICB0YWJsZVxuXG5sZXQgaW5pdF9jbGFzcyB0YWJsZSA9XG4gIGluc3RfdmFyX2NvdW50IDo9ICFpbnN0X3Zhcl9jb3VudCArIHRhYmxlLnNpemUgLSAxO1xuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gTGlzdC5yZXYgdGFibGUuaW5pdGlhbGl6ZXJzO1xuICByZXNpemUgdGFibGUgKDMgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZSlcblxubGV0IGluaGVyaXRzIGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHMgKF8sIHN1cGVyLCBfLCBlbnYpIHRvcCA9XG4gIG5hcnJvdyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzO1xuICBsZXQgaW5pdCA9XG4gICAgaWYgdG9wIHRoZW4gc3VwZXIgY2xhIGVudiBlbHNlIE9iai5yZXByIChzdXBlciBjbGEpIGluXG4gIHdpZGVuIGNsYTtcbiAgQXJyYXkuY29uY2F0XG4gICAgW1t8IHJlcHIgaW5pdCB8XTtcbiAgICAgbWFnaWMgKEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIGNsYSkgKHRvX2FycmF5IHZhbHMpIDogaW50IGFycmF5KTtcbiAgICAgQXJyYXkubWFwXG4gICAgICAgKGZ1biBubSAtPiByZXByIChnZXRfbWV0aG9kIGNsYSAoZ2V0X21ldGhvZF9sYWJlbCBjbGEgbm0pIDogY2xvc3VyZSkpXG4gICAgICAgKHRvX2FycmF5IGNvbmNyX21ldGhzKSBdXG5cbmxldCBtYWtlX2NsYXNzIHB1Yl9tZXRocyBjbGFzc19pbml0ID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIChlbnZfaW5pdCAoT2JqLnJlcHIgMCksIGNsYXNzX2luaXQsIGVudl9pbml0LCBPYmoucmVwciAwKVxuXG50eXBlIGluaXRfdGFibGUgPSB7IG11dGFibGUgZW52X2luaXQ6IHQ7IG11dGFibGUgY2xhc3NfaW5pdDogdGFibGUgLT4gdCB9XG5cbmxldCBtYWtlX2NsYXNzX3N0b3JlIHB1Yl9tZXRocyBjbGFzc19pbml0IGluaXRfdGFibGUgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgaW5pdF90YWJsZS5jbGFzc19pbml0IDwtIGNsYXNzX2luaXQ7XG4gIGluaXRfdGFibGUuZW52X2luaXQgPC0gZW52X2luaXRcblxubGV0IGR1bW15X2NsYXNzIGxvYyA9XG4gIGxldCB1bmRlZiA9IGZ1biBfIC0+IHJhaXNlIChVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSBsb2MpIGluXG4gIChPYmoubWFnaWMgdW5kZWYsIHVuZGVmLCB1bmRlZiwgT2JqLnJlcHIgMClcblxuKCoqKiogT2JqZWN0cyAqKioqKVxuXG5sZXQgY3JlYXRlX29iamVjdCB0YWJsZSA9XG4gICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gIE9iai5vYmogKHNldF9pZCBvYmopXG5cbmxldCBjcmVhdGVfb2JqZWN0X29wdCBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICAgIGxldCBvYmogPSBPYmoubmV3X2Jsb2NrIE9iai5vYmplY3RfdGFnIHRhYmxlLnNpemUgaW5cbiAgICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICAgIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICAgIE9iai5vYmogKHNldF9pZCBvYmopXG4gIGVuZFxuXG5sZXQgcmVjIGl0ZXJfZiBvYmogPVxuICBmdW5jdGlvblxuICAgIFtdICAgLT4gKClcbiAgfCBmOjpsIC0+IGYgb2JqOyBpdGVyX2Ygb2JqIGxcblxubGV0IHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlID1cbiAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gIGlmIGluaXRzIDw+IFtdIHRoZW5cbiAgICBpdGVyX2Ygb2JqIGluaXRzXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzX29wdCBvYmpfMCBvYmogdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmogZWxzZSBiZWdpblxuICAgIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICAgIGlmIGluaXRzIDw+IFtdIHRoZW4gaXRlcl9mIG9iaiBpbml0cztcbiAgICBvYmpcbiAgZW5kXG5cbmxldCBjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGl6ZXJzIG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgIGxldCBvYmogPSBjcmVhdGVfb2JqZWN0IHRhYmxlIGluXG4gICAgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGU7XG4gICAgb2JqXG4gIGVuZFxuXG4oKiBFcXVpdmFsZW50IHByaW1pdGl2ZSBiZWxvd1xubGV0IHNlbmRzZWxmIG9iaiBsYWIgPVxuICAobWFnaWMgb2JqIDogKG9iaiAtPiB0KSBhcnJheSBhcnJheSkuKDApLihsYWIpIG9ialxuKilcbmV4dGVybmFsIHNlbmQgOiBvYmogLT4gdGFnIC0+ICdhID0gXCIlc2VuZFwiXG5leHRlcm5hbCBzZW5kY2FjaGUgOiBvYmogLT4gdGFnIC0+IHQgLT4gaW50IC0+ICdhID0gXCIlc2VuZGNhY2hlXCJcbmV4dGVybmFsIHNlbmRzZWxmIDogb2JqIC0+IGxhYmVsIC0+ICdhID0gXCIlc2VuZHNlbGZcIlxuZXh0ZXJuYWwgZ2V0X3B1YmxpY19tZXRob2QgOiBvYmogLT4gdGFnIC0+IGNsb3N1cmVcbiAgICA9IFwiY2FtbF9nZXRfcHVibGljX21ldGhvZFwiIFtAQG5vYWxsb2NdXG5cbigqKioqIHRhYmxlIGNvbGxlY3Rpb24gYWNjZXNzICoqKiopXG5cbnR5cGUgdGFibGVzID1cbiAgfCBFbXB0eVxuICB8IENvbnMgb2Yge2tleSA6IGNsb3N1cmU7IG11dGFibGUgZGF0YTogdGFibGVzOyBtdXRhYmxlIG5leHQ6IHRhYmxlc31cblxubGV0IHNldF9kYXRhIHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YSA8LSB2XG5sZXQgc2V0X25leHQgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0IDwtIHZcbmxldCBnZXRfa2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMua2V5XG5sZXQgZ2V0X2RhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhXG5sZXQgZ2V0X25leHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5uZXh0XG5cbmxldCBidWlsZF9wYXRoIG4ga2V5cyB0YWJsZXMgPVxuICBsZXQgcmVzID0gQ29ucyB7a2V5ID0gT2JqLm1hZ2ljIDA7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICBsZXQgciA9IHJlZiByZXMgaW5cbiAgZm9yIGkgPSAwIHRvIG4gZG9cbiAgICByIDo9IENvbnMge2tleSA9IGtleXMuKGkpOyBkYXRhID0gIXI7IG5leHQgPSBFbXB0eX1cbiAgZG9uZTtcbiAgc2V0X2RhdGEgdGFibGVzICFyO1xuICByZXNcblxubGV0IHJlYyBsb29rdXBfa2V5cyBpIGtleXMgdGFibGVzID1cbiAgaWYgaSA8IDAgdGhlbiB0YWJsZXMgZWxzZVxuICBsZXQga2V5ID0ga2V5cy4oaSkgaW5cbiAgbGV0IHJlYyBsb29rdXBfa2V5ICh0YWJsZXM6dGFibGVzKSA9XG4gICAgaWYgZ2V0X2tleSB0YWJsZXMgPT0ga2V5IHRoZW5cbiAgICAgIG1hdGNoIGdldF9kYXRhIHRhYmxlcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBDb25zIF8gYXMgdGFibGVzX2RhdGEgLT5cbiAgICAgICAgICBsb29rdXBfa2V5cyAoaS0xKSBrZXlzIHRhYmxlc19kYXRhXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZ2V0X25leHQgdGFibGVzIHdpdGhcbiAgICAgIHwgQ29ucyBfIGFzIG5leHQgLT4gbG9va3VwX2tleSBuZXh0XG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgbGV0IG5leHQgOiB0YWJsZXMgPSBDb25zIHtrZXk7IGRhdGEgPSBFbXB0eTsgbmV4dCA9IEVtcHR5fSBpblxuICAgICAgICAgIHNldF9uZXh0IHRhYmxlcyBuZXh0O1xuICAgICAgICAgIGJ1aWxkX3BhdGggKGktMSkga2V5cyBuZXh0XG4gIGluXG4gIGxvb2t1cF9rZXkgdGFibGVzXG5cbmxldCBsb29rdXBfdGFibGVzIHJvb3Qga2V5cyA9XG4gIG1hdGNoIGdldF9kYXRhIHJvb3Qgd2l0aFxuICB8IENvbnMgXyBhcyByb290X2RhdGEgLT5cbiAgICBsb29rdXBfa2V5cyAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RfZGF0YVxuICB8IEVtcHR5IC0+XG4gICAgYnVpbGRfcGF0aCAoQXJyYXkubGVuZ3RoIGtleXMgLSAxKSBrZXlzIHJvb3RcblxuKCoqKiogYnVpbHRpbiBtZXRob2RzICoqKiopXG5cbmxldCBnZXRfY29uc3QgeCA9IHJldCAoZnVuIF9vYmogLT4geClcbmxldCBnZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiAtPiBBcnJheS51bnNhZmVfZ2V0IG9iaiBuKVxubGV0IGdldF9lbnYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbilcbmxldCBnZXRfbWV0aCBuICA9IHJldCAoZnVuIG9iaiAtPiBzZW5kc2VsZiBvYmogbilcbmxldCBzZXRfdmFyIG4gICA9IHJldCAoZnVuIG9iaiB4IC0+IEFycmF5LnVuc2FmZV9zZXQgb2JqIG4geClcbmxldCBhcHBfY29uc3QgZiB4ID0gcmV0IChmdW4gX29iaiAtPiBmIHgpXG5sZXQgYXBwX3ZhciBmIG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfZW52IGYgZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX21ldGggZiBuICA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX2NvbnN0X2NvbnN0IGYgeCB5ID0gcmV0IChmdW4gX29iaiAtPiBmIHggeSlcbmxldCBhcHBfY29uc3RfdmFyIGYgeCBuICAgPSByZXQgKGZ1biBvYmogLT4gZiB4IChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSlcbmxldCBhcHBfY29uc3RfbWV0aCBmIHggbiA9IHJldCAoZnVuIG9iaiAtPiBmIHggKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfdmFyX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIHgpXG5sZXQgYXBwX21ldGhfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pIHgpXG5sZXQgYXBwX2NvbnN0X2VudiBmIHggZSBuID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiB4IChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfZW52X2NvbnN0IGYgZSBuIHggPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSB4KVxubGV0IG1ldGhfYXBwX2NvbnN0IG4geCA9IHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIHgpXG5sZXQgbWV0aF9hcHBfdmFyIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChBcnJheS51bnNhZmVfZ2V0IG9iaiBtKSlcbmxldCBtZXRoX2FwcF9lbnYgbiBlIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG0pKVxubGV0IG1ldGhfYXBwX21ldGggbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKHNlbmRzZWxmIG9iaiBtKSlcbmxldCBzZW5kX2NvbnN0IG0geCBjID1cbiAgcmV0IChmdW4gb2JqIC0+IHNlbmRjYWNoZSB4IG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF92YXIgbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgOiBvYmopIG1cbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfZW52IG0gZSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGVcbiAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXRcbiAgICAgICAgICAgICAgICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIDogb2JqKVxuICAgICAgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX21ldGggbSBuIGMgPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBzZW5kY2FjaGUgKHNlbmRzZWxmIG9iaiBuKSBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IG5ld19jYWNoZSB0YWJsZSA9XG4gIGxldCBuID0gbmV3X21ldGhvZCB0YWJsZSBpblxuICBsZXQgbiA9XG4gICAgaWYgbiBtb2QgMiA9IDAgfHwgbiA+IDIgKyBtYWdpYyB0YWJsZS5tZXRob2RzLigxKSAqIDE2IC8gU3lzLndvcmRfc2l6ZVxuICAgIHRoZW4gbiBlbHNlIG5ld19tZXRob2QgdGFibGVcbiAgaW5cbiAgdGFibGUubWV0aG9kcy4obikgPC0gT2JqLm1hZ2ljIDA7XG4gIG5cblxudHlwZSBpbXBsID1cbiAgICBHZXRDb25zdFxuICB8IEdldFZhclxuICB8IEdldEVudlxuICB8IEdldE1ldGhcbiAgfCBTZXRWYXJcbiAgfCBBcHBDb25zdFxuICB8IEFwcFZhclxuICB8IEFwcEVudlxuICB8IEFwcE1ldGhcbiAgfCBBcHBDb25zdENvbnN0XG4gIHwgQXBwQ29uc3RWYXJcbiAgfCBBcHBDb25zdEVudlxuICB8IEFwcENvbnN0TWV0aFxuICB8IEFwcFZhckNvbnN0XG4gIHwgQXBwRW52Q29uc3RcbiAgfCBBcHBNZXRoQ29uc3RcbiAgfCBNZXRoQXBwQ29uc3RcbiAgfCBNZXRoQXBwVmFyXG4gIHwgTWV0aEFwcEVudlxuICB8IE1ldGhBcHBNZXRoXG4gIHwgU2VuZENvbnN0XG4gIHwgU2VuZFZhclxuICB8IFNlbmRFbnZcbiAgfCBTZW5kTWV0aFxuICB8IENsb3N1cmUgb2YgY2xvc3VyZVxuXG5sZXQgbWV0aG9kX2ltcGwgdGFibGUgaSBhcnIgPVxuICBsZXQgbmV4dCAoKSA9IGluY3IgaTsgbWFnaWMgYXJyLighaSkgaW5cbiAgbWF0Y2ggbmV4dCgpIHdpdGhcbiAgICBHZXRDb25zdCAtPiBsZXQgeCA6IHQgPSBuZXh0KCkgaW4gZ2V0X2NvbnN0IHhcbiAgfCBHZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfdmFyIG5cbiAgfCBHZXRFbnYgICAtPiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfZW52IGUgblxuICB8IEdldE1ldGggIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF9tZXRoIG5cbiAgfCBTZXRWYXIgICAtPiBsZXQgbiA9IG5leHQoKSBpbiBzZXRfdmFyIG5cbiAgfCBBcHBDb25zdCAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBhcHBfY29uc3QgZiB4XG4gIHwgQXBwVmFyICAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF92YXIgZiBuXG4gIHwgQXBwRW52ICAgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluICBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2VudiBmIGUgblxuICB8IEFwcE1ldGggIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfbWV0aCBmIG5cbiAgfCBBcHBDb25zdENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgeSA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2NvbnN0IGYgeCB5XG4gIHwgQXBwQ29uc3RWYXIgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfdmFyIGYgeCBuXG4gIHwgQXBwQ29uc3RFbnYgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X2VudiBmIHggZSBuXG4gIHwgQXBwQ29uc3RNZXRoIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X21ldGggZiB4IG5cbiAgfCBBcHBWYXJDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF92YXJfY29uc3QgZiBuIHhcbiAgfCBBcHBFbnZDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52X2NvbnN0IGYgZSBuIHhcbiAgfCBBcHBNZXRoQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfbWV0aF9jb25zdCBmIG4geFxuICB8IE1ldGhBcHBDb25zdCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbWV0aF9hcHBfY29uc3QgbiB4XG4gIHwgTWV0aEFwcFZhciAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfdmFyIG4gbVxuICB8IE1ldGhBcHBFbnYgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluXG4gICAgICBtZXRoX2FwcF9lbnYgbiBlIG1cbiAgfCBNZXRoQXBwTWV0aCAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW4gbWV0aF9hcHBfbWV0aCBuIG1cbiAgfCBTZW5kQ29uc3QgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIHNlbmRfY29uc3QgbSB4IChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZFZhciAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfdmFyIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRFbnYgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBzZW5kX2VudiBtIGUgbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRNZXRoIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF9tZXRoIG0gbiAobmV3X2NhY2hlIHRhYmxlKVxuICB8IENsb3N1cmUgXyBhcyBjbG8gLT4gbWFnaWMgY2xvXG5cbmxldCBzZXRfbWV0aG9kcyB0YWJsZSBtZXRob2RzID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBtZXRob2RzIGluIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gZG9cbiAgICBsZXQgbGFiZWwgPSBtZXRob2RzLighaSkgaW4gbGV0IGNsbyA9IG1ldGhvZF9pbXBsIHRhYmxlIGkgbWV0aG9kcyBpblxuICAgIHNldF9tZXRob2QgdGFibGUgbGFiZWwgY2xvO1xuICAgIGluY3IgaVxuICBkb25lXG5cbigqKioqIFN0YXRpc3RpY3MgKioqKilcblxudHlwZSBzdGF0cyA9XG4gIHsgY2xhc3NlczogaW50OyBtZXRob2RzOiBpbnQ7IGluc3RfdmFyczogaW50OyB9XG5cbmxldCBzdGF0cyAoKSA9XG4gIHsgY2xhc3NlcyA9ICF0YWJsZV9jb3VudDtcbiAgICBtZXRob2RzID0gIW1ldGhvZF9jb3VudDsgaW5zdF92YXJzID0gIWluc3RfdmFyX2NvdW50OyB9XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdG9rZW4gPVxuICAgIEt3ZCBvZiBzdHJpbmdcbiAgfCBJZGVudCBvZiBzdHJpbmdcbiAgfCBJbnQgb2YgaW50XG4gIHwgRmxvYXQgb2YgZmxvYXRcbiAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gIHwgQ2hhciBvZiBjaGFyXG5cbigqIFRoZSBzdHJpbmcgYnVmZmVyaW5nIG1hY2hpbmVyeSAqKVxuXG5sZXQgaW5pdGlhbF9idWZmZXIgPSBCeXRlcy5jcmVhdGUgMzJcblxubGV0IGJ1ZmZlciA9IHJlZiBpbml0aWFsX2J1ZmZlclxubGV0IGJ1ZnBvcyA9IHJlZiAwXG5cbmxldCByZXNldF9idWZmZXIgKCkgPSBidWZmZXIgOj0gaW5pdGlhbF9idWZmZXI7IGJ1ZnBvcyA6PSAwXG5cbmxldCBzdG9yZSBjID1cbiAgaWYgIWJ1ZnBvcyA+PSBCeXRlcy5sZW5ndGggIWJ1ZmZlciB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAoMiAqICFidWZwb3MpIGluXG4gICAgQnl0ZXMuYmxpdCAhYnVmZmVyIDAgbmV3YnVmZmVyIDAgIWJ1ZnBvcztcbiAgICBidWZmZXIgOj0gbmV3YnVmZmVyXG4gIGVuZDtcbiAgQnl0ZXMuc2V0ICFidWZmZXIgIWJ1ZnBvcyBjO1xuICBpbmNyIGJ1ZnBvc1xuXG5sZXQgZ2V0X3N0cmluZyAoKSA9XG4gIGxldCBzID0gQnl0ZXMuc3ViX3N0cmluZyAhYnVmZmVyIDAgIWJ1ZnBvcyBpbiBidWZmZXIgOj0gaW5pdGlhbF9idWZmZXI7IHNcblxuKCogVGhlIGxleGVyICopXG5cbmxldCBtYWtlX2xleGVyIGtleXdvcmRzID1cbiAgbGV0IGt3ZF90YWJsZSA9IEhhc2h0YmwuY3JlYXRlIDE3IGluXG4gIExpc3QuaXRlciAoZnVuIHMgLT4gSGFzaHRibC5hZGQga3dkX3RhYmxlIHMgKEt3ZCBzKSkga2V5d29yZHM7XG4gIGxldCBpZGVudF9vcl9rZXl3b3JkIGlkID1cbiAgICB0cnkgSGFzaHRibC5maW5kIGt3ZF90YWJsZSBpZCB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gSWRlbnQgaWRcbiAgYW5kIGtleXdvcmRfb3JfZXJyb3IgYyA9XG4gICAgbGV0IHMgPSBTdHJpbmcubWFrZSAxIGMgaW5cbiAgICB0cnkgSGFzaHRibC5maW5kIGt3ZF90YWJsZSBzIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RyZWFtLkVycm9yIChcIklsbGVnYWwgY2hhcmFjdGVyIFwiIF4gcykpXG4gIGluXG4gIGxldCByZWMgbmV4dF90b2tlbiAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnICcgfCAnXFwwMTAnIHwgJ1xcMDEzJyB8ICdcXDAwOScgfCAnXFwwMjYnIHwgJ1xcMDEyJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBuZXh0X3Rva2VuIHN0cm1fX1xuICAgIHwgU29tZSAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICdfJyB8ICdcXDE5MicuLidcXDI1NScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8ICc+JyB8XG4gICAgICAgICAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IFNvbWUgJ1xcJycgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgYyA9XG4gICAgICAgICAgdHJ5IGNoYXIgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICdcXCcnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoQ2hhciBjKVxuICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgJ1xcXCInIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBTb21lIChTdHJpbmcgKHN0cmluZyBzKSlcbiAgICB8IFNvbWUgJy0nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbmVnX251bWJlciBzdHJtX19cbiAgICB8IFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgYylcbiAgICB8IF8gLT4gTm9uZVxuICBhbmQgaWRlbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJ0EnLi4nWicgfCAnYScuLid6JyB8ICdcXDE5MicuLidcXDI1NScgfCAnMCcuLic5JyB8ICdfJyB8ICdcXCcnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIGlkZW50MiAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLScgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfFxuICAgICAgICAgJz4nIHwgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBuZWdfbnVtYmVyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBfIC0+IGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBpZGVudDIgc1xuICBhbmQgbnVtYmVyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IFNvbWUgJy4nIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJy4nOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEludCAoaW50X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZGVjaW1hbF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBleHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcrJyB8ICctJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGVuZF9leHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gZW5kX2V4cG9uZW50X3BhcnQgc3RybV9fXG4gIGFuZCBlbmRfZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGVuZF9leHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgc3RyaW5nIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXCInIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgZ2V0X3N0cmluZyAoKVxuICAgIHwgU29tZSAnXFxcXCcgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgYyA9XG4gICAgICAgICAgdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIGNoYXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcXCcgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBiZWdpbiB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIGVzY2FwZSAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICduJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXG4nXG4gICAgfCBTb21lICdyJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXHInXG4gICAgfCBTb21lICd0JyAtPiBTdHJlYW0uanVuayBzdHJtX187ICdcXHQnXG4gICAgfCBTb21lICgnMCcuLic5JyBhcyBjMSkgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMyKSAtPlxuICAgICAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzMpIC0+XG4gICAgICAgICAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICAgICAgICAgIENoYXIuY2hyXG4gICAgICAgICAgICAgICAgICAoKENoYXIuY29kZSBjMSAtIDQ4KSAqIDEwMCArIChDaGFyLmNvZGUgYzIgLSA0OCkgKiAxMCArXG4gICAgICAgICAgICAgICAgICAgICAoQ2hhci5jb2RlIGMzIC0gNDgpKVxuICAgICAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBlbmRcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNcbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBjb21tZW50IHM7IG5leHRfdG9rZW4gc1xuICAgIHwgXyAtPiBTb21lIChrZXl3b3JkX29yX2Vycm9yICcoJylcbiAgYW5kIGNvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9uZXN0ZWRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfZW5kX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfbmVzdGVkX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBjb21tZW50IHM7IGNvbW1lbnQgc1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX2VuZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyknIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgKClcbiAgICB8IFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfZW5kX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBpblxuICBmdW4gaW5wdXQgLT4gU3RyZWFtLmZyb20gKGZ1biBfY291bnQgLT4gbmV4dF90b2tlbiBpbnB1dClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9IHNpZ1xuICBpbmNsdWRlIEhhc2h0YmwuU2VlZGVkU1xuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICBpbmNsdWRlIEhhc2h0YmwuU1xuICB2YWwgY2xlYW46ICdhIHQgLT4gdW5pdFxuICB2YWwgc3RhdHNfYWxpdmU6ICdhIHQgLT4gSGFzaHRibC5zdGF0aXN0aWNzXG4gICAgKCoqIHNhbWUgYXMgeyFzdGF0c30gYnV0IG9ubHkgY291bnQgdGhlIGFsaXZlIGJpbmRpbmdzICopXG5lbmRcblxubW9kdWxlIEdlbkhhc2hUYWJsZSA9IHN0cnVjdFxuXG4gIHR5cGUgZXF1YWwgPVxuICB8IEVUcnVlIHwgRUZhbHNlXG4gIHwgRURlYWQgKCoqIHRoZSBnYXJiYWdlIGNvbGxlY3RvciByZWNsYWltZWQgdGhlIGRhdGEgKilcblxuICBtb2R1bGUgTWFrZVNlZWRlZChIOiBzaWdcbiAgICB0eXBlIHRcbiAgICB0eXBlICdhIGNvbnRhaW5lclxuICAgIHZhbCBjcmVhdGU6IHQgLT4gJ2EgLT4gJ2EgY29udGFpbmVyXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogJ2EgY29udGFpbmVyIC0+IHQgLT4gZXF1YWxcbiAgICB2YWwgZ2V0X2RhdGE6ICdhIGNvbnRhaW5lciAtPiAnYSBvcHRpb25cbiAgICB2YWwgZ2V0X2tleTogJ2EgY29udGFpbmVyIC0+IHQgb3B0aW9uXG4gICAgdmFsIHNldF9rZXlfZGF0YTogJ2EgY29udGFpbmVyIC0+IHQgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBjaGVja19rZXk6ICdhIGNvbnRhaW5lciAtPiBib29sXG4gIGVuZCkgOiBTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnRcbiAgPSBzdHJ1Y3RcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgICAgIG11dGFibGUgZGF0YTogJ2EgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgICAgIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICAgICAgfVxuXG4gICAgYW5kICdhIGJ1Y2tldGxpc3QgPVxuICAgIHwgRW1wdHlcbiAgICB8IENvbnMgb2YgaW50ICgqIGhhc2ggb2YgdGhlIGtleSAqKSAqICdhIEguY29udGFpbmVyICogJ2EgYnVja2V0bGlzdFxuXG4gICAgKCoqIHRoZSBoYXNoIG9mIHRoZSBrZXkgaXMga2VwdCBpbiBvcmRlciB0byB0ZXN0IHRoZSBlcXVhbGl0eSBvZiB0aGUgaGFzaFxuICAgICAgYmVmb3JlIHRoZSBrZXkuIFNhbWUgcmVhc29uIGFzIGZvciBXZWFrLk1ha2UgKilcblxuICAgIHR5cGUga2V5ID0gSC50XG5cbiAgICBsZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgICAgIGlmIHggPj0gbiB0aGVuIHhcbiAgICAgIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgICAgIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxuICAgIGxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbiAgICBsZXQgY3JlYXRlID8ocmFuZG9tID0gKEhhc2h0YmwuaXNfcmFuZG9taXplZCAoKSkpIGluaXRpYWxfc2l6ZSA9XG4gICAgICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gICAgICBsZXQgc2VlZCA9IGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpIGVsc2UgMCBpblxuICAgICAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG4gICAgbGV0IGNsZWFyIGggPVxuICAgICAgaC5zaXplIDwtIDA7XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgZG9uZVxuXG4gICAgbGV0IHJlc2V0IGggPVxuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGlmIGxlbiA9IGguaW5pdGlhbF9zaXplIHRoZW5cbiAgICAgICAgY2xlYXIgaFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBoLnNpemUgPC0gMDtcbiAgICAgICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgaC5pbml0aWFsX3NpemUgRW1wdHlcbiAgICAgIGVuZFxuXG4gICAgbGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5jb3B5IGguZGF0YSB9XG5cbiAgICBsZXQga2V5X2luZGV4IGggaGtleSA9XG4gICAgICBoa2V5IGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGNsZWFuIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBub3QgKEguY2hlY2tfa2V5IGMpIC0+XG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgIHwgQ29ucyhoa2V5LCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgQ29ucyhoa2V5LCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgICgqKiByZXNpemUgaXMgdGhlIG9ubHkgZnVuY3Rpb24gdG8gZG8gdGhlIGFjdHVhbCBjbGVhbmluZyBvZiBkZWFkIGtleXNcbiAgICAgICAgKHJlbW92ZSBkb2VzIGl0IGp1c3QgYmVjYXVzZSBpdCBjb3VsZCkuXG5cbiAgICAgICAgVGhlIGdvYWwgaXMgdG86XG5cbiAgICAgICAgLSBub3QgcmVzaXplIGluZmluaXRlbHkgd2hlbiB0aGUgYWN0dWFsIG51bWJlciBvZiBhbGl2ZSBrZXlzIGlzXG4gICAgICAgIGJvdW5kZWQgYnV0IGtleXMgYXJlIGNvbnRpbnVvdXNseSBhZGRlZC4gVGhhdCB3b3VsZCBoYXBwZW4gaWZcbiAgICAgICAgdGhpcyBmdW5jdGlvbiBhbHdheXMgcmVzaXplLlxuICAgICAgICAtIG5vdCBjYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgZWFjaCBhZGRpdGlvbiwgdGhhdCB3b3VsZCBoYXBwZW4gaWYgdGhpc1xuICAgICAgICBmdW5jdGlvbiBkb24ndCByZXNpemUgZXZlbiB3aGVuIG9ubHkgb25lIGtleSBpcyBkZWFkLlxuXG4gICAgICAgIFNvIHRoZSBhbGdvcml0aG06XG4gICAgICAgIC0gY2xlYW4gdGhlIGtleXMgYmVmb3JlIHJlc2l6aW5nXG4gICAgICAgIC0gaWYgdGhlIG51bWJlciBvZiByZW1haW5pbmcga2V5cyBpcyBsZXNzIHRoYW4gaGFsZiB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgICAgYXJyYXksIGRvbid0IHJlc2l6ZS5cbiAgICAgICAgLSBpZiBpdCBpcyBtb3JlLCByZXNpemUuXG5cbiAgICAgICAgVGhlIHNlY29uZCBwcm9ibGVtIHJlbWFpbnMgaWYgdGhlIHRhYmxlIHJlYWNoZXMgeyFTeXMubWF4X2FycmF5X2xlbmd0aH0uXG5cbiAgICAqKVxuICAgIGxldCByZXNpemUgaCA9XG4gICAgICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICAgICAgbGV0IG5zaXplID0gb3NpemUgKiAyIGluXG4gICAgICBjbGVhbiBoO1xuICAgICAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCAmJiBoLnNpemUgPj0gb3NpemUgbHNyIDEgdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgKCogc28gdGhhdCBrZXlfaW5kZXggc2VlcyB0aGUgbmV3IGJ1Y2tldCBjb3VudCAqKVxuICAgICAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgICAgICB8IENvbnMoaGtleSwgZGF0YSwgcmVzdCkgLT5cbiAgICAgICAgICAgICAgaW5zZXJ0X2J1Y2tldCByZXN0OyAoKiBwcmVzZXJ2ZSBvcmlnaW5hbCBvcmRlciBvZiBlbGVtZW50cyAqKVxuICAgICAgICAgICAgICBsZXQgbmlkeCA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgICAgICAgICAgbmRhdGEuKG5pZHgpIDwtIENvbnMoaGtleSwgZGF0YSwgbmRhdGEuKG5pZHgpKSBpblxuICAgICAgICBmb3IgaSA9IDAgdG8gb3NpemUgLSAxIGRvXG4gICAgICAgICAgaW5zZXJ0X2J1Y2tldCBvZGF0YS4oaSlcbiAgICAgICAgZG9uZVxuICAgICAgZW5kXG5cbiAgICBsZXQgYWRkIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25zKGhrZXksIGNvbnRhaW5lciwgaC5kYXRhLihpKSkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZW1vdmVfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gaC5zaXplIDwtIGguc2l6ZSAtIDE7IG5leHRcbiAgICAgICAgICAgIHwgRUZhbHNlIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dClcbiAgICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgICAoKiBUaGUgZGVhZCBrZXkgaXMgYXV0b21hdGljYWxseSByZW1vdmVkLiBJdCBpcyBhY2NlcHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIGZvciB0aGlzIGZ1bmN0aW9uIHNpbmNlIGl0IGFscmVhZHkgcmVtb3ZlcyBhIGJpbmRpbmcgKilcbiAgICAgICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICByZW1vdmVfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoaGssYyxuZXh0KSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gcmVtb3ZlX2J1Y2tldCBoLmRhdGEuKGkpXG5cbiAgICAoKiogeyFmaW5kfSBkb24ndCByZW1vdmUgZGVhZCBrZXlzIGJlY2F1c2UgaXQgd291bGQgYmUgc3VycHJpc2luZyBmb3JcbiAgICAgICAgdGhlIHVzZXIgdGhhdCBhIHJlYWQtb25seSBmdW5jdGlvbiBtdXRhdGVzIHRoZSBzdGF0ZSAoZWcuIGNvbmN1cnJlbnRcbiAgICAgICAgYWNjZXNzKS4gU2FtZSBmb3IgeyFpdGVyfSwgeyFmb2xkfSwgeyFtZW19LlxuICAgICopXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWMga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgaGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgKGguZGF0YS4oa2V5X2luZGV4IGggaGtleSkpXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IFtdXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGQ6OmZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPlxuICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IEguc2V0X2tleV9kYXRhIGMga2V5IGluZm9cbiAgICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhfLF8sbmV4dCkgLT4gcmVwbGFjZV9idWNrZXQgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICB0cnlcbiAgICAgICAgcmVwbGFjZV9idWNrZXQgbFxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29ucyhoa2V5LCBjb250YWluZXIsIGwpO1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoayA9IGhrZXkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IHRydWVcbiAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IG1lbV9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF9oaywgX2MsIHJlc3QpIC0+IG1lbV9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cbiAgICBsZXQgaXRlciBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICAoKVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiAoKVxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZFxuICAgICAgICAgICAgZW5kOyBkb19idWNrZXQgcmVzdCBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgZm9sZCBmIGggaW5pdCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgICAgICBtYXRjaCBiIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICAgYWNjdVxuICAgICAgICB8IENvbnMoXywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIGxldCBhY2N1ID0gYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYWNjdVxuICAgICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkIGFjY3VcbiAgICAgICAgICAgIGVuZCBpblxuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3QgYWNjdSAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBsZXQgYWNjdSA9IHJlZiBpbml0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgICBkb25lO1xuICAgICAgIWFjY3VcblxuICAgIGxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+XG4gICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT5cbiAgICAgICAgICAgICAgICBtYXRjaCBmIGsgZCB3aXRoXG4gICAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICAgICAgfCBTb21lIG5ld19kIC0+XG4gICAgICAgICAgICAgICAgICAgIEguc2V0X2tleV9kYXRhIGMgayBuZXdfZDtcbiAgICAgICAgICAgICAgICAgICAgQ29ucyhoaywgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICBsZXQgbGVuZ3RoIGggPSBoLnNpemVcblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSByZXN0XG5cbiAgICBsZXQgc3RhdHMgaCA9XG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgYywgcmVzdCkgd2hlbiBILmNoZWNrX2tleSBjIC0+XG4gICAgICAgICAgYnVja2V0X2xlbmd0aF9hbGl2ZSAoYWNjdSArIDEpIHJlc3RcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoX2FsaXZlIGFjY3UgcmVzdFxuXG4gICAgbGV0IHN0YXRzX2FsaXZlIGggPVxuICAgICAgbGV0IHNpemUgPSByZWYgMCBpblxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYiBpblxuICAgICAgICAgICBzaXplIDo9ICFzaXplICsgbDtcbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSAhc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCB0b19zZXEgdGJsID1cbiAgICAgICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICAgICAgbGV0IHRibF9kYXRhID0gdGJsLmRhdGEgaW5cbiAgICAgICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gICAgICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgICAgICBlbHNlIGF1eChpKzEpIHRibF9kYXRhLihpKSAoKVxuICAgICAgICB8IENvbnMgKF8sIGMsIG5leHQpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhdXggaSBuZXh0ICgpXG4gICAgICAgICAgICAgIHwgU29tZSBrZXksIFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgYXV4IDAgRW1wdHlcblxuICAgIGxldCB0b19zZXFfa2V5cyBtID0gU2VxLm1hcCBmc3QgKHRvX3NlcSBtKVxuXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgZW5kXG5lbmRcblxubW9kdWxlIE9iakVwaCA9IE9iai5FcGhlbWVyb25cblxubGV0IF9vYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4geFxuICB8IFNvbWUgdiAtPiBTb21lIChPYmoub2JqIHYpXG5cbigqKiBUaGUgcHJldmlvdXMgZnVuY3Rpb24gaXMgdHlwZWQgc28gdGhpcyBvbmUgaXMgYWxzbyBjb3JyZWN0ICopXG5sZXQgb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPiBPYmoubWFnaWMgeFxuXG5cbm1vZHVsZSBLMSA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgMVxuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChrOidrKSA6IHVuaXQgPSBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKHQyOignaywnZCkgdCk6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnRcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggPSBILmhhc2hcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICAoKiB7IWdldF9rZXlfY29weX0gaXMgbm90IHVzZWQgYmVjYXVzZSB0aGUgZXF1YWxpdHkgb2YgdGhlIHVzZXIgY2FuIGJlXG4gICAgICAgICAgICB0aGUgcGh5c2ljYWwgZXF1YWxpdHkgKilcbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgaycgLT5cbiAgICAgICAgICAgIGlmIEguZXF1YWwgayBrJyB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSA9IGdldF9rZXlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgPSBjaGVja19rZXlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgSzIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2sxLCAnazIsICdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrMSwnazIsJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDJcblxuICBsZXQgZ2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXkxX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2sxKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBnZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAxKVxuICBsZXQgZ2V0X2tleTJfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMSlcbiAgbGV0IHNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSAoazonazIpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAxIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDFcbiAgbGV0IGNoZWNrX2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAxXG5cblxuICBsZXQgYmxpdF9rZXkxICh0MTooJ2sxLF8sXykgdCkgKHQyOignazEsXyxfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuICBsZXQgYmxpdF9rZXkyICh0MTooXywnazIsXykgdCkgKHQyOihfLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAxIHQyIDEgMVxuICBsZXQgYmxpdF9rZXkxMiAodDE6KCdrMSwnazIsXykgdCkgKHQyOignazEsJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAyXG5cbiAgbGV0IGdldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgKGQ6J2QpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLF8sJ2QpIHQpICh0MjooXyxfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWRcbiAgICAgIChIMTpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpXG4gICAgICAoSDI6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChIMS50LEgyLnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgxLnQgKiBIMi50XG4gICAgICBsZXQgY3JlYXRlIChrMSxrMikgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCAoazEsazIpID1cbiAgICAgICAgSDEuaGFzaCBzZWVkIGsxICsgSDIuaGFzaCBzZWVkIGsyICogNjU1OTlcbiAgICAgIGxldCBlcXVhbCBjIChrMSxrMikgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+XG4gICAgICAgICAgICBpZiBIMS5lcXVhbCBrMSBrMScgJiYgSDIuZXF1YWwgazIgazInXG4gICAgICAgICAgICB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT4gU29tZSAoazEnLCBrMicpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgKGsxLGsyKSBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9IGNoZWNrX2tleTEgYyAmJiBjaGVja19rZXkyIGNcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDE6IEhhc2h0YmwuSGFzaGVkVHlwZSkoSDI6IEhhc2h0YmwuSGFzaGVkVHlwZSk6XG4gICAgKFMgd2l0aCB0eXBlIGtleSA9IEgxLnQgKiBIMi50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZFxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDEudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgxLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMS5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDIudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgyLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMi5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLbiA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSBuIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSBuXG4gIGxldCBsZW5ndGggKGs6KCdrLCdkKSB0KSA6IGludCA9IE9iakVwaC5sZW5ndGgga1xuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgbilcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCBuKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgKGs6J2spIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCBuIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgblxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgblxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAobzE6aW50KSAodDI6KCdrLCdkKSB0KSAobzI6aW50KSAobDppbnQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIG8xIHQyIG8yIGxcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50IGFycmF5XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlIChBcnJheS5sZW5ndGggaykgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgayA9XG4gICAgICAgIGxldCBoID0gcmVmIDAgaW5cbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIGggOj0gSC5oYXNoIHNlZWQgay4oaSkgKiA2NTU5OSArICFoO1xuICAgICAgICBkb25lO1xuICAgICAgICAhaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgIGxldCBsZW4gID0gQXJyYXkubGVuZ3RoIGsgaW5cbiAgICAgICAgbGV0IGxlbicgPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gIT0gbGVuJyB0aGVuIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZWMgZXF1YWxfYXJyYXkgayBjIGkgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrLihpKSBraVxuICAgICAgICAgICAgICAgICAgdGhlbiBlcXVhbF9hcnJheSBrIGMgKGktMSlcbiAgICAgICAgICAgICAgICAgIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICAgIGluXG4gICAgICAgICAgZXF1YWxfYXJyYXkgayBjIChsZW4tMSlcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbGV0IGxlbiA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiA9IDAgdGhlbiBTb21lIFt8fF1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyAwIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBrMCAtPlxuICAgICAgICAgICAgICBsZXQgcmVjIGZpbGwgYSBpID1cbiAgICAgICAgICAgICAgICBpZiBpIDwgMSB0aGVuIFNvbWUgYVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgICAgICBhLihpKSA8LSBraTtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxsIGEgKGktMSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IGEgPSBBcnJheS5tYWtlIGxlbiBrMCBpblxuICAgICAgICAgICAgICBmaWxsIGEgKGxlbi0xKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9XG4gICAgICAgIGxldCByZWMgY2hlY2sgYyBpID1cbiAgICAgICAgICBpIDwgMCB8fCAoY2hlY2tfa2V5IGMgaSAmJiBjaGVjayBjIChpLTEpKSBpblxuICAgICAgICBjaGVjayBjIChsZW5ndGggYyAtIDEpXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQgYXJyYXkpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFyayBTaGlud2VsbCBhbmQgTGVvIFdoaXRlLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE1LS0yMDE2IEphbmUgU3RyZWV0IEdyb3VwIExMQyAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIHNwYWNldGltZV9lbmFibGVkIDogdW5pdCAtPiBib29sXG4gID0gXCJjYW1sX3NwYWNldGltZV9lbmFibGVkXCIgW0BAbm9hbGxvY11cblxubGV0IGVuYWJsZWQgPSBzcGFjZXRpbWVfZW5hYmxlZCAoKVxuXG5sZXQgaWZfc3BhY2V0aW1lX2VuYWJsZWQgZiA9XG4gIGlmIGVuYWJsZWQgdGhlbiBmICgpIGVsc2UgKClcblxubW9kdWxlIFNlcmllcyA9IHN0cnVjdFxuICB0eXBlIHQgPSB7XG4gICAgY2hhbm5lbCA6IG91dF9jaGFubmVsO1xuICAgIG11dGFibGUgY2xvc2VkIDogYm9vbDtcbiAgfVxuXG4gIGV4dGVybmFsIHdyaXRlX21hZ2ljX251bWJlciA6IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV93cml0ZV9tYWdpY19udW1iZXJcIlxuXG4gIGV4dGVybmFsIHJlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSA6IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWVcIlxuXG4gIGxldCBjcmVhdGUgfnBhdGggPVxuICAgIGlmIHNwYWNldGltZV9lbmFibGVkICgpIHRoZW4gYmVnaW5cbiAgICAgIGxldCBjaGFubmVsID0gb3Blbl9vdXQgcGF0aCBpblxuICAgICAgcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNoYW5uZWw7XG4gICAgICBsZXQgdCA9XG4gICAgICAgIHsgY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgICAgY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIGluXG4gICAgICB3cml0ZV9tYWdpY19udW1iZXIgdC5jaGFubmVsO1xuICAgICAgdFxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB7IGNoYW5uZWwgPSBzdGRvdXQ7ICAoKiBhcmJpdHJhcnkgdmFsdWUgKilcbiAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICBleHRlcm5hbCBzYXZlX2V2ZW50IDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gZXZlbnRfbmFtZTpzdHJpbmcgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfZXZlbnRcIlxuXG4gIGxldCBzYXZlX2V2ZW50ID90aW1lIHQgfmV2ZW50X25hbWUgPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIHNhdmVfZXZlbnQgP3RpbWUgdC5jaGFubmVsIH5ldmVudF9uYW1lKVxuXG4gIGV4dGVybmFsIHNhdmVfdHJpZSA6ID90aW1lOmZsb2F0IC0+IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV9zYXZlX3RyaWVcIlxuXG4gIGxldCBzYXZlX2FuZF9jbG9zZSA/dGltZSB0ID1cbiAgICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgICBpZiB0LmNsb3NlZCB0aGVuIGZhaWx3aXRoIFwiU2VyaWVzIGlzIGNsb3NlZFwiO1xuICAgICAgc2F2ZV90cmllID90aW1lIHQuY2hhbm5lbDtcbiAgICAgIGNsb3NlX291dCB0LmNoYW5uZWw7XG4gICAgICB0LmNsb3NlZCA8LSB0cnVlKVxuZW5kXG5cbm1vZHVsZSBTbmFwc2hvdCA9IHN0cnVjdFxuICBleHRlcm5hbCB0YWtlIDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3Rha2Vfc25hcHNob3RcIlxuXG4gIGxldCB0YWtlID90aW1lIHsgU2VyaWVzLmNsb3NlZDsgY2hhbm5lbCB9ID1cbiAgICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgICBpZiBjbG9zZWQgdGhlbiBmYWlsd2l0aCBcIlNlcmllcyBpcyBjbG9zZWRcIjtcbiAgICAgIEdjLm1pbm9yICgpO1xuICAgICAgdGFrZSA/dGltZSBjaGFubmVsKVxuZW5kXG5cbmV4dGVybmFsIHNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMgOiBldmVudF9uYW1lOnN0cmluZyAtPiB1bml0XG4gID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgXCJjYW1sX3NwYWNldGltZV9zYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzXCJcblxubGV0IHNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMgfmV2ZW50X25hbWUgPVxuICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyB+ZXZlbnRfbmFtZSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBNYW51ZWwgU2VycmFubyBldCBYYXZpZXIgTGVyb3ksIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDAgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtCaWdhcnJheV06IGxhcmdlLCBtdWx0aS1kaW1lbnNpb25hbCwgbnVtZXJpY2FsIGFycmF5cyAqKVxuXG4oKiBUaGVzZSB0eXBlcyBpbiBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB0YWJsZXMgaW5cbiAgIC4uL3R5cGluZy90eXBlb3B0Lm1sICopXG5cbnR5cGUgZmxvYXQzMl9lbHQgPSBGbG9hdDMyX2VsdFxudHlwZSBmbG9hdDY0X2VsdCA9IEZsb2F0NjRfZWx0XG50eXBlIGludDhfc2lnbmVkX2VsdCA9IEludDhfc2lnbmVkX2VsdFxudHlwZSBpbnQ4X3Vuc2lnbmVkX2VsdCA9IEludDhfdW5zaWduZWRfZWx0XG50eXBlIGludDE2X3NpZ25lZF9lbHQgPSBJbnQxNl9zaWduZWRfZWx0XG50eXBlIGludDE2X3Vuc2lnbmVkX2VsdCA9IEludDE2X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQzMl9lbHQgPSBJbnQzMl9lbHRcbnR5cGUgaW50NjRfZWx0ID0gSW50NjRfZWx0XG50eXBlIGludF9lbHQgPSBJbnRfZWx0XG50eXBlIG5hdGl2ZWludF9lbHQgPSBOYXRpdmVpbnRfZWx0XG50eXBlIGNvbXBsZXgzMl9lbHQgPSBDb21wbGV4MzJfZWx0XG50eXBlIGNvbXBsZXg2NF9lbHQgPSBDb21wbGV4NjRfZWx0XG5cbnR5cGUgKCdhLCAnYikga2luZCA9XG4gICAgRmxvYXQzMiA6IChmbG9hdCwgZmxvYXQzMl9lbHQpIGtpbmRcbiAgfCBGbG9hdDY0IDogKGZsb2F0LCBmbG9hdDY0X2VsdCkga2luZFxuICB8IEludDhfc2lnbmVkIDogKGludCwgaW50OF9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50OF91bnNpZ25lZCA6IChpbnQsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfc2lnbmVkIDogKGludCwgaW50MTZfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3Vuc2lnbmVkIDogKGludCwgaW50MTZfdW5zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MzIgOiAoaW50MzIsIGludDMyX2VsdCkga2luZFxuICB8IEludDY0IDogKGludDY0LCBpbnQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQgOiAoaW50LCBpbnRfZWx0KSBraW5kXG4gIHwgTmF0aXZlaW50IDogKG5hdGl2ZWludCwgbmF0aXZlaW50X2VsdCkga2luZFxuICB8IENvbXBsZXgzMiA6IChDb21wbGV4LnQsIGNvbXBsZXgzMl9lbHQpIGtpbmRcbiAgfCBDb21wbGV4NjQgOiAoQ29tcGxleC50LCBjb21wbGV4NjRfZWx0KSBraW5kXG4gIHwgQ2hhciA6IChjaGFyLCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuXG50eXBlIGNfbGF5b3V0ID0gQ19sYXlvdXRfdHlwXG50eXBlIGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRfdHlwICgqKilcblxudHlwZSAnYSBsYXlvdXQgPVxuICAgIENfbGF5b3V0OiBjX2xheW91dCBsYXlvdXRcbiAgfCBGb3J0cmFuX2xheW91dDogZm9ydHJhbl9sYXlvdXQgbGF5b3V0XG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9raW5kIGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBmbG9hdDMyID0gRmxvYXQzMlxubGV0IGZsb2F0NjQgPSBGbG9hdDY0XG5sZXQgaW50OF9zaWduZWQgPSBJbnQ4X3NpZ25lZFxubGV0IGludDhfdW5zaWduZWQgPSBJbnQ4X3Vuc2lnbmVkXG5sZXQgaW50MTZfc2lnbmVkID0gSW50MTZfc2lnbmVkXG5sZXQgaW50MTZfdW5zaWduZWQgPSBJbnQxNl91bnNpZ25lZFxubGV0IGludDMyID0gSW50MzJcbmxldCBpbnQ2NCA9IEludDY0XG5sZXQgaW50ID0gSW50XG5sZXQgbmF0aXZlaW50ID0gTmF0aXZlaW50XG5sZXQgY29tcGxleDMyID0gQ29tcGxleDMyXG5sZXQgY29tcGxleDY0ID0gQ29tcGxleDY0XG5sZXQgY2hhciA9IENoYXJcblxubGV0IGtpbmRfc2l6ZV9pbl9ieXRlcyA6IHR5cGUgYSBiLiAoYSwgYikga2luZCAtPiBpbnQgPSBmdW5jdGlvblxuICB8IEZsb2F0MzIgLT4gNFxuICB8IEZsb2F0NjQgLT4gOFxuICB8IEludDhfc2lnbmVkIC0+IDFcbiAgfCBJbnQ4X3Vuc2lnbmVkIC0+IDFcbiAgfCBJbnQxNl9zaWduZWQgLT4gMlxuICB8IEludDE2X3Vuc2lnbmVkIC0+IDJcbiAgfCBJbnQzMiAtPiA0XG4gIHwgSW50NjQgLT4gOFxuICB8IEludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IE5hdGl2ZWludCAtPiBTeXMud29yZF9zaXplIC8gOFxuICB8IENvbXBsZXgzMiAtPiA4XG4gIHwgQ29tcGxleDY0IC0+IDE2XG4gIHwgQ2hhciAtPiAxXG5cbigqIEtlZXAgdGhvc2UgY29uc3RhbnRzIGluIHN5bmMgd2l0aCB0aGUgY2FtbF9iYV9sYXlvdXQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGNfbGF5b3V0ID0gQ19sYXlvdXRcbmxldCBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBHZW5hcnJheSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0XG4gIGV4dGVybmFsIGNyZWF0ZTogKCdhLCAnYikga2luZCAtPiAnYyBsYXlvdXQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSB0XG4gICAgID0gXCJjYW1sX2JhX2NyZWF0ZVwiXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhXG4gICAgID0gXCJjYW1sX2JhX2dldF9nZW5lcmljXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiY2FtbF9iYV9zZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIG51bV9kaW1zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcImNhbWxfYmFfbnVtX2RpbXNcIlxuICBleHRlcm5hbCBudGhfZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX2JhX2RpbVwiXG4gIGxldCBkaW1zIGEgPVxuICAgIGxldCBuID0gbnVtX2RpbXMgYSBpblxuICAgIGxldCBkID0gQXJyYXkubWFrZSBuIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gbi0xIGRvIGQuKGkpIDwtIG50aF9kaW0gYSBpIGRvbmU7XG4gICAgZFxuXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoQXJyYXkuZm9sZF9sZWZ0ICggKiApIDEgKGRpbXMgYXJyKSlcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc2xpY2VfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IGFycmF5IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3NsaWNlXCJcbiAgZXh0ZXJuYWwgc2xpY2VfcmlnaHQ6ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5lbmRcblxubW9kdWxlIEFycmF5MCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8fF1cbiAgbGV0IGdldCBhcnIgPSBHZW5hcnJheS5nZXQgYXJyIFt8fF1cbiAgbGV0IHNldCBhcnIgPSBHZW5hcnJheS5zZXQgYXJyIFt8fF1cbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPSBraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKVxuXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG5cbiAgbGV0IG9mX3ZhbHVlIGtpbmQgbGF5b3V0IHYgPVxuICAgIGxldCBhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGluXG4gICAgc2V0IGEgdjtcbiAgICBhXG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbXxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMVwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzFcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8xXCJcbiAgZXh0ZXJuYWwgZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltIGFycilcblxuICBleHRlcm5hbCBzdWI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgJ2MpIHQgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlICh0eXBlIHQpIChhIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpIG4gPVxuICAgIG1hdGNoIGxheW91dCBhIHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF0gOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCAoQXJyYXkubGVuZ3RoIGRhdGEpIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZGF0YSAtIDEgZG8gdW5zYWZlX3NldCBiYSAoaSArIG9mcykgZGF0YS4oaSkgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMlwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8yXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnQgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodCBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5Mi5vZl9hcnJheTogbm9uLXJlY3Rhbmd1bGFyIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIHJvdy4oailcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMjsgZGltM3xdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8zXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV9zZXRfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzNcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzNcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGRpbTM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzNcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpICogKGRpbTMgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9yaWdodF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfbGVmdF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgZGltMyA9IGlmIGRpbTIgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICBsZXQgY29sID0gcm93LihqKSBpblxuICAgICAgICBpZiBBcnJheS5sZW5ndGggY29sIDw+IGRpbTMgdGhlblxuICAgICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgICAgZm9yIGsgPSAwIHRvIGRpbTMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIChrICsgb2ZzKSBjb2wuKGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkwOiAoJ2EsICdiLCAnYykgQXJyYXkwLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkxOiAoJ2EsICdiLCAnYykgQXJyYXkxLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkyOiAoJ2EsICdiLCAnYykgQXJyYXkyLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkzOiAoJ2EsICdiLCAnYykgQXJyYXkzLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxubGV0IGFycmF5MF9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDAgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTBfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5MV9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDEgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTFfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5Ml9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDIgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTJfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5M19vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDMgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTNfb2ZfZ2VuYXJyYXlcIlxuXG5leHRlcm5hbCByZXNoYXBlOlxuICAgKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiY2FtbF9iYV9yZXNoYXBlXCJcbmxldCByZXNoYXBlXzAgYSA9IHJlc2hhcGUgYSBbfHxdXG5sZXQgcmVzaGFwZV8xIGEgZGltMSA9IHJlc2hhcGUgYSBbfGRpbTF8XVxubGV0IHJlc2hhcGVfMiBhIGRpbTEgZGltMiA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMnxdXG5sZXQgcmVzaGFwZV8zIGEgZGltMSBkaW0yIGRpbTMgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTI7ZGltM3xdXG5cbigqIEZvcmNlIGNhbWxfYmFfZ2V0X3sxLDIsMyxOfSB0byBiZSBsaW5rZWQgaW4sIHNpbmNlIHdlIGRvbid0IHJlZmVyXG4gICB0byB0aG9zZSBwcmltaXRpdmVzIGRpcmVjdGx5IGluIHRoaXMgZmlsZSAqKVxuXG5sZXQgXyA9XG4gIGxldCBfID0gR2VuYXJyYXkuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkxLmdldCBpblxuICBsZXQgXyA9IEFycmF5Mi5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTMuZ2V0IGluXG4gICgpXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5leHRlcm5hbCBnZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzFcIlxuZXh0ZXJuYWwgZ2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8yXCJcbmV4dGVybmFsIGdldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfM1wiXG5leHRlcm5hbCBzZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzFcIlxuZXh0ZXJuYWwgc2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8yXCJcbmV4dGVybmFsIHNldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfM1wiXG4iLCJsZXQgdGFyaWYgPSBcIsOJdMOpIDIwMjBcIlxuXG5sZXQgZGVzdGluYXRhaXJlcyA9IFwiZHVidXZhbEBnbWFpbC5jb20sZ3V5LmdyYW5nZUB3YW5hZG9vLmZyXCJcblxudHlwZSBwaWVjZSA9IENoYW1icmUxIHwgQ2hhbWJyZTIgfCBDaGFtYnJlMyB8IFNlam91ciB8IFNkYjEgfCBTZGIyXG5cbmxldCBwaWVjZXMgPSBbIENoYW1icmUxOyBDaGFtYnJlMjsgQ2hhbWJyZTM7IFNlam91cjsgU2RiMTsgU2RiMiBdXG5cbmxldCBzaG9ydF9zdHJpbmdfb2ZfcGllY2UgPSBmdW5jdGlvblxuICB8IENoYW1icmUxIC0+IFwiY2gxXCJcbiAgfCBDaGFtYnJlMiAtPiBcImNoMlwiXG4gIHwgQ2hhbWJyZTMgLT4gXCJjaDNcIlxuICB8IFNlam91ciAtPiBcInNqXCJcbiAgfCBTZGIxIC0+IFwic2RiMVwiXG4gIHwgU2RiMiAtPiBcInNkYjJcIlxuXG5sZXQgbG9uZ19zdHJpbmdfb2ZfcGllY2UgPSBmdW5jdGlvblxuICB8IENoYW1icmUxIC0+IFwiQ2hhbWJyZSAxXCJcbiAgfCBDaGFtYnJlMiAtPiBcIkNoYW1icmUgMlwiXG4gIHwgQ2hhbWJyZTMgLT4gXCJDaGFtYnJlIDNcIlxuICB8IFNlam91ciAtPiBcIlPDqWpvdXJcIlxuICB8IFNkYjEgLT4gXCJTYWxsZSBkZSBiYWlucyAxXCJcbiAgfCBTZGIyIC0+IFwiU2FsbGUgZGUgYmFpbnMgMlwiXG5cbnR5cGUgZm91cm5pdHVyZSA9IHtcbiAgbmFtZSA6IHN0cmluZztcbiAgZGVzaWduYXRpb24gOiBzdHJpbmc7XG4gIHByaXggOiBpbnQ7XG4gIGRpc3BvbmliaWxpdGUgOiAocGllY2UgKiBpbnQpIGxpc3Q7XG59XG5cbmxldCBmb3Vybml0dXJlcyA9XG4gIFtcbiAgICB7XG4gICAgICBuYW1lID0gXCJkaDgwXCI7XG4gICAgICBkZXNpZ25hdGlvbiA9IFwiRHJhcCBob3Vzc2UgODAgY21cIjtcbiAgICAgIHByaXggPSA3O1xuICAgICAgZGlzcG9uaWJpbGl0ZSA9IFsgKENoYW1icmUxLCAyKSBdO1xuICAgIH07XG4gICAge1xuICAgICAgbmFtZSA9IFwiZGg5MFwiO1xuICAgICAgZGVzaWduYXRpb24gPSBcIkRyYXAgaG91c3NlIDkwIGNtXCI7XG4gICAgICBwcml4ID0gNztcbiAgICAgIGRpc3BvbmliaWxpdGUgPSBbIChDaGFtYnJlMywgNCkgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcImRoMTQwXCI7XG4gICAgICBkZXNpZ25hdGlvbiA9IFwiRHJhcCBob3Vzc2UgMTQwIGNtXCI7XG4gICAgICBwcml4ID0gMTU7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoQ2hhbWJyZTIsIDEpOyAoU2Vqb3VyLCAxKSBdO1xuICAgIH07XG4gICAge1xuICAgICAgbmFtZSA9IFwiZGhiYlwiO1xuICAgICAgZGVzaWduYXRpb24gPSBcIkRyYXAgaG91c3NlIGLDqWLDqVwiO1xuICAgICAgcHJpeCA9IDM7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoQ2hhbWJyZTEsIDEpIF07XG4gICAgfTtcbiAgICB7XG4gICAgICBuYW1lID0gXCJoYzFwXCI7XG4gICAgICBkZXNpZ25hdGlvbiA9IFwiSG91c3NlIGRlIGNvdWV0dGUgMSBwbGFjZVwiO1xuICAgICAgcHJpeCA9IDEwO1xuICAgICAgZGlzcG9uaWJpbGl0ZSA9IFsgKENoYW1icmUxLCAyKTsgKENoYW1icmUzLCA0KSBdO1xuICAgIH07XG4gICAge1xuICAgICAgbmFtZSA9IFwiaGMycFwiO1xuICAgICAgZGVzaWduYXRpb24gPSBcIkhvdXNzZSBkZSBjb3VldHRlIDIgcGxhY2VzXCI7XG4gICAgICBwcml4ID0gMTY7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoQ2hhbWJyZTIsIDEpOyAoU2Vqb3VyLCAxKSBdO1xuICAgIH07XG4gICAge1xuICAgICAgbmFtZSA9IFwiaGNiYlwiO1xuICAgICAgZGVzaWduYXRpb24gPSBcIkhvdXNzZSBkZSBjb3VldHRlIGLDqWLDqVwiO1xuICAgICAgcHJpeCA9IDQ7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoQ2hhbWJyZTEsIDEpIF07XG4gICAgfTtcbiAgICB7XG4gICAgICBuYW1lID0gXCJsaXRiYlwiO1xuICAgICAgZGVzaWduYXRpb24gPSBcIkxpdCBiw6liw6lcIjtcbiAgICAgIHByaXggPSAxMDtcbiAgICAgIGRpc3BvbmliaWxpdGUgPSBbIChDaGFtYnJlMSwgMSkgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcInBtODBcIjtcbiAgICAgIGRlc2lnbmF0aW9uID0gXCJQcm90w6hnZSBtYXRlbGFzIDgwIGNtXCI7XG4gICAgICBwcml4ID0gMDtcbiAgICAgIGRpc3BvbmliaWxpdGUgPSBbIChDaGFtYnJlMSwgMikgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcInBtOTBcIjtcbiAgICAgIGRlc2lnbmF0aW9uID0gXCJQcm90w6hnZSBtYXRlbGFzIDkwIGNtXCI7XG4gICAgICBwcml4ID0gMDtcbiAgICAgIGRpc3BvbmliaWxpdGUgPSBbIChDaGFtYnJlMywgNCkgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcInBtMTQwXCI7XG4gICAgICBkZXNpZ25hdGlvbiA9IFwiUHJvdMOoZ2UgbWF0ZWxhcyAxNDAgY21cIjtcbiAgICAgIHByaXggPSAwO1xuICAgICAgZGlzcG9uaWJpbGl0ZSA9IFsgKENoYW1icmUyLCAxKTsgKFNlam91ciwgMSkgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcInBtYmJcIjtcbiAgICAgIGRlc2lnbmF0aW9uID0gXCJQcm90w6hnZSBtYXRlbGFzIGLDqWLDqVwiO1xuICAgICAgcHJpeCA9IDA7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoQ2hhbWJyZTEsIDEpIF07XG4gICAgfTtcbiAgICB7XG4gICAgICBuYW1lID0gXCJ0YWllXCI7XG4gICAgICBkZXNpZ25hdGlvbiA9IFwiVGFpZSBk4oCZb3JlaWxsZXJcIjtcbiAgICAgIHByaXggPSAzO1xuICAgICAgZGlzcG9uaWJpbGl0ZSA9XG4gICAgICAgIFsgKENoYW1icmUxLCA0KTsgKENoYW1icmUyLCA0KTsgKENoYW1icmUzLCA4KTsgKFNlam91ciwgNCkgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcImRvdWNoZVwiO1xuICAgICAgZGVzaWduYXRpb24gPSBcIkRyYXAgZGUgZG91Y2hlXCI7XG4gICAgICBwcml4ID0gNDtcbiAgICAgIGRpc3BvbmliaWxpdGUgPSBbIChTZGIxLCAzKTsgKFNkYjIsIDMpIF07XG4gICAgfTtcbiAgICB7XG4gICAgICBuYW1lID0gXCJnYW50XCI7XG4gICAgICBkZXNpZ25hdGlvbiA9IFwiR2FudCBkZSB0b2lsZXR0ZVwiO1xuICAgICAgcHJpeCA9IDE7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoU2RiMSwgNCk7IChTZGIyLCA2KSBdO1xuICAgIH07XG4gICAge1xuICAgICAgbmFtZSA9IFwic2VydlwiO1xuICAgICAgZGVzaWduYXRpb24gPSBcIlNlcnZpZXR0ZSBkZSB0b2lsZXR0ZVwiO1xuICAgICAgcHJpeCA9IDM7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoU2RiMSwgNCk7IChTZGIyLCA2KSBdO1xuICAgIH07XG4gICAge1xuICAgICAgbmFtZSA9IFwiaW52XCI7XG4gICAgICBkZXNpZ25hdGlvbiA9IFwiU2VydmlldHRlIGludml0w6lzXCI7XG4gICAgICBwcml4ID0gMztcbiAgICAgIGRpc3BvbmliaWxpdGUgPSBbIChTZGIxLCAxKTsgKFNkYjIsIDEpIF07XG4gICAgfTtcbiAgICB7XG4gICAgICBuYW1lID0gXCJ0YXBpc1wiO1xuICAgICAgZGVzaWduYXRpb24gPSBcIlRhcGlzIGRlIGRvdWNoZVwiO1xuICAgICAgcHJpeCA9IDM7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoU2RiMSwgMik7IChTZGIyLCAyKSBdO1xuICAgIH07XG4gICAge1xuICAgICAgbmFtZSA9IFwibWFpbnNcIjtcbiAgICAgIGRlc2lnbmF0aW9uID0gXCJFc3N1aWUtbWFpbnNcIjtcbiAgICAgIHByaXggPSAyO1xuICAgICAgZGlzcG9uaWJpbGl0ZSA9IFsgKFNlam91ciwgMikgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcInRhYmxlXCI7XG4gICAgICBkZXNpZ25hdGlvbiA9IFwiU2VydmlldHRlcyBkZSB0YWJsZVwiO1xuICAgICAgcHJpeCA9IDI7XG4gICAgICBkaXNwb25pYmlsaXRlID0gWyAoU2Vqb3VyLCAxMCkgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcInRvcmNob25cIjtcbiAgICAgIGRlc2lnbmF0aW9uID0gXCJUb3JjaG9ucyDDoCB2YWlzc2VsbGVcIjtcbiAgICAgIHByaXggPSAyO1xuICAgICAgZGlzcG9uaWJpbGl0ZSA9IFsgKFNlam91ciwgMikgXTtcbiAgICB9O1xuICAgIHtcbiAgICAgIG5hbWUgPSBcIm1pY3JvZmlicmVcIjtcbiAgICAgIGRlc2lnbmF0aW9uID0gXCJUb3JjaG9ucyBtaWNyb2ZpYnJlXCI7XG4gICAgICBwcml4ID0gMDtcbiAgICAgIGRpc3BvbmliaWxpdGUgPSBbIChTZGIxLCAyKTsgKFNkYjIsIDIpOyAoU2Vqb3VyLCAyKSBdO1xuICAgIH07XG4gIF1cblxuIixudWxsLCJtb2R1bGUgSUwgPSBJbnZlbnRhaXJlX2xpbmdlXG5cbmxldCBzZXRfc3RyaW5nX2lucHV0X2J5X2lkIG5tIHYgPVxuICBtYXRjaFxuICAgIEpzX29mX29jYW1sLkRvbV9odG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBubVxuICAgICAgSnNfb2Zfb2NhbWwuRG9tX2h0bWwuQ29lcmNlVG8uaW5wdXRcbiAgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGlucCAtPiBpbnAjIy52YWx1ZSA6PSBKc19vZl9vY2FtbC5Kcy5zdHJpbmcgdlxuXG5sZXQgcmVhZF9zdHJpbmdfaW5wdXRfYnlfaWQgbm0gPVxuICBtYXRjaFxuICAgIEpzX29mX29jYW1sLkRvbV9odG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBubVxuICAgICAgSnNfb2Zfb2NhbWwuRG9tX2h0bWwuQ29lcmNlVG8uaW5wdXRcbiAgd2l0aFxuICB8IE5vbmUgLT4gXCJcIlxuICB8IFNvbWUgaW5wIC0+IGlucCMjLnZhbHVlIHw+IEpzX29mX29jYW1sLkpzLnRvX3N0cmluZ1xuXG5sZXQgemVyb19pbnRfaW5wdXRfYnlfaWQgbm0gPVxuICBtYXRjaFxuICAgIEpzX29mX29jYW1sLkRvbV9odG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBubVxuICAgICAgSnNfb2Zfb2NhbWwuRG9tX2h0bWwuQ29lcmNlVG8uc2VsZWN0XG4gIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBpbnAgLT4gaW5wIyMudmFsdWUgOj0gMCB8PiBzdHJpbmdfb2ZfaW50IHw+IEpzX29mX29jYW1sLkpzLnN0cmluZ1xuXG5sZXQgcmVhZF9pbnRfaW5wdXRfYnlfaWQgbm0gPVxuICBtYXRjaFxuICAgIEpzX29mX29jYW1sLkRvbV9odG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBubVxuICAgICAgSnNfb2Zfb2NhbWwuRG9tX2h0bWwuQ29lcmNlVG8uc2VsZWN0XG4gIHdpdGhcbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIGlucCAtPiBpbnAjIy52YWx1ZSB8PiBKc19vZl9vY2FtbC5Kcy50b19zdHJpbmcgfD4gaW50X29mX3N0cmluZ1xuXG5sZXQgc2V0X3RkX2J5X2lkIG5tIHYgPVxuICBtYXRjaFxuICAgIEpzX29mX29jYW1sLkRvbV9odG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBubVxuICAgICAgSnNfb2Zfb2NhbWwuRG9tX2h0bWwuQ29lcmNlVG8udGRcbiAgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHRkIC0+IHRkIyMuaW5uZXJIVE1MIDo9IEpzX29mX29jYW1sLkpzLnN0cmluZyB2XG5cbmxldCBmaWVsZF9pZF9ieV9mb3Vybml0dXJlIGYgPVxuICBsZXQgb3BlbiBJTCBpblxuICBmLmRpc3BvbmliaWxpdGVcbiAgfD4gTGlzdC5tYXAgKGZ1biAocCwgXykgLT4gZi5uYW1lIF4gXCJfXCIgXiBzaG9ydF9zdHJpbmdfb2ZfcGllY2UgcClcblxubGV0IGZpZWxkX2lkX2FuZF9waWVjZV9ieV9mb3Vybml0dXJlIGYgPVxuICBsZXQgb3BlbiBJTCBpblxuICBmLmRpc3BvbmliaWxpdGVcbiAgfD4gTGlzdC5tYXAgKGZ1biAocCwgXykgLT5cbiAgICAgICAgIChmLm5hbWUgXiBcIl9cIiBeIHNob3J0X3N0cmluZ19vZl9waWVjZSBwLCBsb25nX3N0cmluZ19vZl9waWVjZSBwKSlcblxubGV0IGFsbF9uYW1lcyA9IElMLmZvdXJuaXR1cmVzIHw+IExpc3QubWFwIGZpZWxkX2lkX2J5X2ZvdXJuaXR1cmUgfD4gTGlzdC5jb25jYXRcblxuKCogTWV0cyDDoCBqb3VyIGxlIGNvcnBzIGR1IG1haWwgKilcbmxldCBlbWFpbF9ib2R5ICgpID1cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDUwMCBpblxuICBQcmludGYuYnByaW50ZiBiXG4gICAgXCItLS0tLSBSw6lzZXJ2YXRpb24gbGluZ2UgRHVidXZhbCwgTGVzIHRlcnJhc3NlcyBkZXMgQ2hvc2VhdXgsIEFwcGFydGVtZW50IFxcXG4gICAgIEI2IC0tLS0tJSUwQVwiO1xuICBQcmludGYuYnByaW50ZiBiIFwiTG9jYXRhaXJlIDogJXMlJTBBXCIgKHJlYWRfc3RyaW5nX2lucHV0X2J5X2lkIFwibm9tX3ByZW5vbVwiKTtcbiAgUHJpbnRmLmJwcmludGYgYiBcIkRhdGUgZOKAmWFycml2w6llIDogJXMlJTBBXCJcbiAgICAocmVhZF9zdHJpbmdfaW5wdXRfYnlfaWQgXCJhcnJpdmVlXCIpO1xuICBQcmludGYuYnByaW50ZiBiIFwiRGF0ZSBkZSBkw6lwYXJ0IDogJXMlJTBBXCIgKHJlYWRfc3RyaW5nX2lucHV0X2J5X2lkIFwiZGVwYXJ0XCIpO1xuICBMaXN0LmZpbHRlcl9tYXBcbiAgICAoZnVuIGYgLT5cbiAgICAgIGZpZWxkX2lkX2FuZF9waWVjZV9ieV9mb3Vybml0dXJlIGZcbiAgICAgIHw+IExpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgIChmdW4gKHMsIGRldGFpbCkgKGZpZWxkX2lkLCBzaG9ydCkgLT5cbiAgICAgICAgICAgICBsZXQgcSA9IHJlYWRfaW50X2lucHV0X2J5X2lkIGZpZWxkX2lkIGluXG4gICAgICAgICAgICAgKCBzICsgcSxcbiAgICAgICAgICAgICAgIGlmIHEgPiAwIHRoZW4gKHNob3J0IF4gXCIgOiBcIiBeIHN0cmluZ19vZl9pbnQgcSkgOjogZGV0YWlsXG4gICAgICAgICAgICAgICBlbHNlIGRldGFpbCApKVxuICAgICAgICAgICAoMCwgW10pXG4gICAgICB8PiBmdW5jdGlvblxuICAgICAgfCAwLCBfIC0+IE5vbmVcbiAgICAgIHwgcSwgZGV0YWlsIC0+IFNvbWUgKGYuZGVzaWduYXRpb24sIHEsIGRldGFpbCkpXG4gICAgSUwuZm91cm5pdHVyZXNcbiAgfD4gTGlzdC5pdGVyIChmdW4gKGRlc2NyLCBxLCBkZXRhaWwpIC0+XG4gICAgICAgICBQcmludGYuYnByaW50ZiBiIFwi4oCUICVkICVzJXMlJTBBXCIgcSBkZXNjclxuICAgICAgICAgICAoIG1hdGNoIGRldGFpbCB3aXRoXG4gICAgICAgICAgIHwgW10gLT4gXCJcIlxuICAgICAgICAgICB8IF8gLT4gUHJpbnRmLnNwcmludGYgXCIgKCVzKVwiIChTdHJpbmcuY29uY2F0IFwiLCBcIiBkZXRhaWwpICkpO1xuICBQcmludGYuYnByaW50ZiBiIFwiJSUwQVRvdGFsIDogJWQg4oKsJSUwQVwiXG4gICAgKExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biB0b3RhbCBmIC0+XG4gICAgICAgICBmaWVsZF9pZF9ieV9mb3Vybml0dXJlIGZcbiAgICAgICAgIHw+IExpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgICAgIChmdW4gcyBmaWVsZF9pZCAtPiBzICsgcmVhZF9pbnRfaW5wdXRfYnlfaWQgZmllbGRfaWQpXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgIHw+ICggKiApIGYucHJpeCB8PiAoICsgKSB0b3RhbClcbiAgICAgICAwIElMLmZvdXJuaXR1cmVzKTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHVwZGF0ZV9tc2cgKCkgPVxuICBtYXRjaFxuICAgIEpzX29mX29jYW1sLkRvbV9odG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBcImJlbnZvaVwiXG4gICAgICBKc19vZl9vY2FtbC5Eb21faHRtbC5Db2VyY2VUby5hXG4gIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBhIC0+XG4gICAgICBhIyMuaHJlZiA6PVxuICAgICAgICBKc19vZl9vY2FtbC5Kcy5zdHJpbmdcbiAgICAgICAgICAoIFwibWFpbHRvOlwiIF4gSUwuZGVzdGluYXRhaXJlc1xuICAgICAgICAgIF4gXCI/c3ViamVjdD1Sw6lzZXJ2YXRpb24gbGluZ2UgRHVidXZhbCZib2R5PVwiIF4gZW1haWxfYm9keSAoKSApXG5cbigqIFJlLWNhbGN1bCAqKVxubGV0IGNvbXB1dGUgKCkgPVxuICBMaXN0Lml0ZXJcbiAgICAoZnVuIGYgLT5cbiAgICAgIGZpZWxkX2lkX2J5X2ZvdXJuaXR1cmUgZlxuICAgICAgfD4gTGlzdC5mb2xkX2xlZnQgKGZ1biBzIGZpZWxkX2lkIC0+IHMgKyByZWFkX2ludF9pbnB1dF9ieV9pZCBmaWVsZF9pZCkgMFxuICAgICAgfD4gZnVuIHF0ZSAtPlxuICAgICAgc2V0X3RkX2J5X2lkIGYuSUwubmFtZSAoKHF0ZSAqIGYucHJpeCB8PiBzdHJpbmdfb2ZfaW50KSBeIFwiwqDigqxcIik7XG4gICAgICBzdHJpbmdfb2ZfaW50IHF0ZSB8PiBzZXRfdGRfYnlfaWQgKGYuSUwubmFtZSBeIFwiX3F0ZVwiKSlcbiAgICBJTC5mb3Vybml0dXJlcztcbiAgTGlzdC5mb2xkX2xlZnRcbiAgICAoZnVuIHRvdGFsIGYgLT5cbiAgICAgIGZpZWxkX2lkX2J5X2ZvdXJuaXR1cmUgZlxuICAgICAgfD4gTGlzdC5mb2xkX2xlZnQgKGZ1biBzIGZpZWxkX2lkIC0+IHMgKyByZWFkX2ludF9pbnB1dF9ieV9pZCBmaWVsZF9pZCkgMFxuICAgICAgfD4gKCAqICkgZi5wcml4IHw+ICggKyApIHRvdGFsKVxuICAgIDAgSUwuZm91cm5pdHVyZXNcbiAgfD4gc3RyaW5nX29mX2ludCB8PiBGdW4uZmxpcCAoIF4gKSBcIsKg4oKsXCIgfD4gc2V0X3RkX2J5X2lkIFwidG90YWxcIjtcbiAgdXBkYXRlX21zZyAoKVxuXG5sZXQgcmVzZXRfZm9ybSAoKSA9XG4gIGxldCBkb2l0ID1cbiAgICBKc19vZl9vY2FtbC5Eb21faHRtbC53aW5kb3cjI2NvbmZpcm1cbiAgICAgIChKc19vZl9vY2FtbC5Kcy5zdHJpbmcgXCJSw6lpbml0aWFsaXNlciBjb21wbMOodGVtZW50IGxlIGZvcm11bGFpcmUgP1wiKVxuICAgIHw+IEpzX29mX29jYW1sLkpzLnRvX2Jvb2xcbiAgaW5cbiAgaWYgZG9pdCB0aGVuIChcbiAgICBzZXRfc3RyaW5nX2lucHV0X2J5X2lkIFwibm9tX3ByZW5vbVwiIFwiXCI7XG4gICAgc2V0X3N0cmluZ19pbnB1dF9ieV9pZCBcImFycml2ZWVcIiBcIlwiO1xuICAgIHNldF9zdHJpbmdfaW5wdXRfYnlfaWQgXCJkZXBhcnRcIiBcIlwiO1xuICAgIGFsbF9uYW1lcyB8PiBMaXN0Lml0ZXIgemVyb19pbnRfaW5wdXRfYnlfaWQ7XG4gICAgY29tcHV0ZSAoKSApXG5cbmxldCBfID1cbiAgSnNfb2Zfb2NhbWwuSnMuZXhwb3J0IFwiY29tcHV0ZVwiIGNvbXB1dGU7XG4gIEpzX29mX29jYW1sLkpzLmV4cG9ydCBcInJlc2V0X2Zvcm1cIiByZXNldF9mb3JtXG4iXX0=
//]]>

  </script>
  <div>
   <p><b>Tarifs de location du linge — SCI Dubuval — Été 2020</b></p>
   <br/>
   <p>
    <b>
     Si nécessaire, complétez ce formulaire dès la réservation, puis
     cliquez sur le bouton « Envoi par courriel » situé en bas de page
     pour nous l’envoyer par courriel.
    </b><br/>
    Si jamais le bouton d’envoi par courriel ne fonctionne pas, vous pouvez
    nous envoyer une copie d’écran du tableau complété à la place.
   </p>
   <p>Votre demande est modifiable jusqu’à 7 jours avant votre arrivée.
   </p>
   <p>
    <b>
     Le montant sera réglé directement à la Société Guy Grange le jour
     de votre arrivée.
    </b>
   </p><br/>
   <p>
    <button type="button" onclick="reset_form()">Réinitialiser le formulaire
    </button>
   </p><br/>
   <table>
    <tr><td><b>Nom et prénom du locataire : </b></td>
     <td><input id="nom_prenom" onchange="compute()"/></td>
    </tr>
    <tr><td><b>Date d’arrivée (aaaa-mm-jj) : </b></td>
     <td><input id="arrivee" onchange="compute()"/></td>
    </tr>
    <tr><td><b>Date de départ (aaaa-mm-jj) : </b></td>
     <td><input id="depart" onchange="compute()"/></td>
    </tr>
   </table>
  </div>
  <div><br/>
   <table class="montablo">
    <tr class="gras"><td></td><td>Prix unitaire</td><td>Chambre 1</td>
     <td>Chambre 2</td><td>Chambre 3</td><td>Séjour</td>
     <td>Salle de bains 1</td><td>Salle de bains 2</td><td>Quantités</td>
     <td>Totaux</td>
    </tr>
    <tr><td class="gras">Drap housse 80 cm</td><td id="dh80_prix">7 €</td>
     <td>
      <select id="dh80_ch1" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
      </select>
     </td><td></td><td></td><td></td><td></td><td></td>
     <td id="dh80_qte"></td><td id="dh80"></td>
    </tr>
    <tr><td class="gras">Drap housse 90 cm</td><td id="dh90_prix">7 €</td>
     <td></td><td></td>
     <td>
      <select id="dh90_ch3" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
       <option value="3">3</option><option value="4">4</option>
      </select>
     </td><td></td><td></td><td></td><td id="dh90_qte"></td>
     <td id="dh90"></td>
    </tr>
    <tr><td class="gras">Drap housse 140 cm</td>
     <td id="dh140_prix">15 €</td><td></td>
     <td>
      <select id="dh140_ch2" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
      </select>
     </td><td></td>
     <td>
      <select id="dh140_sj" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td><td></td><td></td><td id="dh140_qte"></td><td id="dh140"></td>
    </tr>
    <tr><td class="gras">Drap housse bébé</td><td id="dhbb_prix">3 €</td>
     <td>
      <select id="dhbb_ch1" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td><td></td><td></td><td></td><td></td><td></td>
     <td id="dhbb_qte"></td><td id="dhbb"></td>
    </tr>
    <tr><td class="gras">Housse de couette 1 place</td>
     <td id="hc1p_prix">10 €</td>
     <td>
      <select id="hc1p_ch1" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
      </select>
     </td><td></td>
     <td>
      <select id="hc1p_ch3" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
       <option value="3">3</option><option value="4">4</option>
      </select>
     </td><td></td><td></td><td></td><td id="hc1p_qte"></td>
     <td id="hc1p"></td>
    </tr>
    <tr><td class="gras">Housse de couette 2 places</td>
     <td id="hc2p_prix">16 €</td><td></td>
     <td>
      <select id="hc2p_ch2" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td><td></td>
     <td>
      <select id="hc2p_sj" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td><td></td><td></td><td id="hc2p_qte"></td><td id="hc2p"></td>
    </tr>
    <tr><td class="gras">Housse de couette bébé</td>
     <td id="hcbb_prix">4 €</td>
     <td>
      <select id="hcbb_ch1" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td><td></td><td></td><td></td><td></td><td></td>
     <td id="hcbb_qte"></td><td id="hcbb"></td>
    </tr>
    <tr><td class="gras">Lit bébé</td><td id="litbb_prix">10 €</td>
     <td>
      <select id="litbb_ch1" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
      </select>
     </td><td></td><td></td><td></td><td></td><td></td>
     <td id="litbb_qte"></td><td id="litbb"></td>
    </tr>
    <tr><td class="gras">Protège matelas 80 cm</td>
     <td id="pm80_prix">0 €</td>
     <td>
      <select id="pm80_ch1" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
      </select>
     </td><td></td><td></td><td></td><td></td><td></td>
     <td id="pm80_qte"></td><td id="pm80"></td>
    </tr>
    <tr><td class="gras">Protège matelas 90 cm</td>
     <td id="pm90_prix">0 €</td><td></td><td></td>
     <td>
      <select id="pm90_ch3" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
       <option value="3">3</option><option value="4">4</option>
      </select>
     </td><td></td><td></td><td></td><td id="pm90_qte"></td>
     <td id="pm90"></td>
    </tr>
    <tr><td class="gras">Protège matelas 140 cm</td>
     <td id="pm140_prix">0 €</td><td></td>
     <td>
      <select id="pm140_ch2" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
      </select>
     </td><td></td>
     <td>
      <select id="pm140_sj" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td><td></td><td></td><td id="pm140_qte"></td><td id="pm140"></td>
    </tr>
    <tr><td class="gras">Protège matelas bébé</td>
     <td id="pmbb_prix">0 €</td>
     <td>
      <select id="pmbb_ch1" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td><td></td><td></td><td></td><td></td><td></td>
     <td id="pmbb_qte"></td><td id="pmbb"></td>
    </tr>
    <tr><td class="gras">Taie d’oreiller</td><td id="taie_prix">3 €</td>
     <td>
      <select id="taie_ch1" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
       <option value="3">3</option><option value="4">4</option>
      </select>
     </td>
     <td>
      <select id="taie_ch2" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
       <option value="3">3</option><option value="4">4</option>
      </select>
     </td>
     <td>
      <select id="taie_ch3" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
       <option value="3">3</option><option value="4">4</option>
       <option value="5">5</option><option value="6">6</option>
       <option value="7">7</option><option value="8">8</option>
      </select>
     </td>
     <td>
      <select id="taie_sj" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
       <option value="3">3</option><option value="4">4</option>
      </select>
     </td><td></td><td></td><td id="taie_qte"></td><td id="taie"></td>
    </tr>
    <tr><td class="gras">Drap de douche</td><td id="douche_prix">4 €</td>
     <td></td><td></td><td></td><td></td>
     <td>
      <select id="douche_sdb1" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option><option value="3">3</option>
      </select>
     </td>
     <td>
      <select id="douche_sdb2" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option><option value="3">3</option>
      </select>
     </td><td id="douche_qte"></td><td id="douche"></td>
    </tr>
    <tr><td class="gras">Gant de toilette</td><td id="gant_prix">1 €</td>
     <td></td><td></td><td></td><td></td>
     <td>
      <select id="gant_sdb1" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option><option value="3">3</option>
       <option value="4">4</option>
      </select>
     </td>
     <td>
      <select id="gant_sdb2" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option><option value="3">3</option>
       <option value="4">4</option><option value="5">5</option>
       <option value="6">6</option>
      </select>
     </td><td id="gant_qte"></td><td id="gant"></td>
    </tr>
    <tr><td class="gras">Serviette de toilette</td>
     <td id="serv_prix">3 €</td><td></td><td></td><td></td><td></td>
     <td>
      <select id="serv_sdb1" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option><option value="3">3</option>
       <option value="4">4</option>
      </select>
     </td>
     <td>
      <select id="serv_sdb2" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option><option value="3">3</option>
       <option value="4">4</option><option value="5">5</option>
       <option value="6">6</option>
      </select>
     </td><td id="serv_qte"></td><td id="serv"></td>
    </tr>
    <tr><td class="gras">Serviette invités</td><td id="inv_prix">3 €</td>
     <td></td><td></td><td></td><td></td>
     <td>
      <select id="inv_sdb1" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td>
     <td>
      <select id="inv_sdb2" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option>
      </select>
     </td><td id="inv_qte"></td><td id="inv"></td>
    </tr>
    <tr><td class="gras">Tapis de douche</td><td id="tapis_prix">3 €</td>
     <td></td><td></td><td></td><td></td>
     <td>
      <select id="tapis_sdb1" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option>
      </select>
     </td>
     <td>
      <select id="tapis_sdb2" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option>
      </select>
     </td><td id="tapis_qte"></td><td id="tapis"></td>
    </tr>
    <tr><td class="gras">Essuie-mains</td><td id="mains_prix">2 €</td>
     <td></td><td></td><td></td>
     <td>
      <select id="mains_sj" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
      </select>
     </td><td></td><td></td><td id="mains_qte"></td><td id="mains"></td>
    </tr>
    <tr><td class="gras">Serviettes de table</td>
     <td id="table_prix">2 €</td><td></td><td></td><td></td>
     <td>
      <select id="table_sj" onchange="compute()"><option value="0">0</option>
       <option value="1">1</option><option value="2">2</option>
       <option value="3">3</option><option value="4">4</option>
       <option value="5">5</option><option value="6">6</option>
       <option value="7">7</option><option value="8">8</option>
       <option value="9">9</option><option value="10">10</option>
      </select>
     </td><td></td><td></td><td id="table_qte"></td><td id="table"></td>
    </tr>
    <tr><td class="gras">Torchons à vaisselle</td>
     <td id="torchon_prix">2 €</td><td></td><td></td><td></td>
     <td>
      <select id="torchon_sj" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option>
      </select>
     </td><td></td><td></td><td id="torchon_qte"></td><td id="torchon"></td>
    </tr>
    <tr><td class="gras">Torchons microfibre</td>
     <td id="microfibre_prix">0 €</td><td></td><td></td><td></td>
     <td>
      <select id="microfibre_sj" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option>
      </select>
     </td>
     <td>
      <select id="microfibre_sdb1" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option>
      </select>
     </td>
     <td>
      <select id="microfibre_sdb2" onchange="compute()">
       <option value="0">0</option><option value="1">1</option>
       <option value="2">2</option>
      </select>
     </td><td id="microfibre_qte"></td><td id="microfibre"></td>
    </tr>
    <tr><td class="gras">Totaux</td><td></td><td></td><td></td><td></td>
     <td></td><td></td><td></td><td></td><td id="total"></td>
    </tr>
    <tr class="gras"><td></td><td>Prix unitaire</td><td>Chambre 1</td>
     <td>Chambre 2</td><td>Chambre 3</td><td>Séjour</td>
     <td>Salle de bains 1</td><td>Salle de bains 2</td><td>Quantités</td>
     <td>Totaux</td>
    </tr>
   </table><br/>
   <a id="benvoi"><button type="button">Envoi par courriel</button></a>
  </div>
 </body>
